

These are some notes for myself\-:

\subsection*{Hosted Forth}


\begin{DoxyItemize}
\item Separate out all the code for a hosted desktop into another file to simplify things
\end{DoxyItemize}


\begin{DoxyItemize}
\item For the hosted forth remove sys calls and put them in the hosted section, a lot of the sys calls I have are only available for a hosted platform.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Remove all fprintfs?
\end{DoxyItemize}

\section*{General}


\begin{DoxyItemize}
\item do...loop should be able to be nested.
\end{DoxyItemize}


\begin{DoxyItemize}
\item print \char`\"{}ok\char`\"{} after each loop?
\end{DoxyItemize}


\begin{DoxyItemize}
\item Define \char`\"{}recurse\char`\"{}
\end{DoxyItemize}


\begin{DoxyItemize}
\item Replace all memory operations with functions to check if it with in bounds first, same with all stack operations.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Turn \#define T\-R\-U\-E into enums, replace function returns with bool type where I can.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Simplify I/\-O redirection...
\end{DoxyItemize}


\begin{DoxyItemize}
\item Documentation. This should be exhaustive, every enum should be documented as the this program might be used as a library where only the header is available. Also expand the file \char`\"{}\-M\-A\-N\-U\-A\-L.\-md\char`\"{}, which should contain the main manual.
\end{DoxyItemize}

Rename \char`\"{}!var\char`\"{}.


\begin{DoxyItemize}
\item On an error (on\-\_\-err) all the input streams that have not been closed properly should be. They currently are not, be careful not to close file pointers twice.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Test strnequ, rename, remove calls and functions.
\end{DoxyItemize}

strnequ should have an absolute address which it can not pass instead of a maximum length as should a few other words.


\begin{DoxyItemize}
\item S\-I\-G\-F\-P\-E on ( minimal value of int / -\/1 ). Needs checking. try\-: 1 31 lshift -\/1 /
\end{DoxyItemize}


\begin{DoxyItemize}
\item Special text encoding for strings and help messages. Space, e, t, a, o, i, n, ... (Encoding based on word frequency, Huffman).
\end{DoxyItemize}


\begin{DoxyItemize}
\item String manipulation words.
\end{DoxyItemize}

I should not go out of my way to do so, just renaming a few things and checking how a few words behave.


\begin{DoxyItemize}
\item Pushes and Pops should be put in there own functions, it would save duplicating so much checking code.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Eval()
\end{DoxyItemize}


\begin{DoxyItemize}
\item The dictionary could be implemented with a 16-\/bit hash instead to save space.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Possible ways of decreasing compile time and why\-:
\end{DoxyItemize}

The search algorithm used in the dictionary search is incredibly simple, changing it so searches are quicker would speed compilation up potentially greatly. At the moment it is a simple link list of strings. Here are some ways of changing the search function\-:

Use hashes (length depending on machine word choice, this would have to selected at compile time), a simple hash of the string could be stored instead of the string itself to reduce the string comparison to one of an equality test.

Move more commonly used words higher up in the dictionary space so they are found quicker, this may reduce average search times.

Binary search.

I would like to make a compromise between complexity and performance.

Using the following and a test rotating X\-O\-R hash available from \href{http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx}{\tt here}

\begin{DoxyVerb}  : hash \ Hashes a string, rotating XOR hash
      0 hvar !dic
      begin
          dup @str dup 0= \ if null
          if
              2drop 1       
          else

              hvar @dic 4 lshift hvar @dic 28 rshift xor
              xor hvar !dic 1+ 0
          then
      until
      hvar @dic
  ;

  : words
      tabvar pwd @reg 
      begin
          dup 1+ @dic dup hash prnn 32 emit prn cr
          @dic dup 0=   
      until
      cr
      2drop
  ;

  foutput words.log
  words\end{DoxyVerb}


Then\-:

\begin{DoxyVerb}    awk '{ print $1 }' words.log | sort | uniq -d\end{DoxyVerb}


We can see collisions, which should exclude the command 'words' itself due to both its redefinition and a quirk. This hash fails the test, 'immediate' and '\-\_\-immediate' and 'immediate' both hash to the same value. 