

Author\-:


\begin{DoxyItemize}
\item Richard James Howe.
\end{DoxyItemize}

Copyright\-:


\begin{DoxyItemize}
\item Copyright 2013 Richard James Howe.
\end{DoxyItemize}

License\-:


\begin{DoxyItemize}
\item L\-G\-P\-L
\end{DoxyItemize}

Email(s)\-:


\begin{DoxyItemize}
\item \href{mailto:howe.r.j.89@googlemail.com}{\tt howe.\-r.\-j.\-89@googlemail.\-com}
\end{DoxyItemize}

\subsection*{Intro}

This is a small \href{https://en.wikipedia.org/wiki/FORTH}{\tt F\-O\-R\-T\-H} implementation called {\bfseries Howe Forth}, it is written in C with the aim of being portable, even to radically different systems from the normal desktop to embedded systems with very few modifications.

This interpreter traces its lineage back to an entry from the \href{http://www.ioccc.org/winners.html}{\tt I\-O\-C\-C\-C}. A person submitting under the name {\bfseries buzzard} entered two winning entries, one listed as {\itshape buzzard.\-2} in the year 1992 was a small F\-O\-R\-T\-H interpreter, this one is a relative of it.

The interpreter should execute fairly quickly, more in due to its small size as opposed and sparse feature set. I have not performed any benchmarks however.

As I am working and updating the interpreter this documentation is going to lag behind that and may go out of date, although it should not do so horrendously. Also please do bear in mind that although this is a text file, it is written in \href{http://daringfireball.net/projects/markdown/}{\tt markdown}, so some characters such as \begin{DoxyVerb}_ * < > \ 
\end{DoxyVerb}


And a few other might have to be escaped, in fact the above symbols {\itshape are} escaped and should appear as verbatim due to the indentation at the beginning on the line, anywhere else they appear they should be escape with the backslash so they get converted to H\-T\-M\-L correctly (which if you are reading the H\-T\-M\-L you will not even notice and you can disregard the notice about markdown).

\subsection*{C Program}

\subsubsection*{G\-C\-C Options}

The program is compiled with the following flags\-: \begin{DoxyVerb}-ansi -g -Wall -Wno-write-strings -Wshadow -Wextra -pedantic -O2
\end{DoxyVerb}


With \href{http://gcc.gnu.org/}{\tt G\-C\-C}.

There are some extra options that can be added on, both of which are simply defining macros. \begin{DoxyVerb}-DRUN4X
\end{DoxyVerb}


This definition enables a cycle counter, the forth virtual machine will exit when the counter is less than zero, it is automatically decrement each time a primitive is run. It does not denote real time spent as each primitive has a variable run time. The forth programming running can enable or disable this counter, as well as update it. \begin{DoxyVerb}-DEBUG_PRN
\end{DoxyVerb}


This definition enables a function the runs after the virtual machine has exited. It simply writes out all of the memory in hexadecimal encoded A\-S\-C\-I\-I with a little bit of formatting to a file called \char`\"{}memory.\-txt\char`\"{}.

\subsubsection*{\hyperlink{forth_8c}{forth.\-c}}

This file implements the forth virtual machine, it is a threaded code interpreter. It provides mechanisms for error handling and recovery, an interface for system calls and input and output redirection.

\subsubsection*{\hyperlink{forth_8h}{forth.\-h}}

Contained in this file are the usual things needed for interfacing with a library; definitions of structures, \#define macros, typedefs, function prototypes and the like. There is no executable code in here.

To use this code in your program you must first include \char`\"{}stdio.\-h\char`\"{} then include \char`\"{}forth.\-h\char`\"{}. \char`\"{}desktop.\-c\char`\"{} contains an example of how to initialize the interpreter memory, I will give a short example of what to do with reference to the code. \begin{DoxyVerb}fobj_t *forth_obj_create(mw reg_l, mw dic_l, mw var_l, mw ret_l, mw str_l)
{
    /*the vm forth object */
    int i = 0;
    fobj_t *fo = calloc(1, sizeof(fobj_t));

    /*setting i/o streams */
    for (i = 0; i < MAX_INSTRM; i++) {
            fo->in_file[i] = calloc(1, sizeof(fio_t));
            CALLOC_FAIL(fo->in_file[i], NULL);
            fo->in_file[i]->fio = io_stdin;
    }

    fo->out_file = calloc(1, sizeof(fio_t));
    fo->err_file = calloc(1, sizeof(fio_t));

    fo->in_file[0]->fio = io_stdin;
    fo->out_file->fio = io_stdout;
    fo->err_file->fio = io_stderr;

    /*memories of the interpreter */
    fo->reg = calloc(reg_l, sizeof(mw));
    fo->dic = calloc(dic_l, sizeof(mw));
    fo->var = calloc(var_l, sizeof(mw));
    fo->ret = calloc(ret_l, sizeof(mw));
    fo->str = calloc(str_l, sizeof(char));

    /*initialize input file, fclose is handled elsewhere */
    fo->in_file[1]->fio = io_rd_file;
    if ((fo->in_file[1]->iou.f = fopen("forth.4th", "r")) == NULL) {
            fprintf(stderr, "Unable to open initial input file!\n");
            return NULL;
    }

    /*initializing memory */
    fo->reg[ENUM_maxReg] = reg_l;
    fo->reg[ENUM_maxDic] = dic_l;
    fo->reg[ENUM_maxVar] = var_l;
    fo->reg[ENUM_maxRet] = ret_l;
    fo->reg[ENUM_maxStr] = str_l;
    fo->reg[ENUM_inputBufLen] = 32;
    fo->reg[ENUM_dictionaryOffset] = 4;
    fo->reg[ENUM_sizeOfMW] = sizeof(mw);
    fo->reg[ENUM_INI] = true;
    fo->reg[ENUM_cycles] = false;   /*Run for X amount of cycles turned off by default. */
    fo->reg[ENUM_ccount] = 0;       /*Run for X amount of cycles turned off by default. */
    fo->reg[ENUM_inStrm] = 1;

    fprintf(stderr, "\tOBJECT INITIALIZED.\n");
    return fo;
}
\end{DoxyVerb}


For brevities sake checking whether \char`\"{}calloc()\char`\"{} worked it omitted. This function \char`\"{}forth\-\_\-obj\-\_\-create()\char`\"{} takes in a list of lengths for each of the arrays, which will be checked by the interpreter when called to see if they meet a list of minimum requirements, and allocates memory for them, that much is obvious.

Of interest however is what \char`\"{}reg\mbox{[}\-X\mbox{]}\char`\"{} is being set to and why and what do \char`\"{}in\-\_\-file\char`\"{}, \char`\"{}out\-\_\-file\char`\"{} and \char`\"{}err\-\_\-file\char`\"{} do. The latter are objects which contain descriptions of where the input, output and the error streams are to be sent to. You can read or write to \char`\"{}stdin\char`\"{}, \char`\"{}stdout\char`\"{} and \char`\"{}stderr\char`\"{} (if possible), to strings or to file streams.

Each \char`\"{}reg\mbox{[}\-X\mbox{]}\char`\"{} value is going to require explaining.

All M\-A\-X\-\_\-\-X Assignments tell the forth virtual machine what the maximum offset is for each array passed to it. \begin{DoxyVerb}fo->reg[ENUM_maxReg] = MAX_REG;
fo->reg[ENUM_maxDic] = MAX_DIC;
fo->reg[ENUM_maxVar] = MAX_VAR;
fo->reg[ENUM_maxRet] = MAX_RET;
fo->reg[ENUM_maxStr] = MAX_STR;
\end{DoxyVerb}


\char`\"{}input\-Buf\-Len\char`\"{} is the length of the input buffer, it limits how big a defined word can be as well as some other things. \begin{DoxyVerb}fo->reg[ENUM_inputBufLen] = 32;
\end{DoxyVerb}


The first four cells in the dictionary should be zero, this is the offset into that dictionary. The reason for this is that it contains a fake dictionary word which pushes zero if accidentally run, points to itself, points to the currently processed word in string storage and will run the first virtual machine instruction when called 'push', although this information is not necessary for the anything, just set it to '4'. \begin{DoxyVerb}fo->reg[ENUM_dictionaryOffset] = 4;
\end{DoxyVerb}


Simply the size of the forth virtual machines machine word. It should be at least two bytes big, preferably signed (if unsigned many warnings will be present, but apart from that there should be no problems). \begin{DoxyVerb}fo->reg[ENUM_sizeOfMW] = sizeof(mw);
\end{DoxyVerb}


This sets a flag to be true, when the \char`\"{}\-I\-N\-I\char`\"{} flag is true the first time the function \char`\"{}forth\-\_\-interpreter()\char`\"{} is run it will attempt to set up the forth environment to an initial state (by calling \char`\"{}forth\-\_\-initialize()\char`\"{}). This checks whether the minimum memory requirements are met, sets up some other registers to their initial values, it also gets a list of symbols to be used the forth virtual machine -\/ that is you can change their name to what you want. It finally creates a forth function that calls a primitive called 'read' which then calls itself ('read' makes sure the return stack does not blow up). \begin{DoxyVerb}fo->reg[ENUM_INI] = true;
\end{DoxyVerb}


When compiled with the flag \char`\"{}-\/\-D\-R\-U\-N4\-X\char`\"{} each time a primitive is run and 'cycles' is enabled a counter is decrement when this is less than zero \char`\"{}forth\-\_\-interpreter()\char`\"{} will exit. This makes sure it starts out as false. \begin{DoxyVerb}fo->reg[ENUM_cycles] = false; 
fo->reg[ENUM_ccount] = 0; 
\end{DoxyVerb}


As there is one file opened as input, this file must be put on the input file stack, it will be removed once the E\-O\-F has been reached. This simply indicates there is one file on the stack. \begin{DoxyVerb}fo->reg[ENUM_inStrm] = 1;
\end{DoxyVerb}


\subsubsection*{desktop.\-c}

This file simply contains a way to setup the library; it allocates all the needed memory, sets up the initial input file stream (a file called {\bfseries forth.\-4th}) and finally sets up some sane starting variables for the allocated memory.

Having done this it then runs the interpreter, when it exits it will display the functions return value and then destroys the object given to it. The interpreter itself will close the initial input file {\bfseries forth.\-4th} when it reaches a E\-O\-F character.

\subsubsection*{\hyperlink{main_8c}{main.\-c}}

\char`\"{}main.\-c\char`\"{} calls the functions in \char`\"{}desktop.\-c\char`\"{} then exits, it is more complicated than it {\itshape needs} to be as it contains debugging information which is optionally compiled in, the example below could serve as an adequate replacement. \begin{DoxyVerb}#include <stdio.h>      /* required by hosted.h and forth.h */
#include <stdlib.h>     /* required by hosted.h */
#include "lib/forth.h"  /* forth_monitor, fobj_t */
#include "lib/hosted.h" /* forth_obj_create, forth_obj_destroy */

#define MAX_REG 32
#define MAX_DIC (1024*1024)
#define MAX_VAR 8192
#define MAX_RET 8192
#define MAX_STR (1024*1024)

int main(void){
    fobj_t *fo;
    fo = forth_obj_create(MAX_REG, MAX_DIC, MAX_VAR, MAX_RET, MAX_STR);
    if(NULL == fo)
      return 1;
    forth_monitor(fo);
    forth_obj_destroy(fo);
    return 0;
}
\end{DoxyVerb}


\subsubsection*{Forth primitives}

\begin{DoxyVerb}  ":": 
\end{DoxyVerb}


This does two things;


\begin{DoxyEnumerate}
\item Compiles a header for the next space delimited word in the input stream into the dictionary.
\item Enter compile mode, instead of executing words that are found and pushing numbers onto the stack, compile are pointer to those words and literals into the dictionary. \begin{DoxyVerb}   "immediate":
\end{DoxyVerb}

\end{DoxyEnumerate}

Make the word just compiled {\itshape immediate}, an immediate word will execute regardless of whether or not we are in compile or command mode. Unlike in normal F\-O\-R\-T\-Hs this word is called just after the definition of the header instead of after the definition of the entire word, so like this\-: \begin{DoxyVerb}: define_me immediate ...
\end{DoxyVerb}


And not\-: \begin{DoxyVerb}: define_me ... ; immediate
\end{DoxyVerb}


This is a difference I should have to change so it conforms better, but I will not be doing that for now. \begin{DoxyVerb}   "read":
\end{DoxyVerb}


This reads in a single space delimited word or number and what it does depends on the state. In either state if it is not a defined word or number then it will throw an error. A word is always looked for before a number is as a word has no limitations as to what its name is bar its length.

In command mode\-:

In command mode 'read' executes words and pushes numbers on to the variable stack.

In compile mode\-:

In compile mode 'read' compiles a pointer to the word in the next available slot in the dictionary, for numbers it compiles a 'push integer' (described later) followed by said number. Immediate words however are executed.

The first word that the interpreter runs is one that calls 'read' and then calls itself recursively so 'read' decrements the return stack pointer as well so the stack does no blow up. \begin{DoxyVerb}   "\\":
\end{DoxyVerb}


This is a comment, it is an immediate word, it will ignore all input until the end of the line has been reached. \begin{DoxyVerb}   "exit":
\end{DoxyVerb}


Return from a called word, the return address should be on the return stack, it is popped off. \begin{DoxyVerb}   "br":
\end{DoxyVerb}


Branch unconditionally to the next space indicated in the dictionary. \begin{DoxyVerb}   "?br":
\end{DoxyVerb}


Branch conditionally to the next space indicated in the dictionary if the top of the stack is zero, else continue. The top of the stack is dropped. \begin{DoxyVerb}   "\+":
\end{DoxyVerb}


Pop two numbers off the variable stack, add them and push the result. \begin{DoxyVerb}   "\-":
\end{DoxyVerb}


Pop two numbers off the variable stack, subtract the first off from the second and push the result. \begin{DoxyVerb}   "\*":
\end{DoxyVerb}


Pop two numbers off the variable stack, multiply them and push the result. \begin{DoxyVerb}   "%":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the remainder when the first off divides the second off and push the result. \begin{DoxyVerb}   "/":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the first off dividing the second off and push the result. \begin{DoxyVerb}   "lshift":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the first off shifting the second off logicically towards the left and push the result. \begin{DoxyVerb}   "rshift":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the first off shifting the second off logicically towards the right and push the result. \begin{DoxyVerb}   "and":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the bitwise A\-N\-D of them and push the result. \begin{DoxyVerb}   "or":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the bitwise O\-R of them and push the result. \begin{DoxyVerb}   "invert":
\end{DoxyVerb}


Bitwise inversion of the top of the variable stack. \begin{DoxyVerb}   "xor":
\end{DoxyVerb}


Pop two numbers off the variable stack, compute the bitwise X\-O\-R of them and push the result. \begin{DoxyVerb}   "1\+":
\end{DoxyVerb}


Add one to the top of the variable stack. \begin{DoxyVerb}   "1\-":
\end{DoxyVerb}


Subtract one from the top of the variable stack. \begin{DoxyVerb}   "=":
\end{DoxyVerb}


Pop two numbers off the variable stack, test for equality of them and push the result. \begin{DoxyVerb}   "<":
\end{DoxyVerb}


Pop two numbers off the variable stack, test if the first of is greater than the second and push the result. \begin{DoxyVerb}   "\>":
\end{DoxyVerb}


Pop two numbers off the variable stack, test if the first of is less than the second and push the result. \begin{DoxyVerb}   "@reg":
\end{DoxyVerb}


Use the top of the variable stack as an index into the register array, push the data in that address to the variable stack. \begin{DoxyVerb}   "@":
\end{DoxyVerb}


Use the top of the variable stack as an index into the dictionary array, push the data in that address to the variable stack. \begin{DoxyVerb}   "pick":
\end{DoxyVerb}


Use the top of the variable stack as an index into the variable stack itself , push the data in that address to the variable stack. \begin{DoxyVerb}   "@str":
\end{DoxyVerb}


Use the top of the variable stack as an index into the string storage array, push the data in that address to the variable stack. \begin{DoxyVerb}   "\!reg":
\end{DoxyVerb}


Pop two number off the stack, the first off is an index into the register array, the second off is the data to write there. \begin{DoxyVerb}   "\!":
\end{DoxyVerb}


Pop two number off the stack, the first off is an index into the dictionary array, the second off is the data to write there. \begin{DoxyVerb}   "\!var":
\end{DoxyVerb}


Pop two number off the stack, the first off is an index into the variable stack itself, the second off is the data to write there. \begin{DoxyVerb}   "\!str":
\end{DoxyVerb}


Pop two number off the stack, the first off is an index into the string storage array, the second off is the data to write there. \begin{DoxyVerb}   "key":
\end{DoxyVerb}


Push one character of input to the variable stack. \begin{DoxyVerb}   "emit":
\end{DoxyVerb}


Pop an item from the variable stack and output the {\itshape lower} 8-\/bits as a character. \begin{DoxyVerb}   "dup":
\end{DoxyVerb}


Duplicate the top of the variable stack. \begin{DoxyVerb}   "drop":
\end{DoxyVerb}


Drop an item from the variable stack. \begin{DoxyVerb}   "swap":
\end{DoxyVerb}


Swap the first two items on the variable stack. \begin{DoxyVerb}   "over":
\end{DoxyVerb}


Duplicate the second item on the variable stack. \begin{DoxyVerb}   "\>r":
\end{DoxyVerb}


Move the top of the variable stack to the return stack. \begin{DoxyVerb}   "r\>":
\end{DoxyVerb}


Move the top of the return stack to the variable stack. \begin{DoxyVerb}   "tail":
\end{DoxyVerb}


This allows the next word compiled word to be called recursively, there is no 'recurse' word in this F\-O\-R\-T\-H. \begin{DoxyVerb}   "\'":
\end{DoxyVerb}


Push the value of the next compiled word to the variable stack at run time. \begin{DoxyVerb}   ",":
\end{DoxyVerb}


Write the top of the stack into the next available dictionary field. \begin{DoxyVerb}   "printnum":
\end{DoxyVerb}


Pop two items off the variable stack, the second off is the base and the second is the number to print off, print this number off as a string in the selected base. \begin{DoxyVerb}   "get\_word":
\end{DoxyVerb}


Use top of stack as an index into string storage and store the next space delimited word there. \begin{DoxyVerb}   "strlen":
\end{DoxyVerb}


Use top of stack as an index into string storage, compute that strings length and push the result to the variable stack. \begin{DoxyVerb}   "isnumber":
\end{DoxyVerb}


Use top of stack as an index into string storage, test whether or not the string there is a number and push the result. \begin{DoxyVerb}   "strnequ":
\end{DoxyVerb}


Pop two numbers of the variable stack, use both as indices into string storage and test whether they are equal or not, push zero if they are equal, one if they are not and two if the strings are too long (what is too long is defined in the source code). \begin{DoxyVerb}   "find":
\end{DoxyVerb}


Find a word in the dictionary if it exists and push a pointer to that words execution field. \begin{DoxyVerb}   "execute":
\end{DoxyVerb}


Given an execution token of a word is on the variable stack, it pops it and executes it, if it is not a valid execution token the behaviour is undefined.

The code\-: \begin{DoxyVerb}find word execute
\end{DoxyVerb}


Will cause the word 'word' to be executed. \begin{DoxyVerb}   "kernel":
\end{DoxyVerb}


This executes system calls, for example file opening and reading. It pops off a number from the variable stack which is used as an index into a number of function calls. If the function call needs any more arguments it gets them from the variable stack.

\subsubsection*{Hidden words}

In addition to this there are three 'invisible' forth words which do not have a name which are\-: \begin{DoxyVerb}   "push integer":
\end{DoxyVerb}


This pushes the next dictionary location onto the variable stack. \begin{DoxyVerb}   "compile":
\end{DoxyVerb}


This compiles a pointer to the next memory location in the dictionary after the compile to the next memory location available in the dictionary. \begin{DoxyVerb}   "run":
\end{DoxyVerb}


You can that being limited to only these primitives would not create a very forth-\/like system. However as any forth programmer knows you can extend the language in itself, which is what the first file does that is read in.

\subsubsection*{S\-Y\-S\-T\-E\-M C\-A\-L\-L\-S}

{\bfseries These should be moved to desktop.\-c soon}

There are a few system calls which are there to handle files; input, output, renaming, removing, closing. Nothing too fancy. If you have an extra system calls you want to add, adding them to here and wrappers around the I/\-O is where to do it. Any system dependent code would go here, for example if I wanted to set up a timer on an embedded system the call would go here.

The current system calls that have been defined are\-: \begin{DoxyVerb}   "SYS_RESET":
\end{DoxyVerb}


This resets the virtual machine as if an error had occurred (resetting the stack pointers, setting I/\-O to defaults, executing the read-\/eval-\/loop function). \begin{DoxyVerb}   "SYS_FOPEN":
\end{DoxyVerb}


This takes two arguments off the variable stack, the first is to decide what this is to act on, the input or the output, and the second off as a pointer into string storage where the file name is to be held.

The options are; S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-I\-N, S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-O\-U\-T for input and output respectively. If a new input file is opened that is added to the input stream stack and reading from that stream begins immediately, when an E\-O\-F occurs that file stream is automatically closed and removed from the stack, the input stream then continues from where it left off. There is no output stack, if a new file is opened the old one is flushed and closed and the output redirected to that new file.

The error stream cannot be redirected from within the forth interpreter, only input and output. \begin{DoxyVerb}   "SYS_FCLOSE":
\end{DoxyVerb}


This takes one argument from the variable stack, an option to decide whether this operation occurs on the input (S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-I\-N) or the output (S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-O\-U\-T) liked \char`\"{}\-S\-Y\-S\-\_\-\-F\-O\-P\-E\-N\char`\"{}.

If S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-I\-N is selected and the current input is a file then it is closed and the next on the file input stack is selected as input. If it is output the output is closed and all output is then redirected to standard out (stdout). \begin{DoxyVerb}   "SYS_FLUSH":
\end{DoxyVerb}


Flush all file streams \char`\"{}fflush(\-N\-U\-L\-L)\char`\"{}. \begin{DoxyVerb}   "SYS_REMOVE":
\end{DoxyVerb}


Pop one number off the variable stack, treat that as an index into string storage where a file name is kept, try to remove that file. \begin{DoxyVerb}   "SYS_RENAME":
\end{DoxyVerb}


Pop two numbers off the variable stack, treat both as indices into string storage where file names are kept, try to rename a file pointed to by the first into a new name pointed to by the second off. \begin{DoxyVerb}   "SYS_REWIND":
\end{DoxyVerb}


Pop a number off the variable stack, which either represents S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-I\-N or S\-Y\-S\-\_\-\-O\-P\-T\-\_\-\-O\-U\-T and try to rewind that input or output.

\subsection*{Error detection and handling}

Unlike traditional Forth implementations errors are handled by the interpreter although it is possible to disable some of the error checking with a compile time option, this is not recommended. All possible errors that can be detected by this program should be, if it does not detect a possible error then this is a bug.

\subsection*{Forth program}

The Forth program that runs on the virtual machine with these sets of primitives is commented, but will eventually be described here.

\subsection*{F\-I\-N\-A\-L W\-O\-R\-D\-S}

This program is released under the \href{http://www.gnu.org/licenses/lgpl-3.0.txt}{\tt L\-G\-P\-L}, feel free to use it in your project under L\-G\-P\-Ls restrictions. Please contact me if you have any problems at my listed Email\-: \href{mailto:howe.r.j.89@gmail.com}{\tt howe.\-r.\-j.\-89@gmail.\-com}.

E\-O\-F 