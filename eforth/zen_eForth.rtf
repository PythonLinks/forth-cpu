{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch8\stshfhich8\stshfbi8\deflang2057\deflangfe2057\themelang2057\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f5\fbidi \fmodern\fcharset0\fprq1{\*\panose 02070409020205020404}Courier{\*\falt Courier New};}{\f8\fbidi \froman\fcharset0\fprq2{\*\panose 02040503060506020304}New York{\*\falt Times New Roman};}
{\f34\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria Math;}{\f39\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0302020204030204}Calibri Light;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f270\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f271\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f273\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f274\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f275\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f276\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f277\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f278\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f610\fbidi \froman\fcharset238\fprq2 Cambria Math CE;}{\f611\fbidi \froman\fcharset204\fprq2 Cambria Math Cyr;}
{\f613\fbidi \froman\fcharset161\fprq2 Cambria Math Greek;}{\f614\fbidi \froman\fcharset162\fprq2 Cambria Math Tur;}{\f617\fbidi \froman\fcharset186\fprq2 Cambria Math Baltic;}{\f618\fbidi \froman\fcharset163\fprq2 Cambria Math (Vietnamese);}
{\f660\fbidi \froman\fcharset238\fprq2 Times CE;}{\f661\fbidi \froman\fcharset204\fprq2 Times Cyr;}{\f663\fbidi \froman\fcharset161\fprq2 Times Greek;}{\f664\fbidi \froman\fcharset162\fprq2 Times Tur;}
{\f665\fbidi \froman\fcharset177\fprq2 Times (Hebrew);}{\f666\fbidi \froman\fcharset178\fprq2 Times (Arabic);}{\f667\fbidi \froman\fcharset186\fprq2 Times Baltic;}{\f668\fbidi \froman\fcharset163\fprq2 Times (Vietnamese);}
{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhimajor\f31528\fbidi \fswiss\fcharset238\fprq2 Calibri Light CE;}{\fhimajor\f31529\fbidi \fswiss\fcharset204\fprq2 Calibri Light Cyr;}
{\fhimajor\f31531\fbidi \fswiss\fcharset161\fprq2 Calibri Light Greek;}{\fhimajor\f31532\fbidi \fswiss\fcharset162\fprq2 Calibri Light Tur;}{\fhimajor\f31535\fbidi \fswiss\fcharset186\fprq2 Calibri Light Baltic;}
{\fhimajor\f31536\fbidi \fswiss\fcharset163\fprq2 Calibri Light (Vietnamese);}{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}
{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}
{\fhiminor\f31576\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\*\defchp \f8 }{\*\defpap \ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }
\noqfpromote {\stylesheet{\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 \snext0 \sqformat \spriority0 
Normal;}{\*\cs10 \additive \ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af8\afs20\alang1025 \ltrch\fcs0 \f8\fs20\lang2057\langfe2057\cgrid\langnp2057\langfenp2057 \snext11 \ssemihidden \sunhideused Normal Table;}{
\s15\ql \li0\ri0\widctlpar\tqc\tx4819\tqr\tx9071\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 \sbasedon0 \snext15 \slink16 
footer;}{\*\cs16 \additive \rtlch\fcs1 \af0 \ltrch\fcs0 \fs24\lang1024\langfe1024\noproof \sbasedon10 \slink15 \slocked \ssemihidden Footer Char;}{\*\cs17 \additive \rtlch\fcs1 \af0 \ltrch\fcs0 \sbasedon10 page number;}{\s18\ql \li0\ri-720\widctlpar
\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 \sbasedon0 \snext18 \spriority0 eForth;}{\s19\qj \li0\ri-720\widctlpar
\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af39\afs20\alang1025 \ltrch\fcs0 
\f39\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 \sbasedon18 \snext19 \spriority0 text;}{\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 
\af5\afs20\alang1025 \ltrch\fcs0 \f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 \sbasedon0 \snext20 \spriority0 zen;}}{\*\revtbl {Unknown;}}{\*\rsidtbl \rsid1127859\rsid8218931\rsid9062223\rsid9905175\rsid10628273\rsid11735699\rsid12989392\rsid15287017
\rsid16122071\rsid16662866}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1\mlMargin0\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info{\author DNA BU-20 License Paks-1 orig}{\operator Howe, Richard}
{\creatim\yr2017\mo4\dy19\hr8\min40}{\revtim\yr2017\mo4\dy19\hr13\min15}{\version7}{\edmins0}{\nofpages39}{\nofwords17170}{\nofchars97870}{\*\company Continental AG}{\nofcharsws114811}{\vern57443}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/
word/2003/wordml}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\hyphhotz0\trackmoves0\trackformatting1\donotembedsysfont1\relyonvml0\donotembedlingdata0\grfdocevents0\validatexml1\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors1
\sprstsp\otblrul\brkfrm\sprstsm\truncex\nolead\msmcap\lytprtmet\hyphcaps0\horzdoc\fracwidth\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow0\jexpand\viewkind1\viewscale100\bdrrlswsix\nolnhtadjtbl\nojkernpunct\rsidroot12989392 \fet0
{\*\wgrffmtfilter 2450}\ilfomacatclnup0\stylesortmethod0{\*\ftnsep \ltrpar \pard\plain \ltrpar\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid1127859 \chftnsep 
\par }}{\*\ftnsepc \ltrpar \pard\plain \ltrpar\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 
\af0 \ltrch\fcs0 \insrsid1127859 \chftnsepc 
\par }}{\*\aftnsep \ltrpar \pard\plain \ltrpar\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 
\af0 \ltrch\fcs0 \insrsid1127859 \chftnsep 
\par }}{\*\aftnsepc \ltrpar \pard\plain \ltrpar\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 
\af0 \ltrch\fcs0 \insrsid1127859 \chftnsepc 
\par }}\ltrpar \sectd \ltrsect\linex0\colsx360\sectdefaultcl\sftnbj {\footerr \ltrpar \pard\plain \ltrpar\s15\ql \li0\ri0\widctlpar\tqc\tx4819\tqr\tx9071\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 
\ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\insrsid10628273 \tab \chpgn 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 
\af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 eForth Overview
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Before diving directly 
into eForth, I would like to discuss the general principles of Forth language. The language consists of a collection of words, which reside in the memory of a computer and can be executed by entering their names on the computer keyboard.  A list of words 
c
an be compiled, given a new name and made a new word.  In fact, most words in Forth are defined as lists of existing words.  A small set of primitive words are defined in machine code of the native CPU.  All other words are built from this primitive words
 and eventually refer to them when executed.
\par 
\par Words are similar to procedures and subroutines in other languages.  The difference is that Forth words are executable interactively when referenced by name, and they can be compiled into lists which can be refe
renced as new words.  Programming in Forth is to define new and more powerful words as lists of existing words.  This process continues until the final word becomes the solution to an application.
\par 
\par Here I will state 'The Forth Law of Computing" without a proof:
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 All computable functions can be constructed by defining new words as lists of words which include a small number of primitive words.
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par This eForth model consists of about 200 words, of which only 31 are primitive words.  Although it is very difficult
 to prove the above law, I will demonstrate it to you that from this small set of primitive words a complete operating system with many tools, that is the eForth model itself, can be built.  If an operating system can be built this way, it is not difficul
t to understand that any application can be so developed.
\par 
\par Forth is very similar to machine code.  In a computer, the CPU has a finite set of machine instructions, and all computable functions are implemented as lists of these machine instructions.  High le
vel languages generally replace machine instruction lists by statements, functions, subroutines, and procedures, which can be used to construct procedures and subroutines at higher levels until the last procedure which is the application.  This also helps
 demonstrating the validity of the above law.
\par 
\par The primitive words must be constructed using native machine code of the host computer.  They are also called low level words or code words.  All other words are constructed as lists of existing words.  They are called high level words or colon words beca
use ":" (colon) is a Forth word which defines or constructs new words to replace lists of existing words.
\par 
\par Forth as a computing system has two principal components: an user interface as the Forth language processor which interprets the commands entered from
 keyboard or equivalent devices; and a machine interface which interprets lists or words recursively until it can issue machine instructions in the primitive words to the host computer for execution.  The user interface processes commands in text form.  I
t is often referred to as the text interpreter and the outer interpreter.  
\par 
\par The machine interface executes words by processing recursively the word lists compiled in colon words to reach the primitive words which are handed to the host computer for executi
on. It is often called the inner interpreter and the address interpreter, because the word lists are often stored in the dictionary as address lists.}{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par }\pard \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Virtual Forth Computer
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Forth is a computer model which can be implemented on any real CPU with reasonable resources.  This model is often called a virtual Forth computer.  The minimal components of a virtual Forth computer are:
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 1.   A dictionary in memory to hold all the execution procedures.
\par 2.   A return stack to hold return addresses of procedures yet to be executed.
\par 3.   A data stack to hold parameters passing between procedures.
\par 4.   A user area in RAM memory to hold all the system variables.
\par 5.   A CPU to move date among stacks and memory, and to do ALU operations to parameters stored on the data stack.
\par 
\par The eForth model is a detailed specification of a virtual Forth computer which can be implemented on many different CPU's and forces them to behave identically in executing an identical Forth instruction set. It was first implemneted on a PC using Inte
l 8086 CPU as a guiding model for other implementations.  Here we will try to describe precisely the behavior of the virtual Forth computer. To describe precisely how this computer functions, we will use the 8086 machine code to clarify the specification.

\par 
\par The following registers are required for a virtual Forth computer:
\par 
\par Forth Register \tab 8086 Register\tab \tab Function\tab 
\par \tab 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid11735699 IP\tab \tab \tab SI     \tab \tab }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Interpreter Pointer\tab 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid11735699 SP\tab \tab \tab SP     \tab \tab }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Data Stack Pointer\tab 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid11735699 RP\tab \tab \tab RP    \tab \tab }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Return Stack Pointer
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid11735699 WP\tab \tab \tab AX\tab \tab }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Word or Work Pointer
\par UP\tab \tab \tab (in memory )   \tab User Area Pointer\tab        
\par 
\par In the dictionary, each procedure (or word in Forth terminology) occupies an a
rea called code field, which contains executable machine code and data required by the code. There are two types of words used in eForth: code word whose code field contains only machine instructions, and colon word whose code field contains a call to the
 
list processing subroutine and a list of word addresses.  A word address is the code field address of the word in the dictionary.  4 bytes are allocated for the call to list processor. Word addresses are 2 bytes in length, and are pointers to code fields 
of words in the dictionary.  The length of a code field varies depending upon the complexity of the word.
\par 
\par In the code field of a code word there is a list of machine instructions of the native CPU.  The machine instructions are terminated by a group of ins
tructions, generally specified as a macro instruction named $NEXT.  The function of $NEXT is to fetch the next word pointed to by the Interpreter Pointer IP, increment IP to point to the next word in the word list, and jump to the address just fetched.  S
i
nce a word address points to a code field containing executable machine instructions, executing a word means jumping directly to the code field pointed to by the word address.  $NEXT thus allows the virtual Forth computer to execute a list of words with v
ery little CPU overhead.  In the 8086 implementation, $NEXT is a macro assembling the following two machine instructions as shown below.
\par 
\par In a colon word, the first four byte in the code field must be a subroutine call instruction to process the address lis
t following this call instruction.  This address list processing subroutine is named doLIST.  doLIST pushes the contents in IP onto the return stack, copies the address of the first entry in its address list into IP and then calls $NEXT.  $NEXT will then 
start executing this list of addresses in sequence.
\par 
\par The last entry in the address list of a colon word must be EXIT.  EXIT is a code word which undoes what doLIST accomplished.  EXIT pops the top item on the return stack into the IP register. Consequently,
 IP points to the address following the colon word just executed.  EXIT then invokes $NEXT which continues the processing of the word list, briefly interrupted by the last colon word in this word list.
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 $NEXT\tab   MACRO
\par \tab   LODSW           \tab \tab \\ load next word into WP (AX)
\par         JMP     AX      \tab \tab \\ jump directly to the word thru WP
\par         ENDM\tab \tab \tab \tab \\ IP (SI) now points to the next word
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 doLIST\tab ( a -- )\tab \\
 Run address list in a colon word. 
\par \tab XCHG\tab BP,SP\tab \tab \\ exchange pointers
\par \tab PUSH\tab SI\tab \tab \\ push return stack
\par \tab XCHG\tab BP,SP\tab \tab \\ restore the pointers
\par \tab POP\tab SI\tab \tab \\ new list address
\par \tab $NEXT
\par 
\par CODE\tab EXIT\tab \tab \tab \\ Terminate a colon definition.
\par \tab XCHG\tab BP,SP\tab \tab \\ exchange pointers
\par \tab POP\tab SI\tab \tab \\ pop return stack
\par \tab XCHG\tab BP,SP\tab \tab \\ restore the pointers
\par \tab $NEXT
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 It is interesting to note that in t
his eForth implementation, $NEXT is a macro, doLIST is a subroutine, and EXIT is actually a Forth code words.  $NEXT, doLIST and EXIT are collectively  call the 'inner interpreters' and 'address interpreters' of Forth.  They are the corner stones of a vir
tual Forth computer as they control the execution flow of Forth words in the system.
\par 
\par Based on the above mechanism to execute code words and colon words, a Forth computer can be constructed using a small set of machine dependent code words and a much larger
 set of colon words.  Tools are provided so that the user can extend the system by adding new words in truly modular fashion to solve any practical problems.
\par 
\par There are 190 high level words in eForth, built on the 31 low level primitive words.  The high le
vel word set is required to build the outer interpreter and the associated utility words.  As the outer interpreter itself represents a fairly substantial application, the word set necessary to build the outer interpreter forms a very solid foundation to 
b
uild most other applications.  However, for any real world application one would not expect that this eForth word set is sufficient.  The beauty of Forth is that in programming an application, the user designs and implements a new word set best tailored t
o his application.  Forth is an open system, assuming that no operating system can be complete and all-encompassing.  The user has the best understanding of his own needs, and he knows the best way to accomplish his goal.
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Memory Map
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The most important co
ntribution by von Neumann to the computer design was the recognition that a single, uniform memory device can be used to store program and data, contrasting to the then prevailing architectures in which program and data were stored separately and most oft
en using very different storage media.  It greatly simplified the design of computers and had become the dominant computer architecture for all the important computer families ever since.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 Memory space is a concept of paramount importance in computer hardwa
re and assembly programming, but often hidden and ignored in most conventional high level languages.  High level languages and operating systems hide the addressable memory space from the user in order to protect the operating system, because there are ve
r
y sensitive areas in the memory space and unintentional alterations to the information stored in these areas would cause the system to malfunction or even to crash.  The point of view from the operating system and from the computer priesthood,  these sens
itive areas must be protected at all cost, and they are the reserved territory of the systems programmers.  Ordinary applications programmers are allocated only enough space to run their programs safely, for their own good.
\par 
\par Forth opens the entire memory space to the user.  The user can freely store data and code into memory and retrieve them from the memory.  Coming with the freedom is the responsibility of handling the memory correctly.
\par 
\par Memory used in eForth is separated into the following areas:
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 Cold boot       \tab 100H-17FH       \tab Cold start and variable initial values
\par Code dictionary \tab 180H-1344H      \tab Code dictionary growing upward
\par Free space      \tab 1346H-33E4H    \tab Shared by code and name dictionaries
\par Name/word      \tab 33E6H-3BFFH     \tab Name dictionary growing downward
\par Data stack      \tab 3C00H-3E7FH     \tab Growing downward
\par TIB             \tab 3E80H-          \tab Growing upward
\par Return stack      -3F7FH     \tab \tab Growing downward
\par User variables  \tab 3F80H-3FFFH
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par These areas are allocated by assembly constants and can be changed conveniently to suit the target environment.  The following assembly code segment prescribes the memory allocation in a typical eForth system.  The memory map is also illustrated in a sche
matic drawing for easier visulization.
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 ;; Memory allocation
\par ;; 0//code>--//--<name//up>--<sp//tib>--rp//em
\par EM\tab EQU\tab 04000H\tab ;top of memory
\par COLDD\tab EQU\tab 00100H\tab ;cold start vector
\par US\tab EQU\tab 64*CELLL\tab ;user area size in cells
\par RTS\tab EQU\tab 64*CELLL\tab ;return stack/TIB size
\par RPP\tab EQU\tab EM-8*CELLL\tab ;start of return stack (RP0)
\par TIBB\tab EQU\tab RPP-RTS\tab ;terminal input buffer (TIB)
\par SPP\tab EQU\tab TIBB-8*CELLL\tab ;start of data stack (SP0)
\par UPP\tab EQU\tab EM-256*CELLL\tab ;start of user area (UP0)
\par NAMEE\tab EQU\tab UPP-8*CELLL\tab ;name dictionary
\par CODEE\tab EQU\tab COLDD+US\tab ;code dictionary
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 {\pard\plain \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 
\rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057\insrsid12989392\charrsid9062223 {\object\objemb\objw4601\objh9301{\*\objclass Word.Picture.8}{\*\objdata 01050000020000000f000000
576f72642e506963747572652e3800000000000000000000260000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000000200000001000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdffffff07000000feffffff04000000050000000600000008000000feffffff090000000a0000000b0000000c0000000d0000000e0000000f0000001000000011000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffff020000000709020000000000c00000000000004600000000000000000000000040d9
87a206b9d20103000000801a00000000000001004f006c00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000201ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
0000000000000000000000001400000000000000030050004900430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0002010100000004000000ffffffff0000000000000000000000000000000000000000000000000000
0000000000000000000001000000640000000000000003004d004500540041000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000201ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
00000000000000000000000003000000c205000000000000feffffff02000000feffffff0400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f000000100000001100000012000000130000001400000015000000160000001700000018000000190000001a00
0000feffffff1c0000001d0000001e0000001f000000200000002100000022000000230000002400000025000000260000002700000028000000290000002a0000002b0000002c0000002d0000002e0000002f00000030000000310000003200000033000000340000003500000036000000370000003800000039000000
3a0000003b0000003c0000003d0000003e0000003f000000400000004100000042000000430000004400000045000000460000004700000048000000490000004a0000004b0000004c0000004d0000004e000000feffffff50000000fefffffffeffffff5300000054000000550000005600000057000000580000005900
00005a0000005b0000005c0000005d0000005e0000005f00000060000000610000006200000063000000640000006500000066000000670000006800000069000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000640002000100000000000800c51700000f300000f8110000542400000000
0000000000000000000000000000e8030000e803000000000000000000000000000000000000000000ff00000000000000ff00000000000000ff00000000000000ff00000000000000000000000000000000000000000000000000000000000000000800c5170f300000010009000003dd02000005001c00000000000500
00000b02ffffffff050000000c02d101e6000500000004010d000000050000002e01180000000500000002010100000005000000090200000000050000000102ffffff00030000001e000a00000026060f000a00ffffffff00000000000007000000fc020000ffffff000000040000002d01000008000000fa0206000100
000000000000040000002d010100070000001b04c801b800050027001c000000fb02f4ff0000000000009001000000000000001054696d6573204e657720526f6d616e00e4f4380038825f7680016376cb1166ba040000002d0102000b00000021050a0046726565205370616365080155000500000014022e0127000500
000013022e01b700090000002105050031333432485332010200070000002105020043503101bc00050000001402a3012700050000001302a301b7000500000014027f0127000500000013027f01b7000e00000021050f00436f64652044696374696f6e617279005c0149000d00000021050e00436f6c6420426f6f7420
4172656196014b000a00000021050800444f532041726561ba01570007000000210501003000cb011b00080000002105040031303048a90108000800000021050400313830488301080008000000210504004f524947a701bb000900000021050500434f444545018301ba000a00000026060f000a00ffffffff00000000
000007000000fc020000000000000000040000002d01030008000000fa0205000100000000000000040000002d0104000e000000240305006f001301720021016f0021016b0021016f001301040000002d0101000500000014022e016f0005000000130221016f000a00000026060f000a00ffffffff0100000000000a00
000026060f000a00ffffffff000000000000050000001402290027000500000013022900b7000500000014024d0027000500000013024d00b700050000001402950027000500000013029500b700050000001402dd002700050000001302dd00b7000d00000021050d0055736572205661726961626c65001c004d000c00
000021050c0052657475726e20537461636b3500290011000000210515005465726d696e616c20496e70757420427566666572004c004b000b00000021050a004461746120537461636b7b0054000e00000021050f004e616d652044696374696f6e61727900bb0042000900000021050500334330304853990000000900
0000210505003345383048535200020009000000210505003346383048532d00020009000000210505003430303048530b0002000700000021050200454d0a00b900070000002105020055502700b9000800000021050300525030303300b9000800000021050300544942304b00b9000800000021050300535030305700
b80009000000210505004e414d4545009a00ba0007000000210502004e50e100ba000500000014024d0027000500000013022900b7000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f0071006b0063006f006300720063006f007100040000002d0101000500000014024d00
6f0005000000130263006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f003b006b002d006f002d0072002d006f003b00040000002d01010005000000140229006f000500000013022d006f000a00000026060f000a00
ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f00f8006b00ea006f00ea007200ea006f00f800040000002d010100050000001402dd006f00050000001302ea006f000a00000026060f000a00ffffffff010000000000090000002105050033333830
48ffe10003000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff010000000000040000002701ffff03000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cceffff
ffff01d000e5001102ff0c00ffffffffffff0000ffff000000e5000001d000000000000000a1006400086450726f0000000100a0008200a0008c001e001affffffffffff0001000affffffff01d000e50009000000000000000000310005002701c800b8001a0000000000000009ffffffffffffffff003800a0009b00a1
0096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a00fd0052010d008c002c000800140554696d657300030014000d000c002e0004ff000100001500000028010800550a467265652053706163650000a0009900a0009700a0009c0001
000affffffff01d000e50020012e0027012e00b700a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300300500049004300540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000c0002000300000006000000ffffffff0000000000000000000000000000000000000000000000000000000000000000000000001b000000ce0c000000000000010043006f006d0070004f0062006a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000012000200ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000004f0000006d0000000000000003004f0062006a0049006e0066006f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000120002010500000007000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000051000000060000000000000002004f006c006500500072006500730030003000300000000000000000000000000000000000000000000000000000000000000000000000
000000000000000018000200ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000052000000e2050000000000000000000100000000000000000001000a0127ffff0137002600280132000205313334324800a0009900a0009700a0009c00a0009b00a1
0096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a012600b9013600cd001500000028013100bc0243500000a0009900a0009700a0009c0001000affffffff01d000e5002001a3002701a300b70020017f0027017f00b700a0009b00a1
0096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a015100460161009b001500000028015c00490f436f64652044696374696f6e61727900a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a00098
00a1006400186450726f000f0014000000300000000100000000000000000001000a018b0048019b009a002b023a0e436f6c6420426f6f7420417265610000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000
000000000001000a01af005401bf008c002b0c2408444f5320417265610000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a01c0001801d00024002801cb001b013000a0009900a00097
00a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a019e000501ae0026002801a9000804313030480000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a10064
00186450726f000f0014000000300000000100000000000000000001000a01780005018800250015000000280183000804313830480000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a
019c00b801ac00db00150000002bb324044f5249470000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a017800b7018800e50028018300ba05434f44454500a0009900a0009700a0009c
00a10064000a6450726f00090001000200a0008c0001000affffffff01d000e50071001e0113006b012100720113006f012100720121006f0121006b0113006f0022012e006f00f300a0008d00a1006400086450726f000a000000a0008c002000290027002900b70020004d0027004d00b7002000950027009500b70020
00dd002700dd00b700a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a0011004a002100930028001c004d0d55736572205661726961626c6500a0009900a0009700a0009c00a0009b00a10096000c0100000000000000
0000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a002a0026003a006a001500000028003500290c52657475726e20537461636b0000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014
000000300000000100000000000000000001000a00410048005100b800150000002b2217155465726d696e616c20496e7075742042756666657200a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f001400000030000000010000000000000000
0001000a007000510080008b00150000002b092f0a4461746120537461636b0000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a00b0003f00c0009700150000002800bb00420f4e616d
652044696374696f6e61727900a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a008effff009e002600280099000005334330304800a0009900a0009700a0009c00a0009b00a10096000c
01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a0047ffff005700260015000000280052000205334538304800a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014
000000300000000100000000000000000001000a0022ffff00320026001500000028002d000205334638304800a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a0000ffff001000260028
000b000205343030304800a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000affff00b6000f00ce0028000a00b902454d0000a0009900a0009700a0009c00a0009b00a10096000c01000000
000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a001c00b6002c00cb002a1d02555000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f00140000003000000001000000000000
00000001000a002800b6003800d1002a0c035250300000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a004000b6005000cf002a18035449420000a0009900a0009700a0009c00a0009b
00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a004c00b5005c00ce0028005700b80353503000a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014
000000300000000100000000000000000001000a008f00b7009f00e500150000002b0243054e414d454500a0009900a0009700a0009c00a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a00d600b700e600cc00150000
002a47024e5000a0009900a0009700a0009c0001000affffffff01d000e50020004d0027002900b700a10064000a6450726f00090001000200a0008c0071001e0063006b007100720071006f0063006b0063006f006300720071006f0022004d006f001600a0008d00a1006400086450726f000a000000a10064000a6450
726f00090001000200a0008c0071001e002d006b003b0072003b006f002d006b002d006f002d0072003b006f00220029006f000400a0008d00a1006400086450726f000a000000a10064000a6450726f00090001000200a0008c0071001e00ea006b00f8007200f8006f00ea006b00ea006f00ea007200f8006f002200dd
006f000d00a0008d00a1006400086450726f000a000000a0009b00a10096000c01000000000000000000000000a0009800a1006400186450726f000f0014000000300000000100000000000000000001000a00d6000000e6002600150000002800e1000305333338304800a0009900a0009700a0009c00a0008d00a0008d
00a0008300ff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff0709020000000000c000000000000046170000004d6963726f736f667420576f72642050696374757265000f000000576f72642e506963747572
652e38000f000000576f72642e506963747572652e3800f439b2710000000000000000000000000000000000000000000000000000000000000002000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffff
030000000400000001000000ffffffff0000000000000000c51700000f300000ba050000010009000003dd02000005001c0000000000050000000b02ffffffff050000000c02d101e6000500000004010d000000050000002e01180000000500000002010100000005000000090200000000050000000102ffffff000300
00001e000a00000026060f000a00ffffffff00000000000007000000fc020000ffffff000000040000002d01000008000000fa0206000100000000000000040000002d010100070000001b04c801b800050027001c000000fb02f4ff0000000000009001000000000000001054696d6573204e657720526f6d616e00e4f4
380038825f7680016376cb1166ba040000002d0102000b00000021050a0046726565205370616365080155000500000014022e0127000500000013022e01b700090000002105050031333432485332010200070000002105020043503101bc00050000001402a3012700050000001302a301b7000500000014027f012700
0500000013027f01b7000e00000021050f00436f64652044696374696f6e617279005c0149000d00000021050e00436f6c6420426f6f74204172656196014b000a00000021050800444f532041726561ba01570007000000210501003000cb011b00080000002105040031303048a9010800080000002105040031383048
8301080008000000210504004f524947a701bb000900000021050500434f444545018301ba000a00000026060f000a00ffffffff00000000000007000000fc020000000000000000040000002d01030008000000fa0205000100000000000000040000002d0104000e000000240305006f001301720021016f0021016b00
21016f001301040000002d0101000500000014022e016f0005000000130221016f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000050000001402290027000500000013022900b7000500000014024d0027000500000013024d00b700050000001402950027000500
000013029500b700050000001402dd002700050000001302dd00b7000d00000021050d0055736572205661726961626c65001c004d000c00000021050c0052657475726e20537461636b3500290011000000210515005465726d696e616c20496e70757420427566666572004c004b000b00000021050a00446174612053
7461636b7b0054000e00000021050f004e616d652044696374696f6e61727900bb00420009000000210505003343303048539900000009000000210505003345383048535200020009000000210505003346383048532d00020009000000210505003430303048530b0002000700000021050200454d0a00b90007000000
2105020055502700b9000800000021050300525030303300b9000800000021050300544942304b00b9000800000021050300535030305700b80009000000210505004e414d4545009a00ba0007000000210502004e50e100ba000500000014024d0027000500000013022900b7000a00000026060f000a00ffffffff0000
00000000040000002d0104000e000000240305006f0071006b0063006f006300720063006f007100040000002d0101000500000014024d006f0005000000130263006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f00
3b006b002d006f002d0072002d006f003b00040000002d01010005000000140229006f000500000013022d006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f00f8006b00ea006f00ea007200ea006f00f80004000000
2d010100050000001402dd006f00050000001302ea006f000a00000026060f000a00ffffffff01000000000009000000210505003333383048ffe10003000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff010000000000040000002701ffff03000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000001050000050000000d0000004d45544146494c455049435400b21f0000ecbfffffc20500000800b21f14400000
010009000003dd02000005001c0000000000050000000b02ffffffff050000000c02d101e6000500000004010d000000050000002e01180000000500000002010100000005000000090200000000050000000102ffffff00030000001e000a00000026060f000a00ffffffff00000000000007000000fc020000ffffff00
0000040000002d01000008000000fa0206000100000000000000040000002d010100070000001b04c801b800050027001c000000fb02f4ff0000000000009001000000000000001054696d6573204e657720526f6d616e00e4f4380038825f7680016376cb1166ba040000002d0102000b00000021050a00467265652053
70616365080155000500000014022e0127000500000013022e01b700090000002105050031333432485332010200070000002105020043503101bc00050000001402a3012700050000001302a301b7000500000014027f0127000500000013027f01b7000e00000021050f00436f64652044696374696f6e617279005c01
49000d00000021050e00436f6c6420426f6f74204172656196014b000a00000021050800444f532041726561ba01570007000000210501003000cb011b00080000002105040031303048a90108000800000021050400313830488301080008000000210504004f524947a701bb000900000021050500434f444545018301
ba000a00000026060f000a00ffffffff00000000000007000000fc020000000000000000040000002d01030008000000fa0205000100000000000000040000002d0104000e000000240305006f001301720021016f0021016b0021016f001301040000002d0101000500000014022e016f0005000000130221016f000a00
000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000050000001402290027000500000013022900b7000500000014024d0027000500000013024d00b700050000001402950027000500000013029500b700050000001402dd002700050000001302dd00b7000d00000021050d00
55736572205661726961626c65001c004d000c00000021050c0052657475726e20537461636b3500290011000000210515005465726d696e616c20496e70757420427566666572004c004b000b00000021050a004461746120537461636b7b0054000e00000021050f004e616d652044696374696f6e61727900bb004200
09000000210505003343303048539900000009000000210505003345383048535200020009000000210505003346383048532d00020009000000210505003430303048530b0002000700000021050200454d0a00b900070000002105020055502700b9000800000021050300525030303300b90008000000210503005449
42304b00b9000800000021050300535030305700b80009000000210505004e414d4545009a00ba0007000000210502004e50e100ba000500000014024d0027000500000013022900b7000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f0071006b0063006f00630072006300
6f007100040000002d0101000500000014024d006f0005000000130263006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f003b006b002d006f002d0072002d006f003b00040000002d01010005000000140229006f00
0500000013022d006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f00f8006b00ea006f00ea007200ea006f00f800040000002d010100050000001402dd006f00050000001302ea006f000a00000026060f000a00ffff
ffff01000000000009000000210505003333383048ffe10003000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff010000000000040000002701ffff030000000000}{\result {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs20\insrsid12989392\charrsid9062223 
{\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw8114\pich16404\picwgoal4600\pichgoal9300\wmetafile8\bliptag1696939656\blipupi72{\*\blipuid 65253e88c0258944c0980920eba184a5}
010009000003dd02000005001c0000000000050000000b02ffffffff050000000c02d101e6000500000004010d000000050000002e0118000000050000000201
0100000005000000090200000000050000000102ffffff00030000001e000a00000026060f000a00ffffffff00000000000007000000fc020000ffffff000000
040000002d01000008000000fa0206000100000000000000040000002d010100070000001b04c801b800050027001c000000fb02f4ff00000000000090010000
00000000001054696d6573204e657720526f6d616e00e4f4380038825f7680016376cb1166ba040000002d0102000b00000021050a0046726565205370616365
080155000500000014022e0127000500000013022e01b700090000002105050031333432485332010200070000002105020043503101bc00050000001402a301
2700050000001302a301b7000500000014027f0127000500000013027f01b7000e00000021050f00436f64652044696374696f6e617279005c0149000d000000
21050e00436f6c6420426f6f74204172656196014b000a00000021050800444f532041726561ba01570007000000210501003000cb011b000800000021050400
31303048a90108000800000021050400313830488301080008000000210504004f524947a701bb000900000021050500434f444545018301ba000a0000002606
0f000a00ffffffff00000000000007000000fc020000000000000000040000002d01030008000000fa0205000100000000000000040000002d0104000e000000
240305006f001301720021016f0021016b0021016f001301040000002d0101000500000014022e016f0005000000130221016f000a00000026060f000a00ffff
ffff0100000000000a00000026060f000a00ffffffff000000000000050000001402290027000500000013022900b7000500000014024d002700050000001302
4d00b700050000001402950027000500000013029500b700050000001402dd002700050000001302dd00b7000d00000021050d0055736572205661726961626c
65001c004d000c00000021050c0052657475726e20537461636b3500290011000000210515005465726d696e616c20496e70757420427566666572004c004b00
0b00000021050a004461746120537461636b7b0054000e00000021050f004e616d652044696374696f6e61727900bb0042000900000021050500334330304853
9900000009000000210505003345383048535200020009000000210505003346383048532d00020009000000210505003430303048530b000200070000002105
0200454d0a00b900070000002105020055502700b9000800000021050300525030303300b9000800000021050300544942304b00b90008000000210503005350
30305700b80009000000210505004e414d4545009a00ba0007000000210502004e50e100ba000500000014024d0027000500000013022900b7000a0000002606
0f000a00ffffffff000000000000040000002d0104000e000000240305006f0071006b0063006f006300720063006f007100040000002d010100050000001402
4d006f0005000000130263006f000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e00
0000240305006f003b006b002d006f002d0072002d006f003b00040000002d01010005000000140229006f000500000013022d006f000a00000026060f000a00
ffffffff0100000000000a00000026060f000a00ffffffff000000000000040000002d0104000e000000240305006f00f8006b00ea006f00ea007200ea006f00
f800040000002d010100050000001402dd006f00050000001302ea006f000a00000026060f000a00ffffffff01000000000009000000210505003333383048ffe10003000a00000026060f000a00ffffffff0100000000000a00000026060f000a00ffffffff010000000000040000002701ffff030000000000}}}}}
\sectd \ltrsect\linex0\colsx360\sectdefaultcl\sftnbj {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 \page eForth Kernel
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par One of the most important feature of eForth is the small machine dependent kernel, which allows its to be ported to other CPU
's very conveniently. The selection of words in this kernel is based on the criteria that they are very difficult if not impossible to synthesize from other primitive words.  From this set of kernel words, all other Forth words have to be built.  The kern
el words can be classified as following:
\par 
\par System interface:}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid9905175            }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 \tab BYE, ?rx, tx!, !io
\par Inner interpreters:     \tab doLIT, doLIST, next, ?branch,  branch, EXECUTE, EXIT
\par Memory access:          }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid16662866        }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 ! , @,  C!,  C@
\par Return stack:           \tab RP@,  RP!,  R>, R@,  R>
\par Data stack:             \tab SP@,  SP!,  DROP, DUP,  SWAP,  OVER
\par Logic:                  \tab }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid16662866               }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 0<,  AND,  OR,  XOR
\par Arithmetic:            \tab UM+
\par 
\par The virtual Forth computer is based on a tw-stack architecture.  The return stack is used to allow a high level word to b
e executed in the address list of another high level word.  It is very similar to the return stack used for nested subroutine calls in a conventional computer.  Before executing a high level word in an address list, the next address of the list is pushed 
o
n the return stack so that the IP register can be used to scan the address list in the called word.  When the called word is executed to completion, the stored address on the returned stack is popped back into IP register and execution of the calling word
 list can be continued.
\par 
\par The data stack is used to pass parameters from one word to another.  Conventional computers use the return stack to do the parameter passing, and it takes a very complicated compiler to figure out which are return addresses and whic
h are parameters.  Forth segregated these two types of information on two separate stacks and thus greatly simplies the execution and compilation of words.  Passing parameter on the data stack also reduces the syntactical complexity of Forth language to t
he minimum and allows words to be strung together into lists with minimum overhead in compilation and interpretation.
\par 
\par The kernal words move and process data and address among the stacks and the memory.  They emcompass the minimal functionality necessary to
 make a computer to behave like a Forth computer.  A complete understanding of these kernel word is vital to the understanding of a virtual Forth computer.  However, it is not difficult to understand the kernel words, because there are only 31 of them.

\par 
\par It
 is my intention to use this eForth model to illustrate the validity of 'the Forth Law of Computing', which stated that all computable functions can be constructed by lists of these kernel words and the high level words built from these kernel words.  The
 
eForth model includes a text interpreter which allows the user to type lists of word names and execute them in sequence, a compiler which allows the user to name lists of words and compile new words, and utilities like memory dump, stack dump, and a colon
 
word decompiler.  Thus the eForth system forms a fairly complete software development environment for the user to develop applications.  If such a system can be built from this small set of kernel words, it should be obvious that most practical applicatio
ns can also be built from }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid9062223 it. }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 System Interface }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par BYE returns control from eForth back to the operating system.  !io initializes the serial I/O device in the system so that it can interact with the user through a terminal.  These two words are not needed once the eForth system is up and running, but they
 
are essential to bring the system up in DOS.  ?rx is used to implement ?KEY and KEY, and tx! is used to implement EMIT.  eForth communicates with the user through these words which supports terminal interactions and file download/upload.  Here these words
 are defined using the DOS service calls.  For embedded controllers, these three words must be defined for the specific I/O devices.
\par 
\par ?RX is a unique design invented by Bill Muench to support serial input .  ?RX provides the functions required of both KEY a
nd KEY? which accept input from a terminal.  ?RX inspects the terminal device and returns a character and a true flag if the character has been received and is waiting to be retrieved.  If no character was received, ?RX simply returns a false flag.  With 
?RX, both KEY and KEY? can be defined as high level colon definitions.
\par 
\par TX! sends a character on the data stack to the terminal device.  Both ?RX and TX! are coded here as DOS calls.  In embedded applications, they will have to be coded in machine specific 
code to handle the specific serial I/O device.  !IO initializes the serial I/O device, which is not necessary here because it is taking care of by the DOS.  In embedded systems, the I/O device must be initialized by !IO.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE BYE\tab ( -- , exit Forth )
\par \tab INT\tab 020H\tab \tab \\ return to DOS 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab ?RX\tab ( -- c T | F )\tab \\
 Return input character and true, 
\par \tab \tab \tab \tab \\ or a false if no input. 
\par \tab $CODE\tab 3,'?RX',QRX
\par \tab XOR\tab BX,BX\tab \tab \\ BX=0 setup for false flag
\par \tab MOV\tab DL,0FFH\tab \\ input command
\par \tab MOV\tab AH,6\tab \tab \\ MS-DOS Direct Console I/O
\par \tab INT\tab 021H
\par \tab JZ\tab QRX3\tab \tab \\ ?key ready
\par \tab OR\tab AL,AL\tab \tab \\ AL=0 if extended char
\par \tab JNZ\tab QRX1\tab \tab \\ ?extended character code
\par \tab INT\tab 021H
\par \tab MOV\tab BH,AL\tab \tab \\ extended code in msb
\par \tab JMP\tab QRX2
\par QRX1:\tab MOV\tab BL,AL
\par QRX2:\tab PUSH\tab BX\tab \tab \\ save character
\par \tab MOV\tab BX,-1\tab \tab \\ true flag
\par QRX3:\tab PUSH\tab BX
\par \tab $NEXT
\par 
\par CODE\tab TX!\tab ( c -- )\tab \\ Send character c to output device.
\par \tab POP\tab DX\tab \tab \\ char in DL
\par \tab CMP\tab DL,0FFH\tab \\ 0FFH is interpreted as input
\par \tab JNZ\tab TX1\tab \tab \\ do NOT allow input
\par \tab MOV\tab DL,32\tab \tab \\ change to blank
\par TX1:\tab MOV\tab AH,6\tab \tab \\ MS-DOS Direct Console I/O
\par \tab INT\tab 021H\tab \tab \\ display character
\par \tab $NEXT
\par 
\par CODE\tab !IO\tab ( -- )\tab \\ Initialize the serial I/O devices.
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Inner Interpreter 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par In the word list of a colon definition, it is generally assumed that words are execution addresses, which can be executed sequentially by the address interpreter $NEXT.  However, o
ccasionally we do need to compile other types of data in-line with the words.  Special mechanisms must be used to tell the address interpreter to treat these data differently.  All data entries must be preceded by special words which can handle the data p
roperly.  A special word and its associated data form a data structure.  Data structures are extensions of words and can be thought of as building blocks to form lists in colon definitions.
\par 
\par $NEXT must be assembled at the end of a code word.  It fetches the
 next address in the address list pointed to by IP and jumps to that address.  It allows an address list to be scanned and thus executed.  doLIST starts the execution of an address list by saving IP on the return stack and stores the starting address of a
n
 address list into IP, and then $NEXT starts executing this address list.  EXIT must be compiled as the last entry in an address list.  It terminates the execution of the current address list and returns execution to the address saved on the return stack.

\par 
\par EXECUTE takes the execution address from the data stack and executes that word.  This powerful word allows the user to execute any word which is not a part of an address list.
\par 
\par doLIT pushes the next word onto the data stack as an integer literal instead o
f as an addresses to be executed by $NEXT.  It allows numbers to be compiled as in-line literals, supplying data to the data stack at run time.  doLIT is not used by itself, but rather compiled by LITERAL which inserts doLIT and its asociated integer into
 the address list under construction.  Anytime you see a number in a colon definition, LITERAL is invoked to compile an integer literal with doLIT.
\par 
\par Integer literals are by far the most numerous data structures in colon definitions other than regular words.  Address literals are used to build control structures.  String literals are used to embed text strings in colon definitions.
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 $NEXT\tab   MACRO
\par \tab   LODSW           \tab \tab \\ load next word into WP (AX)
\par         JMP     AX      \tab \tab \\ jump directly to the word thru WP
\par         ENDM\tab \tab \tab \tab \\ IP (SI) now points to the next word
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 doLIST\tab ( a -- )\tab \\
 Run address list in a colon word. 
\par \tab XCHG\tab BP,SP\tab \tab \\ exchange pointers
\par \tab PUSH\tab SI\tab \tab \\ push return stack
\par \tab XCHG\tab BP,SP\tab \tab \\ restore the pointers
\par \tab POP\tab SI\tab \tab \\ new list address
\par \tab $NEXT
\par 
\par CODE\tab EXIT\tab \tab \tab \\ Terminate a colon definition.
\par \tab XCHG\tab BP,SP\tab \tab \\ exchange pointers
\par \tab POP\tab SI\tab \tab \\ pop return stack
\par \tab XCHG\tab BP,SP\tab \tab \\ restore the pointers
\par \tab $NEXT
\par 
\par CODE\tab EXECUTE\tab ( ca -- )\tab \\ Execute the word at ca.
\par \tab POP\tab BX
\par \tab JMP\tab BX\tab \tab \\ jump to the code address
\par 
\par CODE\tab doLIT\tab ( -- w )\tab \\ Push inline literal on data stack.
\par \tab LODSW\tab \tab \tab \\ get the literal compiled in-line
\par \tab PUSH\tab AX\tab \tab \\ push literal on the stack
\par \tab $NEXT\tab \tab \tab \\ execute next word after literal
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Loops and Branches
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par eForth uses three different types of address literals. 'next', '?branch' and '
branch' are followed not by word addresses but by pointers to locations in a list to be executed next.  These address literals are the building blocks upon which loops and branching structures are constructed.  An address literal is followed by a branch p
ointer which causes execution to be transferred to that location.  The branch location most often points to a different location in the address list of the same colon word.  
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab next\tab ( -- )\tab \\
 Decrement index and exit loop 
\par \tab \tab \tab \tab \\ if index is less than 0.
\par \tab SUB\tab WORD PTR [BP],1\tab \\ decrement the index
\par \tab JC\tab NEXT1\tab \tab \\ ?decrement below 0
\par \tab MOV\tab SI,0[SI]\tab \\ no, continue loop
\par \tab $NEXT
\par NEXT1:ADD\tab BP,2\tab \tab \\ yes, pop the index
\par \tab ADD\tab SI,2\tab \tab \\ exit loop
\par \tab $NEXT
\par 
\par CODE\tab ?branch\tab ( f -- )\tab \\ Branch if flag is zero.
\par \tab POP\tab BX\tab \tab \\ pop flag
\par \tab OR\tab BX,BX\tab \tab \\ ?flag=0
\par \tab JZ\tab BRAN1\tab \tab \\ yes, so branch
\par \tab ADD\tab SI,2\tab \tab \\ point IP to next cell
\par \tab $NEXT
\par BRAN1:MOV\tab SI,0[SI]\tab \\ IP:=(IP), jump to new address
\par \tab $NEXT
\par 
\par CODE\tab branch\tab ( -- )\tab \\ Branch to an inline address.
\par \tab MOV\tab SI,0[SI]\tab \\ jump to new address unconditionally
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Address literals are used to construct control structures in colon definitions.  'next' is compiled by NEXT.  '?branch' is compiled by IF, WHILE and UNTIL.  'branch' is compiled by AFT, ELSE, REPEAT and AGAIN.  In the colon words to be discussed in the la
ter sections, you will not see these kernel words but words which construct loops and branches.  For examples:
\par 
\par \tab IF ( compiles ?branch and address after THEN ) <true clause>  THEN
\par \tab IF ( compiles ?branch and address after ELSE )  <true clause>
\par \tab \tab ELSE ( compiles branch and address after THEN ) <false clause>
\par \tab \tab THEN
\par \tab BEGIN (marks current address ) <loop clause>
\par \tab \tab AGAIN ( compiles branch and address after BEGIN )
\par \tab BEGIN ( mark current address ) <loop clause>
\par \tab \tab UNTIL ( compiles ?branch and address after BEGIN )
\par \tab BEGIN ( mark current address ) <loop clause>
\par \tab \tab WHILE ( compiles ?branch and address after REPEAT ) <true clause>
\par \tab \tab REPEAT ( compile branch and address after BEGIN )
\par \tab FOR  ( set up loop, mark current address ) <loop clause>
\par \tab \tab NEXT ( compile next and address after FOR )
\par \tab FOR ( set up loop, mark current address ) <loopclause>
\par \tab \tab AFT ( change marked address to current address, compile branch
\par \tab \tab \tab and address after THEN ) <skip clause>
\par \tab \tab THEN <loop clause>  NEXT ( compile next and address after AFT )
\par \tab \tab 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Memory Access}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par Four memory accessing words are included in the eForth kernel: ! (store), @ (fetch), C! (C-store) and C@ (C-fetch).  ! and @ access memory in cells, whose size depends on the CPU underneath.  eForth assumes that the CPU can acces
s memory in bytes and that all addresses are in the units of bytes.   C! and C@ allow the user access memory in bytes.  
\par 
\par The two most important resources in a computer are the CPU and the memory.  There is not much one can do with the CPU, except to use i
ts instruction set to write programs.  However, the real usefulness and intelligence lies with the memory, which holds both the program and the data.  In conventional languages, you humbly request memory to store your data, and the compiler reluctantly al
locate it to you.  If you exceed your memory allocation, your program will be ruthlessly terminated.  
\par 
\par In Forth, you have all the memory and you are allowed to do anything with the memory.  !, @, C! and C@ do not place restriction on their use.  You can use them to write self-modifying code if you like.  However, you must know exactly what you are doing. 

\par 
\par It is not a very good idea to change the contents of the dictionary, except in the parameter fields of variables and arrays you defined specifically for 
data storage.  The space occupied by the stacks should be respected, too.  The user variable area holds vital information for the system to run correctly.  The space bewteen the code dictionary and the name dictionary are not used and you are free to use 
it to store temporary data.  Be reminded, however, that as you define new words, the dictionaries are extended and may over-write data you placed there.
\par 
\par The moral is: Use @ and C@ freely, but be careful with ! and C!.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab !\tab ( w a -- )\tab \\
 Pop the data stack to memory.
\par \tab POP\tab BX\tab \tab \\ get address from tos
\par \tab POP\tab 0[BX]\tab \tab \\ store data to that adddress
\par \tab $NEXT
\par 
\par CODE\tab @\tab ( a -- w )\tab \\ Push memory location to data stack.
\par \tab POP\tab BX\tab \tab \\ get address
\par \tab PUSH\tab 0[BX]\tab \tab \\ fetch data
\par \tab $NEXT
\par 
\par CODE\tab C!\tab ( c b -- )\tab \\ Pop data stack to byte memory.
\par \tab POP\tab BX\tab \tab \\ get address
\par \tab POP\tab AX\tab \tab \\ get data in a cell
\par \tab MOV\tab 0[BX],AL\tab \\ store one byte
\par \tab $NEXT
\par 
\par CODE\tab C@\tab ( b -- c )\tab \\ Push byte memory content on data stack.
\par \tab POP\tab BX\tab \tab \\ get address
\par \tab XOR\tab AX,AX \tab \\ AX=0 zero the hi byte
\par \tab MOV\tab AL,0[BX]\tab \\ get low byte
\par \tab PUSH\tab AX\tab \tab \\ push on stack
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Return Stack 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par RP! pushes the address on the top of the data stack to the return stack and thus initializes the return stack.  RP! is only used to initialize the system and are seldom used in applications
.  RP@ pushes the contents of the return stack pointer RP on the data stack.  It is also used very rarely in applications.
\par 
\par >R pops a number off the data stack and pushes it on the return stack..  R> does the opposite.  R@ copies the top item on the return stack and pushes it on the data stack.
\par 
\par The eForth system uses the return stack for two specific purposes: to save addresses while recusing through an address list, and to store the loop index during a FOR-NEXT loop.  As the addresses piled up on the retu
rn stack changes dynamically as words are executed, there is very little useful information the user can get from the return stack at the run time.  In setting up a loop, FOR compiles >R, which pushes the loop index from the data stack to the return stack
.
  Inside the FOR-NEXT loop, the running index can be recalled by R@.  NEXT compiles 'next' with an address after FOR.  when 'next' is executed, it decrements the loop index on the top of the return stack.  If the index becomes negative, the loop is termin
ated; otherwise, 'next' jumps back to the word after FOR.
\par 
\par Return stack is used by the virtual Forth computer to save return addresses to be processes later.  It is also a convenient place to store data temporarily.  The return stack can thus be considered 
as a extension of the data stack.  However, one must be very careful in using the return stack for temporary storage.  The data pushed on the return stack must be popped off before EXIT is executed.  Otherwise, EXIT will get the wrong address to return to
, and the system generally will crash.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab RP@\tab ( -- a )\tab \\
 Push current RP to data stack.
\par \tab PUSH\tab BP\tab \tab \\ copy address to return stack
\par \tab $NEXT\tab \tab \tab \\ pointer register BP
\par 
\par CODE\tab RP!\tab ( a -- )\tab \\ Set the return stack pointer.
\par \tab POP\tab BP\tab \tab \\ copy (BP) to tos
\par \tab $NEXT
\par 
\par CODE\tab R>\tab ( -- w )\tab \\ Pop return stack to data stack.
\par \tab PUSH\tab 0[BP]\tab \tab \\ copy w to data stack
\par \tab ADD\tab BP,2\tab \tab \\ adjust RP for popping
\par \tab $NEXT
\par 
\par CODE\tab R@\tab ( -- w )\tab \\ Copy top of return stack to data stack.
\par \tab PUSH\tab 0[BP]\tab \tab \\ copy w to data stack
\par \tab $NEXT
\par 
\par CODE\tab >R\tab ( w -- )\tab \\ Push data stack to return stack.
\par \tab SUB\tab BP,2\tab \tab \\ adjust RP for pushing
\par \tab POP\tab 0[BP]\tab \tab \\ push w to return stack
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Data Stack 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The data stack is the centralized location where all numerical data are processed, and where parameters are passed from one word to another.
  The stack items has to be arranged properly so that they can be retrieved properly in the Last-In-First-Out (LIFO) manner.  When stack items are out of order, they can be rearranged by the stack words DUP, SWAP, OVER and DROP.  There are other stack wor
ds useful in manipulating stack items, but these four are considered to be the minimum set.
\par 
\par Data stack is initialize
d by SP!.  The depth of data stack can be examined by SP@.  These words, as RP@ and RP! are only used by the system and very rarely used in applications.  These words are necessary in the Forth kernel because you cannot operate a stack-based computer with
out these instructions.  
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab DROP\tab ( w -- )\tab \\
 Discard top stack item.
\par \tab ADD\tab SP,2\tab  \tab \\ adjust SP to pop
\par \tab $NEXT
\par 
\par CODE\tab DUP\tab ( w -- w w )\tab \\ Duplicate the top stack item.
\par \tab MOV\tab BX,SP \tab \\ use BX to index the stack
\par \tab PUSH\tab 0[BX]
\par \tab $NEXT
\par 
\par CODE\tab SWAP\tab ( w1 w2 -- w2 w1 )\tab \\ Exchange top two stack items.
\par \tab POP\tab BX\tab \tab \\ get w2
\par \tab POP\tab AX\tab \tab \\ get w1
\par \tab PUSH\tab BX\tab \tab \\ push w2
\par \tab PUSH\tab AX\tab \tab \\ push w1
\par \tab $NEXT
\par 
\par CODE\tab OVER\tab ( w1 w2 -- w1 w2 w1 )\tab \\ Copy second stack item to top.
\par \tab MOV\tab BX,SP \tab \\ use BX to index the stack
\par \tab PUSH\tab 2[BX]\tab \tab \\ get w1 and push on stack
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab SP@\tab ( -- a )\tab \\
 Push the current data stack pointer.
\par \tab MOV\tab BX,SP \tab \\ use BX to index the stack
\par \tab PUSH\tab BX\tab \tab \\ push SP back
\par \tab $NEXT
\par 
\par CODE\tab SP!\tab ( a -- )\tab \\ Set the data stack pointer.
\par \tab POP\tab SP\tab \tab \\ safety
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Logical Words
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The only primitive word which cares about logic is '?branch'.  It tests the top item on the stack.  If it is zero, ?branch will branch to the following address.  If it is not zero, ?branch will ignore the address and execute the word after the branch addr
e
ss.  Thus we distinguish two classes of numbers, zero for 'false' and non-zero for 'true'.  Numbers used this way are called logic flags which can be either true or false.  The only primitive word which generates flags is '0<', which examines the top item
 on the data stack for its negativeness.  If it is negative, '0<' will return a -1 for true.  If it is 0 or positive, '0<' will return a 0 for false.
\par 
\par The three logic words AND, OR and XOR are bitwise logic operators over the width of a cell.  They can be u
sed to operate on real flags (0 and -1) for logic purposes.  The user must be aware of the distinct behaviors between the real flags and the generalized flags.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab 0<\tab ( n -- f )\tab \\
 Return true if n is negative.
\par \tab POP\tab AX
\par \tab CWD\tab     \tab \tab \\ sign extend AX into DX
\par \tab PUSH\tab DX\tab \tab \\ push 0 or -1
\par \tab $NEXT
\par 
\par CODE\tab AND\tab ( w w -- w )\tab \\ Bitwise AND.
\par \tab POP\tab BX
\par \tab POP\tab AX
\par \tab AND\tab BX,AX
\par \tab PUSH\tab BX
\par \tab $NEXT
\par 
\par CODE\tab OR\tab ( w w -- w )\tab \\ Bitwise inclusive OR.
\par \tab POP\tab BX
\par \tab POP\tab AX
\par \tab OR\tab BX,AX
\par \tab PUSH\tab BX
\par \tab $NEXT
\par 
\par CODE\tab XOR\tab ( w w -- w )\tab \\ Bitwise exclusive OR.
\par \tab POP\tab BX
\par \tab POP\tab AX
\par \tab XOR\tab BX,AX
\par \tab PUSH\tab BX
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Primitive Arithmetic }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par The only primitive arithmetic word in the eForth kernel is UM+.  All other arithmetic words, like +, -, * and / are derived from UM+ as colon definitions.  This design emphasize portability over p
erformance, because it greatly reduces the efforts in moving eForth into CPU's which do not have native multiply and divide instructions.  Once eForth is implemented on a new CPU, the more complicated arithmetic words are the first ones to be optimized to
 enhance the performance.
\par 
\par UM+ adds two unsigned number on the top of the data stack and returns to the data stack the sum of these two numbers and the carry as one number on top of the sum.  To handle the carry this way is very inefficient, because most CP
U's have carry as a bit in the status register, and the carry can be accessed by many machine instructions.  It is thus more convenient to use carry in machine code programming.  eForth provides the user a handle on the carry in high level, making it easi
er for the user to deal with it directly.  
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 CODE\tab UM+\tab ( w w -- w cy )
\par \\ \tab Add two numbers, return the sum and carry flag.
\par \tab XOR\tab CX,CX \tab \\ CX=0 initial carry flag
\par \tab POP\tab BX
\par \tab POP\tab AX
\par \tab ADD\tab AX,BX
\par \tab RCL\tab CX,1        \tab \\ get carry
\par \tab PUSH\tab AX   \tab \tab \\ push sum
\par \tab PUSH\tab CX  \tab \tab \\ push carry
\par \tab $NEXT
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 High Level Forth Words
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Following are the eForth words defined as high level colon definitions.  They are built from the primitive eForth words and other high level eForth words, including data structures and control structures.  Sinc
e eForth source is coded in Microsoft MASM assembler, the word lists in the colon definitions are constructed as data in MASM, using the DW directive.  This form of representation, though very effective, is very difficult to read.  The original model of e
F
orth as provided by Bill Muench was in the form of a Forth source listing.  This listing is much simpler and easy to read, assuming that the reader has some knowledge of the Forth syntax.  This listing is also a very good source to learn a good coding sty
l
e of Forth.  I therefore think it is better to present the high level Forth colon definitions in this form.  As the 8086 eForth implementation deviates slightly from the original Forth model, I tried to translate the 8086 implementation faithfully back to
 the Forth style for our discussion here.
\par 
\par The sequence of words is exactly the same as that in the MASM assembly source listing.  The reader is encouraged to read the MASM source listing along with the text in this book.  Reading two descriptions of the sa
me subject often enable better comprehension and understanding.
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Variables  and User Variables
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The term user variable was codified in earlier Forth systems on the mini-computers in which multitasking was an integral part of the Forth operating system.  I
n a multitasking system, many user share CPU and other resources in the computing system.  Each user has a private memory area to store essential information about its own task so that the system can leave a task temporarily to serve other users and retur
n to this task continuing the unfinished work.  In a single user environment, the user variables have the same functionality as system variables.
\par 
\par In eForth, all variables used by the system are merged together and are implemented uniformly as user variable
s.  A special memory area in the high memory is allocated for all these variables, and they are all initialized by copying a table of initial values stored in the cold boot area.  A significant benefit of this scheme is that it allows the eForth system to
 operate in ROM memory naturally.  It is very convenient for embedded system applications which preclude mass storage and file downloading.
\par 
\par In an application, the user can choose to implement variables in the forms of user variables or regular variables wh
en running in RAM memory.  To run things in ROM, variables must be defined as user variables.  Although eForth in the original model allows only a small number of user variable to be defined in an application, the user area can be enlarged at will by chan
ging a few assembly constants and equates.
\par 
\par In eForth only one vocabulary is used.  The name of this vocabulary is FORTH.  When FORTH is executed, the address of the pointer to the top of the dictionary is written into the first cell in the CONTEXT array.  
When the text interpreter searches the dictionary for a words, it picks up the pointer in CONTEXT and follow the thread through the name dictionary.  If the name dictionary is exhausted, the text interpreter will pick up the next cell in the CONTEXT array
 and do the search.  The first cell in CONTEXT array containing a 0 stops the searching.  There are 8 cells in the CONTEXT array. Since the last cell must be zero, eForth allows up to 8 context vocabularies to be searched.
\par 
\par There are two empty cells in the 
code field of FORTH.  The first cell stores the pointer to the last name field in the name dictionary.  The second field must be a 0, which serves to terminate a vocabulary link when many vocabularies are created.  Vocabularies are useful in reducing the 
n
umber of words the text interpreter must search to locate a word, and allowing related words to be grouped together as logic modules.  Although the eForth itself only uses one vocabulary, the mechanism is provided to define multiple vocabularies in large 
applications.
\par 
\par The CONTEXT arrays is designed as a vocabulary stack to implement the ONLY- ALSO concept of vocabulary search order first  proposed by Bill Ragsdale in the Forth 83 Standard.
\par 
\par CURRENT points to a vocabulary thread to which new definitions are to be added.  
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : doVAR ( -- a ) R> ; 
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 VARIABLE UP\tab ( -- a, Pointer to the user area.)
\par 
\par : doUSER\tab ( -- a, Run time routine for user variables.)
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx4320\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 \tab R> @ \tab \tab \tab \tab \\
 retrieve user area offset
\par \tab UP @ + ; \tab \tab \tab \\ add to user area base addr
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : doVOC ( -- ) R> CONTEXT ! ;
\par 
\par : FORTH ( -- ) doVOC [ 0 , 0 ,
\par 
\par : doUSER ( -- a ) R> @ UP @ + ; 
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 eForth provides many functions in the vectored form to allow the behavior the these functions to be changed dynamically at r
un time.  A vectored function stores a code address in a user variable. @EXECUTE is used to execute the function, given the address of the user variable.  Following is the list of user variables defined in eForth:
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 SP0\tab \tab ( -- a, pointer to bottom of the dat
a stack.)
\par RP0\tab \tab ( -- a, pointer to bottom of the return stack.)
\par '?KEY\tab \tab ( -- a, execution vector of ?KEY.  Default to ?rx.)
\par 'EMIT\tab \tab ( -- a, execution vector of EMIT.  Default to tx!)
\par 'EXPECT\tab ( -- a, execution vector of EXPECT.  Default to 'accept'.)
\par 'TAP\tab \tab ( -- a, execution vector of TAP.  Defulat the kTAP.)
\par 'ECHO\tab \tab ( -- a, execution vector of ECHO.  Default to tx!.)
\par 'PROMPT\tab ( -- a, execution vector of PROMPT.  Default to '.ok'.)
\par BASE\tab \tab ( -- a,.radix base for numeric I/O.  Default to 10.)
\par tmp\tab \tab ( -- a, a temporary storage location used in parse and find.)
\par SPAN\tab \tab ( -- a, hold character count received by EXPECT.)
\par >IN\tab \tab ( -- a, hold the character pointer while parsing input stream.)
\par #TIB\tab \tab ( -- a, hold the current count and address of the terminal input \tab \tab buffer. Terminal Input Buffer used one cell after #TIB.)
\par CSP\tab \tab ( -- a, hold the stack pointer for error checking.)
\par 'EVAL\tab \tab ( -- a, execution vector of EVAL. Default to EVAL.)
\par 'NUMBER\tab ( -- a, address of number conversion.  Default to NUMBER?.)
\par HLD\tab \tab ( -- a, hold a pointer in building a numeric output string.)
\par HANDLER\tab ( -- a, hold the return stack pointer for error handling.)
\par CONTEXT\tab ( -- a, a area to specify vocabulary search order.  Default to \tab \tab FORTH. Vocabulary stack, 8 cells follwing CONTEXT.)
\par CURRENT\tab ( -- a, point to the vocabulary to be extended.  Default to FORTH.
\par \tab \tab Vocabulary link uses one cell after CURRENT.)
\par CP\tab \tab ( -- a, point to the top of the code dictionary.)
\par NP\tab \tab ( -- a, point to the bottom of the name dictionary.)
\par LAST\tab \tab ( -- a, point to the last name in the name dictionary.)
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Common Functions}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par This group of Forth words are commonly used in writing Forth applications.  They are coded in high level to enhance the portability of eForth.  In most Forth implementations, they are coded in machine language to increase
 the execute speed.  After an eForth system is ported to a new CPU, this word set should be recoded in assembly to improve the run time performance of the system.
\par 
\par ?DUP, ROT, 2DROP,  and 2DUP are stack operators supplementing the four classic stack operators DUP, SWAP, OVER and DROP. 
\par 
\par ROT is unique in that it accesses the third item on the data stack.  All other stack operators can only access one or two stack items
.  In Forth programming, it is generally accepted that one should not try to access stack items deeper than the third item.  When you have to access deeper into the data stack, it is a good time to re-evaluate your algorithm.  Most often, you can avoid th
is situation by factoring your code into smaller parts which do not reach so deep.
\par 
\par +, - and D+ are simple extensions from the primitive word UM+.  It is interesting to see how the more commonly used arithmetic operators are derived.  + is UM+ with the carr
y discarded.  NOT returns the ones compliment of a number, and NEGATE returns the two's compliment.  Because UM+ preserves the carry, it can be used to form multiple precision operators like D+.  Later we will see how UM+ is used to do multiplication and 
division.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ?DUP ( w -- w w | 0 ) DUP IF DUP THEN ;
\par : ROT ( w1 w2 w3 -- w2 w3 w1 ) >R SWAP R> SWAP ;
\par : 2DROP ( w w  -- ) DROP DROP ;
\par : 2DUP ( w1 w2 -- w1 w2 w1 w2 ) OVER OVER ;
\par : + ( w w -- w ) UM+ DROP ;
\par : NOT ( w -- w ) -1 XOR ;
\par :  NEGATE ( n -- -n ) NOT 1 + ;
\par : DNEGATE ( d -- -d ) NOT >R NOT 1 UM+ R> + ;
\par : D+ ( d d -- d ) >R SWAP >R UM+ R> R> + + ;
\par : - ( w w -- w ) NEGATE + ;
\par : ABS ( n -- +n ) DUP 0< IF NEGATE THEN ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Comparison
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The primitive comparison word in eForth is ?branch and 0<.  However, ?bran
ch is at such a low level that it can not be readily used in high level Forth code.  ?branch is secretly compiled into the high level Forth words by IF as an address literal.  For all intentions and purposes, we can consider IF the equivalent of ?branch. 
 When IF is encountered, the top item on the data stack is considered a logic flag.  If it is true (non-zero), the execution continues until ELSE, then jump to THEN, or to THEN directly if there is no ELSE clause.
\par 
\par The following logic words are constructed 
using the IF...ELSE...THEN structure with 0< and XOR.  XOR is used as 'not equal' operator, because if the top two items on the data stack are not equal, the XOR operator will return a non-zero number, which is considered to be 'true'.  
\par 
\par U< is used to com
pared two unsigned numbers.  This operator is very important, especially in comparing addresses, as we assume that the addresses are unsigned numbers pointing to unique memory locations.  The arithmetic comparison operator < cannot be used to determine wh
ether one address is higher or lower than the other.  Using < for address comparison had been the single cause of many failures in the annals of Forth.
\par 
\par MAX retains the larger of the top two items on the data stack.  Both numbers are assumed to be signed integers.
\par 
\par MIN retains the smaller of the top two items on the data stack.  Both numbers are assumed to be signed integers.
\par 
\par WITHIN 
checks whether the third item on the data stack is within the range as specified by the top two numbers on the data stack.  The range is inclusive as to the lower limit and exclusive to the upper limit.  If the third item is within range, a true flag is r
eturned on the data stack.  Otherwise, a false flag is returned.  All numbers are assumed to be unsigned integers.  
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : = ( w w -- t ) XOR IF 0 EXIT THEN -1 ;
\par : U< ( u u -- t ) 2DUP XOR 0< IF SWAP DROP 0< EXIT THEN - 0< ;
\par :  < ( n n -- t ) 2DUP XOR 0< IF      DROP 0< EXIT THEN - 0< ;
\par : MAX ( n n -- n ) 2DUP      < IF SWAP THEN DROP ;
\par : MIN ( n n -- n ) 2DUP SWAP < IF SWAP THEN DROP ;
\par : WITHIN ( u ul uh -- t ) \\ ul <= u < uh
\par   OVER - >R - R> U< ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 
\f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 \page Divide 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par This group of words provide a variety of multiplica
tion and division functions.  The most interesting feature of this word set is that they are all based on the primitive UM+ operator in the kernel. Building this word set in high level has the penalty that all math operations will be slow.  However, since
 
eForth needs these functions only in numeric I/O conversions, the performance of eForth itself is not substantially affected by them.  Nevertheless, if an application requires lots of numeric computations, a few critical words in this word set should be r
ecoded in assembly.  The primary candidates for optimization are UM/MOD and UM*, because all other multiply and divide operators are derived from these two words.
\par 
\par UM/MOD and UM* are the most complicated and comprehensive division and multiplication operato
rs.  Once they are coded, all other division and multiplication operators can be derived easily.  It has been a tradition in Forth coding that one solves the most difficult problem first, and all other problems are solved by themselves.
\par 
\par UM/MOD divides an unsigned double integer by an unsigned signal integer.  It returns the unsigned remainder and unsigned quotient on the data stack.
\par 
\par M/MOD divides a signed double integer by a signed signal integer.  It returns the signed remainder and signed quotient on the data stack.  The signed division is floored towards negative infinity.
\par 
\par /MOD divides a signed single integer by a signed integer.  It returns the signed remainder and quotient.  MOD is similar to /MOD, except that only the signed remainder is returned.  
/ is also similar to /MOD, except that only the signed quotient is returned.
\par 
\par In most advanced microprocessors like 8086, all these division operations can be performed by the CPU as native machine instructions.  The user can take advantage of these machine instructions by recoding these Forth words in machine code.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : UM/MOD ( ud u -- ur uq )
\par   2DUP U<
\par   IF NEGATE  15
\par     FOR >R DUP UM+ >R >R DUP UM+ R> + DUP
\par         R> R@ SWAP >R UM+  R> OR
\par       IF >R DROP 1 + R> ELSE DROP THEN R>
\par     NEXT DROP SWAP EXIT
\par   THEN DROP 2DROP  -1 DUP ;
\par 
\par : M/MOD ( d n -- r q ) \\ floored division
\par   DUP 0<  DUP >R
\par   IF NEGATE >R DNEGATE R>
\par   THEN >R DUP 0< IF R@ + THEN R> UM/MOD R>
\par   IF SWAP NEGATE SWAP THEN ;
\par 
\par : /MOD ( n n -- r q ) OVER 0< SWAP M/MOD ;
\par : MOD ( n n -- r ) /MOD DROP ;
\par : / ( n n -- q ) /MOD SWAP DROP ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 
\f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\f5\fs20\insrsid10628273\charrsid9062223 Multiply 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 UM* is the most complicated multiplication operation.  Once it is coded, all other multiplication words can be derived from it.  
\par 
\par UM* multiplies two unsigned single integers and returns the unsigned dou
ble integer product on the data stack.  M*  multiplies two signed single integers and returns the signed double integer product on the data stack.  * multiplies two signed single integers and returns the signed single integer product on the data stack.

\par 
\par Again, advanced CPU's generally have these multiplication operations as native machine instructions.  The user should take advantage of these resources to enhance the eForth system.
\par 
\par Forth is very close to the machine language that it generally only handles integer numbers.  There are floating point extensions on many more sophisticated Forth systems, but they are more exceptions than rules.  The reason that Forth has traditionally be
e
n an integer language is that integers are handled faster and more efficiently in the computers, and most technical problems can be solved satisfactorily using integers only.  A 16-bit integer has the dynamic range of 110 dB which is far more than enough 
f
or most engineering problems.  The precision of a 16-bit integer representation is limited to one part in 65535, which could be inadequate for small numbers.  However, the precision can be greatly improved by scaling; i.e., taking the ratio of two integer
s.  It was demonstrated that pi, or any other irrational numbers, can be represented accurately to 1 part in 100,000,000 by a ratio of two 16-bit integers.
\par 
\par The scaling operators */MOD and */ are useful in scaling number n1 by the ratio of n2/n3.  When n2 a
nd n3 are properly chosen, the scaling operation can preserve precision similar to the floating point operations at a much higher speed.  Notice also that in these scaling operations, the intermediate product of n1 and n2 is a double precision integer so 
that the precision of scaling is maintained.
\par 
\par */MOD multiplies the signed integers n1 and n2, and then divides the double integer product by n3.  It in fact is ratioing n1 by n2/n3.  It returns both the remainder and the quotient.  */ is similar to */MOD except that it only returns the quotient.

\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : UM* ( u u -- ud )
\par   0 SWAP ( u1 0 u2 ) 15
\par   FOR DUP UM+ >R >R DUP UM+ R> + R>
\par     IF >R OVER UM+ R> + THEN
\par   NEXT ROT DROP ;
\par 
\par : * ( n n -- n ) UM* DROP ;
\par 
\par : M* ( n n -- d )
\par   2DUP XOR 0< >R  ABS SWAP ABS UM*  R> IF DNEGATE THEN ;
\par 
\par : */MOD ( n n n -- r q ) >R M* R> M/MOD ;
\par : */ ( n n n -- q ) */MOD SWAP DROP ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Memory  Alignment }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par The most serious problem in porting system from one computer to another is that different computers have different sizes for their addre
sses and data.  We generally classify computers as 8, 16, 32, ... , bit machines, because they operate on data of these various sizes.  It is thus difficult to port a single programming model as eForth to all these computers.  In eForth, a set of memory a
lignment words helps to make it easier to port the eForth model to different machines.
\par 
\par We assume that the target computer can address it memory in 8 bit chunks (bytes).  The natural width of data best handled by the computer is thus a multiple of bytes.   
A unit of such data is a cell.  An 16 bit machine handles data in 2 byte cells, and a 32 bit machine handles data in 4 byte cells.
\par 
\par CELL+ increments the memory address by the cell size in bytes, and CELL- decrements the memory address by the cell size.  CE
LLS multiplies the cell number on the stack by the cell size in bytes.  These words are very useful in converting a cell offset into a byte offset, in order to access integers in a data array.
\par 
\par ALIGNED converts an address on the stack to the next cell boundary, to help accessing memory by cells.
\par 
\par The blank character (ASCII 32) is special in eForth because it is the most often used character to delimit words in the input stream and the most often used character to format the output
 strings.  It is used so often that it is advantageous to define an unique word for it.  BL simply returns the number 32 on the data stack.
\par 
\par >CHAR is very important in converting a non-printable character to a harmless 'underscare' character(ASCII 95).  As
 eForth is designed to communicate with a host computer through the serial I/O device, it is important that eForth will not emit control characters to the host and causes unexpected behavior on the host computer.  >CHAR thus filters the characters before 
they are sent out by EMIT.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
DEPTH returns the number of items currently on the data stack to the top of the stack.  PICK takes a number  n  off the data stack and replaces it with the n'th item on the data stack.  The number  n  is 0-based; i.e., the top it
em is number 0,  the next item is number 1, etc.  Therefore, 0 PICK is equivalent to DUP, and 1 PICK is  equivalent to OVER.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : CELL- ( a -- a ) -2 + ;
\par : CELL+ ( a -- a )  2 + ;
\par : CELLS ( n -- n )  2 * ;
\par 
\par : ALIGNED ( b -- a )
\par   DUP 0 2 UM/MOD DROP DUP
\par   IF 2 SWAP - THEN + ;
\par 
\par : BL ( -- 32 ) 32 ;
\par 
\par : >CHAR ( c -- c )
\par   $7F AND DUP 127 BL WITHIN IF DROP 95 THEN ;
\par 
\par : DEPTH ( -- n ) SP@ SP0 @ SWAP - 2 / ;
\par 
\par : PICK ( +n -- w ) 1 + CELLS SP@ + @ ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\b\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Memory Access     \tab 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Here are three useful memory operators.  +! increments the contents of a memory location by an integer on the stack.  2! and 2@ store and fetch double integers to and from memory.
\par 
\par There are three buffer areas used often in the eForth system.  HERE returns
 the address of the first free location above the code dictionary, where new words are compiled.  PAD returns the address of the text buffer where numbers are constructed and text strings are stored temporarily.  TIB is the terminal input buffer where inp
ut text string is held.
\par 
\par @EXECUTE is a special word supporting the vectored execution words in eForth.  It takes the word address stored in a memory location and executes the word.  It is used extensively to execute the vectored words in the user area.
\par 
\par A m
emory array is generally specified by a starting address and its length in bytes.  In a string, the first byte is a count byte, specifying the number of bytes in the following string.  This is called a counted string.  String literals in the colon definit
ions and the name strings in the name dictionary are all represented by counted strings.  Following are special words which handles memory arrays and strings.
\par 
\par COUNT converts a string array address to the address-length representation of a counted string.    CMOVE copies a memory array from one location to another.  FILL fills a memory array with the same byte.
\par 
\par Arrays and strings are generally specified by the address of the first byte in the array or string, and the byte length.  This specification of cour
se is the consequence that the memory is byte addressable.  In a CPU which address memory in cells, these words must be defined in terms of an artificial byte space.
\par    
\par -TRAILING removes the trailing white space characters from the end of a string. White 
space characters include all the non-printable characters below ASCII 32. This word allows eForth to process text lines in files downloaded from a host computer.  It conveniently eliminates carriage-returns, life-feeds, tabs and spaces at the end of the t
ext lines.
\par 
\par PACK$ is an important string handling word used by the text interpreter.  It copies a text string from on location to another.  In the target area,  the string is converted to a counted string by adding a count byte before the text of the string
.  This word is used to build the name field of a new word at the bottom of the name dictionary.  PACK$ is designed so that it can pack bytes into cells in a cell addressable machine.
\par 
\par A cheap way to implement eForth on a cell addressable machine is to equ
ate cell addresses to byte addresses, and to store one byte in a cell.  This scheme is workable, but very inefficient in the memory utilization.  PACK$ is a tool which helps the implementor to bridge the gap.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : +! ( n a -- ) SWAP OVER @ + SWAP ! ;
\par 
\par : 2! ( d a -- ) SWAP OVER ! CELL+ ! ;
\par : 2@ ( a -- d ) DUP CELL+ @ SWAP @ ;
\par 
\par : COUNT ( b -- b +n ) DUP 1 + SWAP C@ ;
\par 
\par : HERE ( -- a ) CP @ ;
\par : PAD ( -- a ) HERE 80 + ;
\par : TIB ( -- a ) #TIB CELL+ @ ;
\par 
\par : @EXECUTE ( a -- ) @ ?DUP IF EXECUTE THEN ;
\par 
\par : CMOVE ( b b u -- )
\par   FOR AFT >R DUP C@ R@ C! 1 + R> 1 + THEN NEXT 2DROP ;
\par 
\par : FILL ( b u c -- )
\par   SWAP FOR SWAP AFT 2DUP C! 1 + THEN NEXT 2DROP ;
\par 
\par : -TRAILING ( b u -- b u )
\par   FOR AFT BL OVER R@ + C@ <
\par     IF R> 1 + EXIT THEN THEN
\par   NEXT 0 ;
\par 
\par : PACK$ ( b u a -- a ) \\ null fill
\par   ALIGNED  DUP >R OVER
\par   DUP 0 2 UM/MOD DROP
\par   - OVER +  0 SWAP !  2DUP C!  1 + SWAP CMOVE  R> ;
\par 
\par }\pard\plain \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 
\af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Text Interpreter
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par The text interpreter is also called the outer interpreter in Forth.  It is functionally equivalent to an operating
 system in a conventional computer.  It accepts command similar to English entered by a user, and carries out the tasks specified by the commands.  As an operating system, the text interpreter must be complicated, because of all the things it has to do.  
H
owever, because Forth employs very simple syntax rules, and has very simple internal structures, the Forth text interpreter is much simpler that conventional operating systems.  It is simple enough that we can discuss it completely in a single chapter, ad
mitted that this is a long chapter.
\par 
\par Let us summarize what a text interpreter must do:
\par 
\par \tab Accept text input from a terminal
\par \tab Parse out commands from input text
\par \tab Search dictionary
\par \tab Execute commands
\par \tab Translate numbers into binary
\par \tab Display numbers in text form
\par \tab Handle errors gracefully
\par \tab 
\par Forth allows us to build and integrate these required functions gradually in modules.  All the modules finally fall into their places in the word QUIT, which is the text interpreter itself.
\par 
\par You might want to look up the code of
 QUIT first and see how the modules fit together.  A good feeling about the big picture will help you in the study of the smaller modules.  Nevertheless, we will doggedly follow the loading order of the source code, and hope that you will not get lost too
 far in the progress.
\par 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Numeric Output
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Forth is interesting in its special capabilities in handling numbers across the man-machine interface.  It recognizes that the machine and the human prefer very different representations of numbers.  The machine prefe
rs the binary representation, but the human prefers decimal Arabic digital representations.  However, depending on circumstances, the human may want numbers to be represented in other radices, like hexadecimal, octal, and sometimes binary.
\par 
\par Forth solves th
is problem of internal (machine) versus external (human) number representations by insisting that all numbers are represented in the binary form in the CPU and in memory.  Only when numbers are imported or exported for human consumption are they converted
 to the external ASCII representation.  The radix of external representation is controlled by the radix value stored in the user variable BASE.
\par 
\par Since BASE is a user variable, the user can select any reasonable radix for entering numbers  into the computer 
and format ting numbers to be shown to the user.  Most programming languages can handle a small set of radices, like decimal, octal, hexadecimal and binary.  
\par 
\par DIGIT converts an integer to a digit.  EXTRACT extracts the least significan digit from a number n.  n is divided by the radix in BASE and returned on the stack.
\par 
\par The output number string is built below the PAD buffer.  The least significant digit is extracted from the integer on the top of the data stack by dividing it by the current radix in BASE. 
 The digit thus extracted are added to the output string backwards from PAD to the low memory. The conversion is terminated when the integer is divided to zero. The address and length of the number string are made available by #> for outputting.
\par 
\par An output
 number conversion is initiated by <# and terminated by #>.  Between them, # converts one digit at a time, #S converts all the digits, while HOLD and SIGN inserts special characters into the string under construction.  This set of words is very versatile 
and can handle many different output formats.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : DIGIT ( u -- c ) 9 OVER < 7 AND + 48 + ;
\par : EXTRACT ( n base -- n c ) 0 SWAP UM/MOD SWAP DIGIT ;
\par 
\par : <# ( -- ) PAD HLD ! ;
\par 
\par : HOLD ( c -- ) HLD @ 1 - DUP HLD ! C! ;
\par 
\par : # ( u -- u ) BASE @ EXTRACT HOLD ;
\par 
\par : #S ( u -- 0 ) BEGIN # DUP WHILE REPEAT ;
\par 
\par : SIGN ( n -- ) 0< IF 45 HOLD THEN ;
\par 
\par : #> ( w -- b u ) DROP HLD @ PAD OVER - ;
\par 
\par : str ( n -- b u ) DUP >R ABS <# #S R> SIGN #> ;
\par 
\par : HEX ( -- ) 16 BASE ! ;
\par : DECIMAL ( -- ) 10 BASE ! ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\b\f39\fs20\insrsid10628273\charrsid9062223 
\par \page Number Output }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par With the
 number formatting word set as shown above, one can format numbers for output in any form desired.  The free output format is a number string preceded by a single space.  The fix column format displays a number right-justified in a column of pre-determine
d width.  The words ., U., and ? use the free format.  The words .R and U.R use the fix format.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 : str\tab ( n -- b u )
\par \tab ( Convert a signed integer to a numeric string.)
\par }\pard\plain \ltrpar\s20\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab DUP >R \tab \tab ( save a copy for sign)
\par \tab ABS \tab \tab \tab ( use absolute of n)
\par \tab <# #S \tab \tab ( convert all digits)\tab 
\par \tab R> SIGN \tab \tab ( add sign from n)
\par \tab #> ;\tab \tab \tab ( return number string addr and length)
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 : HEX\tab ( -- )
\par \tab ( Use radix 16 as base for numeric conversions.)
\par \tab 16 BASE ! ;
\par 
\par : DECIMAL\tab ( -- )
\par \tab ( Use radix 10 as base for numeric conversions.)
\par \tab 10 BASE ! ;
\par 
\par : .R\tab ( n +n -- )
\par \tab ( Display an integer in a field of n columns, right justified.)
\par }\pard\plain \ltrpar\s20\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab >R str      \tab ( convert n to a number string)
\par \tab R> OVER - SPACES \tab ( print leading spaces)
\par \tab TYPE ;\tab \tab ( print number in +n column format)
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par : U.R\tab ( u +n -- )
\par \tab ( Display an unsigned integer in n column, right justified.)
\par }\pard\plain \ltrpar\s20\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab >R \tab \tab \tab ( save column number)
\par \tab <# #S #> R> \tab ( convert unsigned number)
\par \tab OVER - SPACES \tab ( print leading spaces)
\par \tab TYPE ;\tab \tab ( print number in +n columns)
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par : U.\tab ( u -- )
\par \tab ( Display an unsigned integer in free format.)
\par }\pard\plain \ltrpar\s20\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab <# #S #> \tab \tab ( convert unsigned number)
\par \tab SPACE \tab \tab ( print one leading space)
\par \tab TYPE ;\tab \tab ( print number)
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par : .\tab ( w -- )
\par \tab ( Display an integer in free format, preceeded by a space.)
\par }\pard\plain \ltrpar\s20\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab BASE @ 10 XOR \tab ( if not in decimal mode)
\par \tab IF U. EXIT THEN \tab ( print unsigned number)
\par \tab str SPACE TYPE ;\tab ( print signed number if decimal)
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 
\f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 : ?\tab ( a -- )
\par \tab ( Display the contents in a memory cell.)
\par \tab @ . ;\tab \tab \tab ( very simple but useful command)
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Numeric Input
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The Forth text interpreter also handles the number input to the system.  It parses
 words out of the input stream and try to execute the words in sequence.  When the text interpreter encounters a word which is not the name of a word in the dictionary, it then assumes that the word must be a number and attempts to convert the ASCII strin
g
 to a number according to the current radix.  When the text interpreter succeeds in converting the string to a number, the number is pushed on the data stack for future use if the text interpreter is in the interpreting mode.  If it is in the compiling mo
de, the text interpreter will compile the number to the code dictionary as an integer literal so that when the word under construction is later executed, this literal integer will be pushed on the data stack.
\par 
\par If the text interpreter fails to convert the word to a number, there is an error condition which will cause the text interpreter to abort, posting an error message to the user, and then wait for the user's next line of commands.
\par 
\par Only two words are needed in eForth to handle input of single precision integer numbers.  
\par 
\par DIGIT? converts a digit to its numeric value according to the current base, and NUMBER? converts a number string to a single integer.  NUMBER? is vectored through 'NUMBER to convert numbers.
\par 
\par NUMBER? converts a string of digits to a single integer.  If the first character is a $ sign, the number is assumed to be in hexadecimal.  Otherwise, the number will be converted using the radix value stored in BASE.  For negative numbers, the first chara
c
ter should be a - sign.  No other characters are allowed in the string.  If a non-digit character is encountered, the address of the string and a false flag are returned.  Successful conversion returns the integer value and a true flag.  If the number is 
larger than 2**n, where n is the bit width of the single integer, only the modulus to 2**n will be kept.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : DIGIT? ( c base -- u t )
\par   >R 48 - 9 OVER <
\par   IF 7 - DUP 10 < OR THEN DUP R> U< ;
\par 
\par : NUMBER? ( a -- n T | a F )
\par   BASE @ >R  0 OVER COUNT ( a 0 b n)
\par   OVER C@ 36 =
\par   IF HEX SWAP 1 + SWAP 1 - THEN ( a 0 b' n')
\par   OVER C@ 45 = >R ( a 0 b n)
\par   SWAP R@ - SWAP R@ + ( a 0 b" n") ?DUP
\par   IF 1 - ( a 0 b n)
\par     FOR DUP >R C@ BASE @ DIGIT?
\par       WHILE SWAP BASE @ * +  R> 1 +
\par     NEXT DROP R@ ( b ?sign) IF NEGATE THEN SWAP
\par       ELSE R> R> ( b index) 2DROP ( digit number) 2DROP 0
\par       THEN DUP
\par   THEN R> ( n ?sign) 2DROP R> BASE ! ;
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Basic I/O 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The eForth system assumes that the system will communicate with its environment only through a serial I/O interface.  To support the serial I/O, only three words are needed:
\par 
\par ?KEY returns a false flag if no character is pending on the receiver. If a character is received, the character and a true flag are returned.  This word is more powerful than that usually defined in most Forth systems because it consolidate the functional
ity of KEY into ?KEY.  It simplifies the coding of the machine dependent I/O interface.
\par 
\par KEY will execute ?KEY continually until a valid character is received and the character is returned.  EMIT sends a character out throughout the transmit line.
\par 
\par ?KEY and
 EMIT are vectored through '?KEY and 'EMIT, so that their function can be changed dynamically at run time.  Normally ?KEY executes ?RX and EMIT executes TX!.  ?RX and TX! are machine dependent kernel words.  Vectoring the I/O words allows the eForth syste
m to changes its I/O channels dynamically and still uses all the existing tools to handle input and output transactions.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
All I/O words are derived from ?KEY, KEY and EMIT.  The following set defined in eForth is particularly useful in normal programming:
\par 
\par SPACE outputs a blank space character.  SPACES output n blank space characters.  CR outputs a carriage-return and a line-feed.  PACE outputs an ASCII 11 character to acknowledge lines received during file downloading.
\par 
\par NUF? returns a false flag if no chara
cter is pending in the input buffer.  After receiving a character, pause and wait for another character.  If this character is CR, return a true flag; otherwise, return false.  This word is very useful in user interruptable routines.
\par 
\par TYPE outputs n characters from a string in memory.
\par 
\par With the number formatting word set as shown above, one can format numbers for output in any form desired.  The free output format is a number string preceded by a single space.  The fix column format displays a number right-
justified in a column of pre-determined width.  The words ., U., and ? use the free format.  The words .R and U.R use the fix format.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
String literals are data structures compiled in colon definitions, in-line with the words.  A string literal must start with a string word which knows how to handle the following string at the run time.  Let us show two examples of the string literals:

\par 
\par : xxx  \tab ...   " A compiled string"  ...   ;
\par : yyy  \tab ...   ." An output string"  ...   ;
\par 
\par In xxx, "  is an immediate word wh
ich compiles the following string as a string literal preceded by a special word $"|.  When $"| is executed at the run time, it returns the address of this string on the data stack.  In yyy,  ." compiles a string literal preceded by another word ."|, whic
h prints the compiled string to the output device.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Both $"| and ."| use the word do$, which retrieve the address of a string stored as the second item on the return stack.  do$ is a bit difficult to understand, because the starting address of the following
 string is the second item on the return stack.  This address is pushed on the data stack so that the string can be accessed.  This address must be changed so that the address interpreter will return to the word right after the compiled string.  This addr
ess will allow the address interpreter to skip over the string literal and continue to execute the word list as intended.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ?KEY ( -- c T | F ) '?KEY @EXECUTE ;
\par : KEY ( -- c ) BEGIN ?KEY UNTIL ;     
\par : EMIT ( c -- ) 'EMIT @EXECUTE ;
\par 
\par : NUF? ( -- f ) ?KEY DUP IF 2DROP KEY 13 = THEN ;
\par 
\par :  PACE ( -- ) 11 EMIT ;
\par : SPACE ( -- ) BL EMIT ;
\par 
\par : CHARS ( +n c -- ) \\ ???ANS conflict
\par   SWAP 0 MAX FOR AFT DUP EMIT THEN NEXT DROP ;
\par 
\par : SPACES ( +n -- ) BL CHARS ;
\par 
\par : TYPE ( b u -- ) FOR AFT DUP C@ EMIT 1 + THEN NEXT DROP ;
\par 
\par : CR ( -- ) 13 EMIT 10 EMIT ;
\par 
\par : do$ ( -- a )
\par   R> R@ R> COUNT + ALIGNED >R SWAP >R ; 
\par 
\par : $"| ( -- a ) do$ ; 
\par 
\par : ."| ( -- ) do$ COUNT TYPE ; COMPILE-ONLY
\par 
\par :  .R ( n +n -- ) >R str      R> OVER - SPACES TYPE ;
\par : U.R ( u +n -- ) >R <# #S #> R> OVER - SPACES TYPE ;
\par 
\par : U. ( u -- ) <# #S #> SPACE TYPE ;
\par :  . ( n -- ) BASE @ 10 XOR IF U. EXIT THEN str SPACE TYPE ;
\par 
\par : ? ( a -- ) @ . ;
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Parsing 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Parsing is always thought of as a very advanced topic in computer sciences.  However, because Forth uses very simple syntax rules, parsing is easy.  Forth source code consists of words, which are ASCII strings separated by spaces and other white space cha
r
acters like tabs, carriage returns, and line feeds.  The text interpreter scans the source code, isolates words and interprets them in sequence.  After a word is parsed out of the input text stream, the text interpreter will 'interpret' it--execute it if 
it is a word, compile it if the text interpreter is in the compiling mode, and convert it to a number if the word is not a Forth word.
\par 
\par PARSE scans the source string in the terminal input buffer from where >IN points to till the end of the buffer, for a wor
d delimited by character c.  It returns the address and length of the word parsed out.  PARSE calls 'parse' to do the detailed works.  PARSE is used to implement many specialized parsing words to perform different source code handling functions.  These wo
rds, including (, \\, CHAR, WORD, and WORD are discussed in the next section.
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 '}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
parse'  ( b1 u1 c -- b2 u2 n )  is the elementary command to do text parsing.  From the source string starting at b1 and of u1 characters long, parse out the first word delimited
 by character c.  Return the address b2 and length u2 of the word just parsed out and the difference n between b1 and b2.  Leading delimiters are skipped over.  'parse' is used by PARSE.
\par 
\par .(  types the following string till the next ).  It is used to output text to the terminal.  (  ignores the following string till the next ).  It is used to place comments in source text.  \\
  ignores all characters till end of input buffer.  It is used to insert comment lines in text.
\par 
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx4680\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\insrsid10628273\charrsid9062223 CHAR  parses the next word but only r
eturn the first character in this word.  Get an ASCII character from the input stream.  WORD parses out the next word delimited by the ASCII character c.  Copy the word to the top of the code dictionary and return the address of this counted string.   WOR
D parses the next word from the input buffer and copy the counted string to the top of the name dictionary.  Return the address of this counted string.  
\par }\pard \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af5 \ltrch\fcs0 
\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : parse ( b u c -- b u delta ; <string> )
\par   tmp !  OVER >R  DUP \\ b u u
\par   IF 1 -  tmp @ BL =
\par     IF \\ b u' \\ 'skip'
\par       FOR BL OVER C@ - 0< NOT  WHILE 1 +
\par       NEXT ( b) R> DROP 0 DUP EXIT \\ all delim
\par         THEN  R>
\par     THEN OVER SWAP \\ b' b' u' \\ 'scan'
\par     FOR tmp @ OVER C@ -  tmp @ BL =
\par       IF 0< THEN WHILE 1 +
\par     NEXT DUP >R  ELSE R> DROP DUP 1 + >R
\par                  THEN OVER -  R>  R> - EXIT
\par   THEN ( b u) OVER R> - ;
\par 
\par : PARSE ( c -- b u ; <string> )
\par   >R  TIB >IN @ +  #TIB @ >IN @ -  R> parse >IN +! ;
\par 
\par : .( ( -- ) 41 PARSE TYPE ; IMMEDIATE
\par : ( ( -- )  41 PARSE 2DROP ; IMMEDIATE
\par : \\ ( -- ) #TIB @ >IN ! ; IMMEDIATE
\par 
\par : CHAR ( -- c ) BL PARSE DROP C@ ;
\par 
\par : TOKEN ( -- a ; <string> )
\par   BL PARSE 31 MIN NP @ OVER - CELL- PACK$ ;
\par 
\par : WORD ( c -- a ; <string> ) PARSE HERE PACK$ ;
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\b\caps\f39\fs20\insrsid10628273\charrsid9062223 
\par D}{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 ictionary Search
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par In eForth, headers of word definitions are l
inked into a name dictionary which is separated from the code dictionary.  A header contains three fields: a word field holding the code address of the word, a link field holding the name field address of the previous header and a name field holding the n
a
me as a counted string.  The name dictionary is a list linked through the link fields and the name fields. The basic searching function is performed by the word 'find'.  'find' follows the linked list of names to find a name which matches a text string, a
nd returns the address of the executable word and the name field address, if a match is found.
\par 
\par eForth allows multiple vocabularies in the name dictionary.  A dictionary can be divided into a number of independently linked sublists through some hashing mech
anism.  A sublist is called a vocabulary.  Although eForth itself contains only one vocabulary, it has the provision to build many vocabularies and allows many vocabularies to be searched in a prioritized order.  The CONTEXT array in the user area has 8 c
ells and allows up to 8 vocabularies to be searched in sequence.  A null entry in the CONTEXT array terminates the vocabulary search.
\par 
\par find ( a va -- ca na, a F)  A counted string at a is the name of a word to be looked up in the dictionary. The last name f
ield address of the vocabulary is stored in location va. If the string is found, both the word (code address) and the name field address are returned.  If the string is not the name a word, the string address and a false flag are returned.
\par 
\par To located a wo
rd, one could follow the linked list and compare the names of defined words to the string to be searched.  If the string matches the name of a word in the name dictionary, the word and the address of the name field are returned.  If the string is not a de
fined word, the search will lead to either a null link or a null name field.  In either case, the search will be terminated and a false flag returned.  The false flag thus indicates that the word searched is not in this vocabulary.
\par 
\par 'find' runs through the name dictionary very quickly because it first compares the length and the first character in the name field as a cell.  In most cases of mismatch, this comparison would fail and the next name can be reached through the link field. 
 
If the first two characters match, then SAME? is invoked to compare the rest of the name field, one cell at a time.  Since both the target text string and the name field are null filled to the cell boundary, the comparison can be performed quickly across 
the entire name field without worrying about the end conditions.
\par 
\par NAME?  ( a -- ca na, a F)   Search all the vocabularies in the CONTEXT array for a name at address a.  Return the word and a name address if a matched word is found.  Otherwise, return the st
ring address and a false flag.  The CONTEXT array can hold up to 8 vocabulary links.  However, a 0 which is not a valid vocabulary link in this array will terminate the searching.  Changing the vocabulary links in this array and the order of these links w
ill alter the searching order and hence the searching priority among the vocabularies.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : NAME> ( a -- xt ) CELL- CELL- @ ;
\par 
\par : SAME? ( a a u -- a a f \\ -0+ )
\par   FOR AFT OVER R@ CELLS + @
\par           OVER R@ CELLS + @ -  ?DUP
\par     IF R> DROP EXIT THEN THEN
\par   NEXT 0 ;
\par 
\par : find ( a va -- xt na | a F )
\par   SWAP              \\ va a
\par   DUP C@ 2 / tmp !  \\ va a  \\ get cell count
\par   DUP @ >R          \\ va a  \\ count byte & 1st char
\par   CELL+ SWAP        \\ a' va
\par   BEGIN @ DUP       \\ a' na na
\par     IF DUP @ [ =MASK ] LITERAL AND  R@ XOR \\ ignore lexicon bits
\par       IF CELL+ -1 ELSE CELL+ tmp @ SAME? THEN
\par     ELSE R> DROP EXIT
\par     THEN
\par   WHILE CELL- CELL- \\ a' la
\par   REPEAT R> DROP SWAP DROP CELL-  DUP NAME> SWAP ;
\par 
\par : NAME? ( a -- xt na | a F )
\par   CONTEXT  DUP 2@ XOR IF CELL- THEN >R \\ context<>also
\par   BEGIN R>  CELL+  DUP >R  @  ?DUP
\par   WHILE find  ?DUP
\par   UNTIL R> DROP EXIT THEN R> DROP  0 ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\b\caps\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Terminal 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The text interpreter interprets source text  stored in the terminal input buffer.  To process characters from the input device, we need three special words to deal with backspaces and carriage return from the input device:
\par 
\par kTAP  processes a character c received from terminal.  b1 is the starting address of the input buffer.  b2 is the end of the in
put buffer. b3 is the currently available address in the input buffer.  c is normally stored into b3, which is bumped by 1 and becomes b5.  In this case, b4 is the same as b2.  If c is a carriage-return, echo a space and make b4=b5=b3.  If c is a back-spa
ce, erase the last character and make b4=b2, b5=b3-1.  TAP  echoes c to output device, store c in b3, and bump b3.
\par 
\par ^H   processes the back-space character.  Erase the last character and decrement b3.  If b3=b1, do nothing because you cannot backup beyond the beginning of the input buffer.
\par 
\par QUERY is the word which accepts text input, up to 80 characters, from the input device and copies the text characters to the terminal input buffer.  It also prepares the terminal input buffer for parsing by setting #TIB t
o the character count and clearing >IN. 
\par 
\par EXPECT  accepts u characters to a memory buffer starting at b.  The input is terminated upon receiving a carriage-return.  The number of characters actually received is stored in SPAN.  EXPECT is called by QUERY to
 put characters into the terminal input buffer.  However, EXPECT is useful by itself because one can use it to place input text anywhere in the memory.  QUERY and EXPECT are the two words most useful in accepting text from the terminal.  
\par 
\par 'accept'  accepts u1 characters to b.  u2  returned is the actual count of characters received.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ^H ( b b b -- b b b ) \\ backspace
\par   >R OVER R> SWAP OVER XOR
\par   IF  8 'ECHO @EXECUTE
\par      32 'ECHO @EXECUTE \\ distructive
\par       8 'ECHO @EXECUTE \\ backspace
\par   THEN ;
\par 
\par : TAP ( bot eot cur c -- bot eot cur )
\par   DUP 'ECHO @EXECUTE OVER C! 1 + ;
\par 
\par : kTAP ( bot eot cur c -- bot eot cur )
\par   DUP 13 XOR
\par   IF 8 XOR IF BL TAP ELSE ^H THEN EXIT
\par   THEN DROP SWAP DROP DUP ;
\par 
\par : accept ( b u -- b u )
\par   OVER + OVER
\par   BEGIN 2DUP XOR
\par   WHILE  KEY  DUP BL -  95 U<
\par     IF TAP ELSE 'TAP @EXECUTE THEN
\par   REPEAT DROP  OVER - ;
\par 
\par : EXPECT ( b u -- ) 'EXPECT @EXECUTE SPAN ! DROP ;
\par 
\par : QUERY ( -- )
\par   TIB 80 'EXPECT @EXECUTE #TIB !  DROP 0 >IN ! ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s19\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx4500\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af39\afs20\alang1025 \ltrch\fcs0 
\f39\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\fs20\insrsid10628273\charrsid9062223 
\par Error Handling
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 This error handling mechanism was first d
eveloped by Mitch Bradley in his ForthMacs and then adopted by the ANS Forth Standard.  It is very simple yet very powerful in customizing system responses to many different error conditions.
\par 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 CATCH setups a local error frame and execute the word reference
d by the execution word ca. It returns a non-zero error code or a zero if no error occurred.  As the assigned word at ca is executing, any error condition will execute THROW, which pushes an error code on the data stack, restore the return stack to the st
ate before CATCH was executed, and execute the error handler stored in HANDLER.  Since the error handler frame is saved on the return stack, many layers of safety nets can be laid down nested. 
\par 
\par CATCH pushes SP and HANDLER on the return stack, saves RP in HANDLER, and then execute the word at ca.  If no error occurred,  HANDLER and SP are restored from the return stack and a 0 is pushed on the data stack.
\par 
\par THROW throws the system back to CATCH so that the error condition can be processed.  CATCH is backtracked by restoring the return stack from the pointer stored in HANDLER and popping the old handler and SP off the error frame on the return stack.
\par 
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : CATCH ( ca -- err#/0 )
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 \tab ( Execute word at ca and set up an error frame for it.)
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab SP@ >R  \tab \tab ( save current stack pointer on return stack )
\par \tab HANDLER @ >R  \tab ( save the handler pointer on return stack )
\par \tab RP@ HANDLER !\tab ( save the handler frame pointer in HANDLER )
\par \tab ( ca ) EXECUTE\tab ( execute the assigned word over this safety net )
\par \tab R> HANDLER !  \tab ( normal return from the executed word )
\par \tab \tab \tab \tab ( restore HANDLER from the return stack )
\par \tab R> DROP  \tab \tab ( discard the saved data stack pointer )
\par \tab 0 ;\tab \tab \tab ( push a no-error flag on data stack )
\par 
\par : THROW ( err# -- err# )
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 \tab ( Reset system to current local error frame an update error flag.)
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab HANDLER @ RP! \tab ( expose latest error handler frame on return stack )
\par \tab R> HANDLER !  \tab ( restore previously saved error handler frame )
\par \tab R> SWAP >R \tab \tab ( retrieve the data stack pointer saved )
\par \tab SP! \tab \tab \tab ( restore the data stack )
\par \tab DROP 
\par \tab R> ;\tab \tab \tab ( retrived err# )
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
NULL$ is the address of a string with a zero count.  This address is used by ABORT and abort" to terminate the interpreting of the current command line.  QUIT tests the address reported by CATCH.  If this address is NULL$, the term
ination is normal and no error message will be issued.  If CATCH reports a different address, QUIT will display the contents of the string at that address. 
\par 
\par }\pard\plain \ltrpar\s19\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx6840\tx7200\tx7920\tx8640\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af39\afs20\alang1025 \ltrch\fcs0 
\f39\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 ABORT" is used only within a definition to compile an inline packed string terminated by the " dou
ble quote character. At run-time, if the flag is false, execute the sequence of words following the string. Otherwise, the string is displayed on the current output device, and execution is then passed to an error handling routine.
\par 
\par You have to study the code in QUIT carefully with this section to get a better understanding of the CATCH-THROW error handling mechanism.
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : CATCH ( xt -- 0 | err# )
\par   SP@ >R  HANDLER @ >R  RP@ HANDLER !
\par   EXECUTE
\par   R> HANDLER !  R> DROP  0 ;
\par 
\par : THROW ( err# -- err# )
\par   HANDLER @ RP!  R> HANDLER !  R> SWAP >R SP! DROP R> ;
\par                         
\par CREATE NULL$ 0 , $," coyote"
\par 
\par : ABORT ( -- ) NULL$ THROW ;
\par 
\par : abort" ( f -- ) IF do$ THROW THEN do$ DROP ; 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par Let's look at how the CATCH-THROW pair is used.  In QUIT, there is this indefinite loop:
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 BEGIN QUERY [ ' EVAL ] LITERAL \tab \tab CATCH 
\par ?DUP UNTIL
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par QUERY get a line of text and CATCH causes EVAL to interpret the line. CATCH also sets up an error handling frame on the return stack and saves the return stack pointer
 in the user variable HANDLER.  The error handling frame contains the current data stack pointer and the current contents in HANDLER.  If no error occurred during EVAL, the error frame is popped off the return stack and a false flag is returned on the dat
a stack.  ?DUP UNTIL will loop back to QUERY and the interpretive process will continue.
\par 
\par While EVAL interprets the text, any word which decided that it detects an error condition and needs attention, it will execute THROW.  THROW restores the return stack 
from the pointer stored in HANDLER, making the error handling frame available.  THROW then restores HANDLER from the one saved in the error frame so that the error handling can be nested.  The data stack pointer is also restored from the error frame.  Now
 THROW passes the address of a error processing routine to the CATCH which built the error frame.
\par 
\par $INTERPRET, ?STACK and abort" pass string addresses to THROW.  The strings contains appropriate error messages to be displayed by the text interpreter.  In QU
IT, the words between UNTIL and AGAIN deal with the error conditions and then re-initialize the text interpreter.
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 \tab \tab 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 Here are some of the examples which generate error conditions:
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 : ABORT   NULL$ THROW ;\tab  
\par : abort"   IF do$ THROW THEN do$ DROP ;
\par : ?STACK   DEPTH 0< IF $" underflow" THROW THEN ;
\par : $INTERPRET   ... 'NUMBER @EXECUTE  IF EXIT THEN THROW ;
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 
\ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Text Interpreter }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par Text interpreter in Forth is like the operating system of a computer. It is the primary interface a user goes through to get th
e computer to do work.  Since Forth uses very simple syntax rules--words are separated by spaces, the text interpreter is also very simple.  It accepts a line of text from the terminal, parses out a word delimited by spaces, locates the word of this word 
i
n the dictionary and then executes it. The process is repeated until the source text is exhausted.  Then the text interpreter waits for another line of text and interprets it again.  This cycle repeats until the user is exhausted and turns off the compute
r.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par In eForth, the text interpreter is encoded in the word QUIT.  QUIT contains an infinite loop which repeats the QUERY EVAL phrase. QUERY accepts a line of text from the terminal and copies the text into the Terminal Input Buffer (TIB).  EVAL interprets t
he text one word at a time till the end of the text line.
\par 
\par One of the unique features in eForth is its error handling mechanism. While EVAL is interpreting a line of text, there could exist many error conditions: a word is not found in the dictionary and i
t is not a number, a compile-only word is accidentally executed interpretively, and the interpretive process may bee interrupted by the words ABORT or abort".  Wherever the error occurs, the text interpreter must be made aware of it so that it can recover
 gracefully from the error condition and continue on about the interpreting business.
\par 
\par $INTERPRET executes a word whose string address is on the stack.  If the string is not a word, convert it to a number.
\par 
\par [  activates the text interpreter by storing the execution address of $INTERPRET into the variable 'EVAL, which is executed in EVAL while the text interpreter is in the interpretive mode. 
\par 
\par .OK prints the familiar 'ok' prompt after executing to the end of a line.  'ok' is printed only when the text interpreter is in the interpretive mode.  While compiling, the prompt is suppressed.
\par 
\par ?STACK checks for stack underflow.  Abort if the stack depth is negative.
\par 
\par EVAL is the interpreter loop which parses words from the input stream and invokes whatever is in 'EVAL to handle that word, either execute it with $INTERPRET or compile it with $COMPILE.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : $INTERPRET ( a -- )
\par   NAME?  ?DUP
\par   IF @ $40 AND
\par     ABORT" compile ONLY" EXECUTE EXIT
\par   THEN 'NUMBER @EXECUTE IF EXIT THEN THROW ;
\par 
\par : [ ( -- ) doLIT $INTERPRET 'EVAL ! ; IMMEDIATE
\par 
\par : .OK ( -- ) doLIT $INTERPRET 'EVAL @ = IF ."  ok" THEN CR ;
\par 
\par : ?STACK ( -- ) DEPTH 0< ABORT" underflow" ;
\par 
\par : EVAL ( -- )
\par   BEGIN TOKEN DUP C@
\par   WHILE 'EVAL @EXECUTE ?STACK
\par   REPEAT DROP 'PROMPT @EXECUTE ;
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Shell 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Source code can be downloaded to eForth through the serial input device.  The only precaution we have to take is that during file downloading, characters are not echoed back to the host computer.  However, whenever an error occurred during downloa
ding, it is more useful to resume echoing so that error messages can be displayed on the terminal.  It is also convenient to send special pacing characters to the host to tell the host that a line of source code was received and processed correctly.  The 
following words configure the eForth I/O vectors to have the proper behavior in normal terminal interaction and also during file downloading:
\par 
\par FILE turns off character echoing.  After one line of text is processed correctly, a pacing character ASCII 11 is s
ent to the host.  If an error occurred, send an ESC (ASCII  26) character.  An error will also restore the I/O vectors into the terminal mode.  HAND resumes terminal interaction.  Turn on character echoing, and send normal prompt message after a line is p
rocessed correctly.  CONSOLE initializes the serial I/O device for terminal interaction.  ?KEY is vectored to ?RX and EMIT is vectored to TX!.
\par 
\par QUIT is the operating system, or a shell, of the eForth system.  It is an infinite loop eForth will never get out
.  It uses QUERY to accept a line of commands from the terminal and then let EVAL parse out the words and execute them.  After a line is processed, it displays 'ok' and wait for the next line of commands.  When an error occurred during execution, it displ
ays the command which caused the error with an error message.  After the error is reported, it re-initializes the system using PRESET and comes back to receive the next line of commands.
\par 
\par Because the behavior of EVAL can be changed by storing either $INTERPRET or $COMPILE into 'EVAL, QUIT exhibits the dual nature of a text interpreter and a compiler.
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : PRESET ( -- ) SP0 @ SP!  TIB #TIB CELL+ ! ;
\par 
\par : xio ( a a a -- ) \\ reset  'EXPECT 'TAP  'ECHO 'PROMPT
\par   doLIT accept  'EXPECT 2! 'ECHO 2! ; COMPILE-ONLY
\par 
\par : FILE ( -- )
\par   doLIT PACE  doLIT DROP  doLIT kTAP xio ;
\par 
\par : HAND ( -- )
\par   doLIT .OK   doLIT EMIT  [ kTAP  xio ;
\par 
\par CREATE I/O  ' ?RX , ' TX! , \\ defaults
\par 
\par : CONSOLE ( -- ) I/O 2@ '?KEY 2! HAND ;
\par 
\par : QUIT ( -- )
\par   RP0 @ RP!
\par   BEGIN [COMPILE] [
\par     BEGIN QUERY doLIT EVAL CATCH ?DUP
\par     UNTIL 'PROMPT @ SWAP CONSOLE  NULL$ OVER XOR
\par     IF CR #TIB 2@ TYPE
\par        CR >IN @ 94 CHARS
\par        CR COUNT TYPE ."  ? "
\par     THEN doLIT .OK XOR
\par     IF $1B EMIT THEN
\par     PRESET
\par   AGAIN ;
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\qc \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 eForth Compiler
\par }\pard \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
After wading through the text interpreter, the Forth compiler will be an easy piece of cake, because the compiler uses almost all the modules used by the text interpreter.  What the compile does, over and above the text interpreter, is to build various st
ructures required by the new words we want to add to the existing system.  Here is a list of these structures:
\par 
\par \tab Name headers
\par \tab Colon definitions
\par \tab Constants,
\par \tab Variables
\par \tab User variables
\par \tab Integer literals
\par \tab String literals
\par \tab Address literals
\par \tab Control structures
\par 
\par A special concept of immediate words is difficult to grasp at first.  It is required in the compiler because of the needs in building different data and control structures in a colon definition.  To understand the Forth compiler fully, you have to be able
 to differential and relate the actions during compile time and actions taken during executing time.  Once these concepts are clear, the whole Forth system will become transparent.
\par 
\par This set stage for enlightenment to strike.
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par \page Interpreter and Compiler}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par T
he Forth compiler is the twin brother of the Forth text interpreter. They share many common properties and use lots of common code.  In eForth, the implementation of the compiler clearly reflects this special duality.  Two interesting words [ and ] causes
 the text interpreter to switch back and forth between the compiler mode and interpreter mode of operation.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Since 'EVAL @EXECUTE is used in EVAL to process a word parsed out of a line of text, the contents in 'EVAL determines the behavior of the text inter
preter.  If $INTERPRET is stored in 'EVAL, as [ does, the words are executed or interpreted.  If we invoked ] to store $COMPILE into 'EVAL, the word will not be executed, but added to the top of the code dictionary.  This is exactly the behavior desired b
y the colon definition compiler in building a list of words in the code field of a new colon definition on the top of the code dictionary.
\par 
\par $COMPILE normally adds a word to the code dictionary.  However, there are two exceptions it must handle.  If the word
 parsed out of the input stream does not exist in the dictionary, the string will be converted to a number.  If the string can be converted to an integer, the integer is then compiled into the code dictionary as an integer  literal. The integer number is 
c
ompiled into the code dictionary following the word doLIT.  The other exception is that a word found in the dictionary could be an immediate word, which must be executed immediately, not compiled to the code dictionary.  Immediate words are used to compil
e special structures in colon definitions.
\par 
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : [ ( -- ) 
\par \tab [ ' $INTERPRET ] LITERAL 
\par \tab 'EVAL ! \tab \tab \tab \tab ( vector EVAL to $INTERPRET )
\par \tab ; IMMEDIATE\tab \tab \tab \tab ( enter into text interpreter mode )
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ] ( -- ) 
\par \tab [ ' $COMPILE ] LITERAL 
\par \tab 'EVAL ! \tab \tab \tab \tab ( vector EVAL to $COMPILE )
\par \tab ; \tab \tab \tab 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\keep\keepn\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Primitive Compiler Words
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Here is a group of words which support the compiler to build new words in the code dictionary.
\par 
\par '  (tick) searches the next word in the input stream for a word in the dictionary.  It returns the execution address of the word if successful.  Otherwise, it displays an error message.
\par 
\par ALLOT allocates  n bytes of memory on the top of the code dictionary.  Once allocated, the compiler will not touch the memory locations.
\par 
\par ,  (comma) adds the execution address of a word on the top of the data stack to the code dictionary, and thus compiles a word to the growing word list of the word currently under construction.
\par 
\par COMPILE is used in a colon definition.  It causes the next word after COMPILE to be added to the top of the code dictionary.  It therefore forces the compilation of a word at the run time.  
\par 
\par [COMPILE] acts similarly, except that it compiles the next word immediately.  It causes the following word to be compiled, even if the following word is an immediate word which would otherwise be executed.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par LITERAL compiles an integer literal to the current colon definition under construction.  The integer literal is taken from the data stack, and is preceded by the word doLIT.  When this colon definition is executed, doLIT will extract the integer from the 
word list and push it back on the data stack.  LITERAL compiles an address literal if the compiled integer happens to be an execution address of a word.  The address will be pushed on the data stack at the run time by doLIT.
\par 
\par $," compiles a string literal. 
 The string is taken from the input stream and is terminated by the double quote character.  $," only copies the counted string to the code dictionary.  A word which makes use of the counted string at the run time must be compiled before the string.  It i
s used by ." and $".
\par 
\par RECURSE is an interesting word which allows eForth to compile recursive definitions.  In a recursive definition, the execution address of the word under construction is compiled into its own word list.  This is not allowed normally bec
ause the name field of the current word under construction is not yet linked to the current vocabulary and it cannot be referenced inside its own colon definition.  RECURSE stores the address of the name field of the current word into CURRENT, thus enable
 it to be referenced inside its own definition.  Recursive words are not used in everyday programming.  RECURSE is defined here in eForth merely as a teaser to wet your appetite.  It is not used in eForth.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ' ( -- xt ) TOKEN NAME? IF EXIT THEN THROW ;
\par 
\par : ALLOT ( n -- ) CP +! ;
\par 
\par : , ( w -- ) HERE DUP CELL+ CP ! ! ; \\ ???ALIGNED
\par 
\par : [COMPILE] ( -- ; <string> ) ' , ; IMMEDIATE
\par 
\par : COMPILE ( -- ) R> DUP @ , CELL+ >R ;
\par 
\par : LITERAL ( w -- ) COMPILE doLIT , ; IMMEDIATE
\par 
\par : $," ( -- ) 34 WORD COUNT ALIGNED CP ! ;
\par 
\par : RECURSE ( -- ) LAST @ NAME> , ; IMMEDIATE
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Structures}{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par A set of immediate words are defined in eForth to help building control structures in colon definitions.  The control structures used in eForth are the following:
\par 
\par Conditional branch \tab IF ... THEN 
\par \tab \tab \tab IF ... ELSE ... THEN
\par Finite loop\tab      \tab FOR ... NEXT
\par \tab \tab \tab FOR ... AFT ... THEN... \tab \tab \tab NEXT
\par Infinite loop\tab    \tab BEGIN ... AGAIN
\par Indefinite loop\tab BEGIN ... UNTIL
\par \tab \tab        \tab BEGIN ... WHILE ... \tab \tab \tab REPEAT
\par 
\par This set of words is more powerful than the ones in figForth model because they permit multiple exits from a loop.  Many examples are provide in the source code of eForth like NUMBER?, parse, find and >NAME.
\par 
\par A control structure contains one or more address literals, which causes execution to branch out of the normal sequence.  The control structure words are immediate words which compile the address literals and resolve the branch address.
\par 
\par One should note that BEGIN  and THEN do not compile any code.  They executes during compilation to set up and to resolve the bra
nch addresses in the address literals.  IF, ELSE, WHILE, UNTIL, and AGAIN do compile address literals with branching words.  Here are many excellent examples on the usage of COMPILE and [COMPILE], and they are worthy of careful study.
\par 
\par Character strings ar
e very important devices for the program to communicate with the user.  Error messages, appropriate warnings and suggestions must be displayed to help the use to use the system in a friendly way.  Character strings are compiled in the colon definitions as
 
string literals.  Each string literal consists of a string word which will use the compiled string to do things, and a counted string.  The first byte in a counted string is the length of the string.  Thus a string may have 0 to 255 characters in it.  A s
tring is always null-filled to the cell boundary.
\par 
\par ABORT" compiles an error message.  This error message is display when the top item on the stack is non-zero.  The rest of the words in the definition is skipped and eForth re-enters the interpreter loop.  T
his is the universal response to an error condition.  More sophisticated programmer can use the CATCH-THROW mechanism to customize the responses to special error conditions.
\par 
\par ." compiles a character string which will be printed which the word containing it is executed in the runtime.  This is the best way to present messages to the user.  
\par 
\par $" compiles a character string.  When it is executed, only the address of the string is left on the data stack.  The programmer will use this address to access the string and individual characters in the string as a string array.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : <MARK ( -- a ) HERE ;
\par : <RESOLVE ( a -- ) , ;
\par : >MARK ( -- A ) HERE 0 , ;
\par : >RESOLVE ( A -- ) <MARK SWAP ! ;
\par 
\par : FOR ( -- a ) COMPILE >R <MARK ; IMMEDIATE
\par : BEGIN ( -- a ) <MARK ; IMMEDIATE
\par : NEXT ( a -- ) COMPILE next <RESOLVE ; IMMEDIATE
\par : UNTIL ( a -- ) COMPILE ?branch <RESOLVE ; IMMEDIATE
\par : AGAIN ( a -- ) COMPILE  branch <RESOLVE ; IMMEDIATE
\par : IF ( -- A )   COMPILE ?branch >MARK ; IMMEDIATE
\par : AHEAD ( -- A ) COMPILE branch >MARK ; IMMEDIATE
\par : REPEAT ( A a -- ) [COMPILE] AGAIN >RESOLVE ; IMMEDIATE
\par : THEN ( A -- ) >RESOLVE ; IMMEDIATE
\par : AFT ( a -- a A ) DROP [COMPILE] AHEAD [COMPILE] BEGIN SWAP ; IMMEDIATE
\par : ELSE ( A -- A )  [COMPILE] AHEAD SWAP [COMPILE] THEN ; IMMEDIATE
\par : WHEN ( a A -- a A a ) [COMPILE] IF OVER ; IMMEDIATE
\par : WHILE ( a -- A a )    [COMPILE] IF SWAP ; IMMEDIATE
\par 
\par : ABORT" ( -- ; <string> ) COMPILE abort" $," ; IMMEDIATE
\par 
\par : $" ( -- ; <string> ) COMPILE $"| $," ; IMMEDIATE
\par : ." ( -- ; <string> ) COMPILE ."| $," ; IMMEDIATE
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Compiler 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
We had discussed how the compiler compiles words and structures into the code field of a colon definition in the code dictionary.  To build a new definition, we have to build its header in the name dictionary also.  A header has a word pointer field
, a link field, and a name field.  Here are the tools to build these fields.
\par 
\par ?UNIQUE is used to display a warning message to show that the name of a new word is a duplicate to a word already existing in the dictionary.  eForth does not mind your reusing t
he same name for different words.  However, giving many words the same name is a potential cause of problems in maintaining software projects.  It is to be avoided if possible and ?UNIQUE reminds you of it.
\par 
\par $,n builds a new entry in the name dictionary us
ing the name already moved to the bottom of the name dictionary by PACK$.  It pads the word field with the address of the top of code dictionary where the new code is to be built, and link the link field to the current vocabulary.  A new word can now be b
uilt in the code dictionary.
\par 
\par $COMPILE builds the body of a new colon definition.  A complete colon definition also requires a header in the name dictionary, and its code field must start with a CALL doLIST instruction. These extra works are perf
ormed by :.  Colon definitions are the most prevailing type of words in eForth.  In addition, eForth has a few other defining words which create other types of new definitions in the dictionary.
\par 
\par OVERT links a new definition to the current vocabulary and thus makes it available for dictionary searches.
\par 
\par ; terminates a colon definition.  It compiles an EXIT to the end of the word list, links this new word to the current vocabulary, and then reactivates the interpreter.
\par 
\par ]  turns the interpreter to a compiler.
\par 
\par :   creates a new header and start a new colon word.  It takes the following string in the input stream to be the name of the new colon definition, by building a new header with this name in the name dictionary.  It then compiles a CALL doLIST instructi
on at the beginning of the code field in the code dictionary.  Now, the code dictionary is ready to accept a word list.  ] is now invoked to turn the text interpreter into a compiler, which will compile the following words in the input stream to a word li
st in the code dictionary.  The new colon definition is terminated by ;, which compiles an EXIT to terminate the word list, and executes [ to turn the compiler back to text interpreter.
\par 
\par call,  compiles the CALL doLIST instruction as the first thing in the code field of a colon definition.
\par 
\par IMMEDIATE sets the immediate lexicon bit in the name field of the new definition just compiled.  When the compiler encounters a word with this bit set, it will not compile this words into the word list under construction,
 but execute the word immediately.  This bit allows structure words to build special structures in the colon definitions, and to process special conditions when the compiler is running.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : ?UNIQUE ( a -- a )
\par   DUP NAME? IF ."  reDef " OVER COUNT TYPE THEN DROP ;
\par 
\par : $,n ( a -- )
\par   DUP C@
\par   IF ?UNIQUE
\par     ( na) DUP LAST ! \\ for OVERT
\par     ( na) HERE ALIGNED SWAP
\par     ( cp na) CELL-
\par     ( cp la) CURRENT @ @
\par     ( cp la na') OVER !
\par     ( cp la) CELL- DUP NP ! ( ptr) ! EXIT
\par   THEN $" name" THROW ;
\par 
\par .( FORTH Compiler )
\par 
\par : $COMPILE ( a -- )
\par   NAME? ?DUP
\par   IF @ $80 AND
\par     IF EXECUTE ELSE , THEN EXIT
\par   THEN 'NUMBER @EXECUTE
\par   IF [COMPILE] LITERAL EXIT
\par   THEN THROW ;
\par 
\par : OVERT ( -- ) LAST @ CURRENT @  ! ;
\par 
\par : ; ( -- )
\par   COMPILE EXIT [COMPILE] [ OVERT ; IMMEDIATE
\par 
\par : ] ( -- ) doLIT $COMPILE 'EVAL ! ;
\par 
\par : call, ( xt -- ) \\ DTC 8086 relative call
\par   $E890 , HERE CELL+ - , ;
\par 
\par : : ( -- ; <string> ) TOKEN $,n doLIT doLIST  call, ] ;
\par 
\par : IMMEDIATE ( -- ) $80 LAST @ @ OR LAST @ ! ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {
\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Defining Words
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Defining words are molds which can be used to define many words which share the same run time execution behavior.  In eForth, we have : , USER, CREATE, and VARIABLE.
\par 
\par USER creates a new user variable.  The user variable contains an user area offset, which 
is added to the beginning address of the user area and to return the address of the user variable in the user area.  CREATE creates a new array without allocating memory.  Memory is allocated using ALLOT.  VARIABLE creates a new variable, initialized to 0
.
\par 
\par eForth does not use CONSTANT, because a integer literal is more economical than a constant.  One can always use a variable for a constant.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : USER ( n -- ; <string> )
\par   TOKEN $,n OVERT
\par   doLIT doLIST COMPILE doUSER , ;
\par 
\par : CREATE ( -- ; <string> )
\par   TOKEN $,n OVERT
\par   doLIT doLIST COMPILE doVAR ;
\par 
\par : VARIABLE ( -- ; <string> ) CREATE 0 , ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 
\f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0\pararsid9062223 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Utilities
\par }\pard \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 eForth is a very small system and only a very small set of tools are provided in the system.  Nevertheless, this set of tools is powerful enough to help the u
ser debug new words he adds to the system.  They are also very interesting programming examples on how to use the words in eForth to build applications.  
\par 
\par Generally, the tools presents the information stored in different parts of the memory in the appropr
iate format to let the use inspect the results as he executes words in the eForth system and words he defined himself.  The tools include memory dump, stack dump, dictionary dump, and a colon definition decompiler.
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par Memory Dump
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par DUMP dumps u bytes starting at address b to the terminal.  It dumps 16 bytes to a line.  A line begins with the address of the first byte, followed by 16 bytes shown in hex, 3 columns per bytes.  At the end of a line are the 16 bytes shown in characters. 
 The character display is generated by _TYPE, which substitutes non-printable characters by underscores.  Typing a key on the keyboard halts the display.  Another CR terminates the display.  Any other key resumes the display.
\par 
\par dm+  displays u bytes from b1 in one line.  It leave the address b1+u on the stack for the next dm+ command to use.
\par 
\par _TYPE  is similar to TYPE.  It displays u characters starting from b.  Non-printable characters are replaced by underscores.
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : _TYPE ( b u -- )
\par   FOR AFT DUP C@ >CHAR EMIT 1 + THEN NEXT DROP ;
\par 
\par : dm+ ( b u -- b )
\par   OVER 4 U.R SPACE FOR A}{\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid9062223 FT DUP C@ 3 U.R 1 + THEN NEXT ;}{\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273 
\par }{\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid9062223 
\par 
\par 
\par }{\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid9062223\charrsid9062223 
\par }{\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : DUMP ( b u -- )
\par   BASE @ >R HEX  16 /
\par   FOR CR 16 2DUP dm+ ROT ROT 2 SPACES _TYPE NUF? NOT WHILE
\par   NEXT ELSE R> DROP THEN DROP  R> BASE ! ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 
\f5\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\f5\fs20\insrsid10628273\charrsid9062223 
\par Stack Tools
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par Data stack is the working place of the Forth computer.  It is where words receive their parameters and also where they left their results.  In debugging a newly defined word which uses stack items and which leaves items on the stack, the best was to 
check its function is to inspect the data stack.  The number output words may be used for this purpose, but they are destructive.  You print out the number from the stack and it is gone.  To inspect the data stack non-destructively, a special utility word
 .S is provided in most Forth systems.  It is also implemented in eForth.
\par 
\par .S  dumps the contents of the data stack on the screen in the free format.  The bottom of the stack is aligned to the left margin.  The top item is shown towards the left and follo
wed by the characters '<sp'.  .S does not change the data stack so it can be used to inspect the data stack non-destructively at any time.
\par 
\par One important discipline in learning Forth is to learn how to use the data stack effectively.  All words must consum
e their input parameters on the stack and leave only their intended results on the stack.  Sloppy usage of the data stack is often the cause of bugs which are very difficult to detect later as unexpected items left on the stack could result in unpredictab
le behavior.  .S should be used liberally during Forth programming and debugging to ensure that the correct data are left on the data stack.
\par 
\par .S is useful in checking the stack interactively during the programming and debugging.  It is not appropriate for c
hecking the data stack at the run time.  For run time stack checking, eForth provides !CSP and ?CSP.  They are not used in the eForth system itself, but are very useful for the user in developing serious applications.
\par 
\par To do run time stack checking, at som
e point the program should execute !CSP to mark the depth of the data stack at that point.  Later, the program would execute ?CSP to see if the stack depth was changed.  Normally, the stack depth should be the same at these two points.  If the stack depth
 is changed, ?CSP would abort the execution.
\par 
\par One application of stack checking is to ensure compiler security.  Normally, compiling a colon definition does not change the depth of the data stack, if all the structure building immediate words in a colon def
inition are properly paired.  If they are not paired, like IF without a THEN, FOR without a NEXT, BEGIN without an AGAIN or REPEAT, etc., the data stack will not be balanced and ?CSP is very useful in catching these compilation errors. This stack check is
 a very simple but powerful tool to check the compiler.  !CSP and CSP are the words to monitor the stack depth.
\par 
\par !CSP  stores the current data stack pointer into tan user variable CSP.  The stack pointer saved will be used by ?CSP for error checking.
\par 
\par ?CSP compares the current stack pointer with that saved in CSP.  If they are different, abort and display the error message 'stack depth'.
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : .S ( -- ) CR DEPTH FOR AFT R@ PICK . THEN NEXT ."  <sp" ;
\par : .BASE ( -- ) BASE @ DECIMAL DUP . BASE  ! ;
\par : .FREE ( -- ) CP 2@ - U. ;
\par 
\par : !CSP ( -- ) SP@ CSP ! ;
\par : ?CSP ( -- ) SP@ CSP @ XOR ABORT" stack depth" ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par \page Dictionary Dump
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par The Forth dictionary contains all the words defined in the system, ready for execution and compilation.  WORDS allows you to examine the dictionar
y and to look for the correct names of words in case you are not sure of their spellings.  WORDS follows the vocabulary thread in the user variable CONTEXT and displays the names of each entry in the name dictionary.  The vocabulary thread can be traced e
asily because the link field in the header of a word points to the name field of the previous word.  The link field of the next word is one cell below its name field.  
\par 
\par WORDS  displays all the names in the context vocabulary.  The order of words is reversed from the compiled order.  The last defined words is shown first.
\par 
\par .ID displays the name of a word, given the word's name field address.  It also replaces non-printable characters in a name by under-scores.
\par 
\par Since the 
name fields are linked into a list in the name dictionary, it is fairly easy to locate a word by searching its name in the name dictionary.  However, finding the name of a word from the execution address of the word is more difficult, because the executio
n addresses of words are not organized in any systematic way.
\par 
\par It is necessary to find the name of a word from its execution address, if we wanted to decompile the contents of a word list in the code dictionary.  This reversed search is accomplished by the word >NAME.
\par 
\par >NAME  finds the name field address of a word from the execution address of the word.  If the word does not exist in the CURRENT vocabulary, it returns a false flag.  It is the mirror image of the word NAME>, which returns the execution addres
s of a word from its name address.  Since the execution address of a word is stored in the word field, two cells below the name, NAME> is trivial.  >NAME is more complicated because the entire name dictionary must be searched to locate the word.   >NAME o
nly  searches the CURRENT vocabulary.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx0\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Bill Muench and I spent much of our spare time in July, 1991 to build and polish the eForth Model and the first implementation on 8086/MS-DOS.  One evening he called me and told me about this smallest and greatest Fort
h decompiler, only three lines of source code.  I was very skeptical because I knew how to build a Forth decompiler.  If a Forth colon definition contains only a simple list of execution addresses, it is a trivial task to decompile it.  However, there are
 many different data and control structures in a colon definition.  To deal with all these structures, it is logically impossible to have a three line decompiler. 
\par 
\par I told Bill that I had to see it to believe.  The next time we met, he read the source code in assembly and I entered it into the eForth model.  The decompiler had 24 words and worked the first time after we reassemble the source code.  
\par 
\par SEE searches the dictionary for the next word in the input stream and returns its code field address.  Then i
t scans the list of execution addresses (words) in the colon definition.  If the word fetched out of the list matches the execution address of a word in the name dictionary, the name will be displayed by the command '.ID'.  If the word does not match any 
e
xecution address in the name dictionary,  it must be part of a structure and it is displayed by 'U.'.  This way, the decompiler ignores all the data structures and control structures in the colon definition, and only displays valid words in the word list.
  
\par 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : >NAME ( xt -- na | F )
\par   CURRENT
\par   BEGIN CELL+ @ ?DUP WHILE 2DUP
\par     BEGIN @ DUP WHILE 2DUP NAME> XOR
\par     WHILE CELL-
\par     REPEAT      THEN SWAP DROP ?DUP
\par   UNTIL SWAP DROP SWAP DROP EXIT THEN DROP 0 ;
\par 
\par : .ID ( a -- )
\par   ?DUP IF COUNT $01F AND _TYPE EXIT THEN ." \{noName\}" ;
\par 
\par : SEE ( -- ; <string> )
\par   ' CR CELL+
\par   BEGIN CELL+ DUP @ DUP IF >NAME THEN ?DUP
\par     IF SPACE .ID ELSE DUP @ U. THEN NUF?
\par   UNTIL DROP ;
\par 
\par : WORDS ( -- )
\par   CR  CONTEXT @
\par   BEGIN @ ?DUP
\par   WHILE DUP SPACE .ID CELL-  NUF?
\par   UNTIL DROP THEN ;
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 
\par Startup
\par 
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
Since we expect eForth to evolve as experience is accumulated with usage, and as it has to track the ANS Forth Standard under development, version control becomes an important issue.  To assure compatibility at different stag
es of development, the user can always inquire the version number of the eForth he is running.  With the version number, corrective actions can be taken to put an overlay on the system to force it to be compatible with another eForth of a different versio
n.
\par 
\par VER returns the version number of this eForth system.  The version number contains two bytes: the most significant byte is the major revision number, and the least significant byte is the minor release number.
\par 
\par 'hi' is he default start-up routine in eForth.  It initializes the serial I/O device and then displays a sign-on message.  This is where the user can customized his application.  From here one can initialize the system to start his customized application.

\par 
\par Because all the system variable in eForth
 are implemented as user variables and the name dictionary is separated from the code dictionary, eForth dictionary is eminently ROMmable and most suitable for embedded applications.  To be useful as a generic model for many different processors and appli
c
ations, a flexible mechanism is designed to help booting eForth up in different environments. Before falling into the QUIT loop, the COLD routine executes a boot routine whose code address is stored in 'BOOT.  This code address can be vectored to an appli
cation routine which defines the proper behavior of the system.
\par 
\par }\pard\plain \ltrpar\s19\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af39\afs20\alang1025 \ltrch\fcs0 
\f39\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 
After the computer is turned on, it executes some native machine code to set up the CPU hardware so that it emulates a virtual Forth computer.  Then it jumps to COLD to initialize the eForth s
ystem.  It finally jumps to QUIT which is the operating system in eForth.  COLD and QUIT are the topmost layers of an eForth system.
\par }\pard\plain \ltrpar\s18\qj \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af39 \ltrch\fcs0 
\f39\fs20\insrsid10628273\charrsid9062223 'BOOT  is an variable vectored to 'hi'.
\par 
\par COLD is a high level word executed upon power-up.  Its most important function is to initialize the user area and execute the boot-up routine vectored through 'BOOT, and then falls into the text interpreter loop QUIT.
\par }\pard\plain \ltrpar\s18\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx9360\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 
\par }\pard\plain \ltrpar\s20\ql \li0\ri-1440\widctlpar\tx720\tx1440\tx2160\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-1440\lin0\itap0 \rtlch\fcs1 \af5\afs20\alang1025 \ltrch\fcs0 
\f5\fs20\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af5 \ltrch\fcs0 \insrsid10628273\charrsid9062223 : VER ( -- u ) $101 ;
\par 
\par : hi ( -- )
\par   !IO BASE @ HEX \\ initialize IO device & sign on
\par   CR ." eFORTH V" VER <# # # 46 HOLD # #> TYPE
\par   CR ;
\par 
\par : EMPTY ( -- )
\par   FORTH CONTEXT @ DUP CURRENT 2!  6 CP 3 MOVE OVERT ;
\par 
\par CREATE 'BOOT  ' hi , \\ application vector
\par 
\par : COLD ( -- )
\par   BEGIN
\par     U0 UP 74 CMOVE 
\par     PRESET  'BOOT @EXECUTE
\par     FORTH CONTEXT @ DUP CURRENT 2! OVERT
\par     QUIT
\par   AGAIN ;
\par 
\par }\pard\plain \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 \rtlch\fcs1 \af0\afs20\alang1025 \ltrch\fcs0 \f8\fs24\lang1024\langfe1024\cgrid\noproof\langnp2057\langfenp2057 {\rtlch\fcs1 \af0 \ltrch\fcs0 
\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 ColdBoot from DOS
\par }{\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par DOS starts executing the object code at 100H. The eForth Model is configured for a DOS machine.  It can be modified to jump to any memory locati
on from where the CPU boots up.  What we have to do here is to set up the 8086 CPU so that it will emulate the virtual Forth computer as we discussed before.  All the pertinent registers have to be initialized properly.  Since eForth is very small and fit
s
 comfortably in a single 64 Kbyte code segment, we will use only one segment for code, data, as well as the two stacks.  Therefore, both the DS and SS segment registers are initialized to be the same as the CS register.  Then, the data stack pointer SP an
d the return stack pointer RP (BP in 8086) are initialized.  To prevent the eForth from being forced back into DOS accidentally, the Control-C interrupt is made benign by vectoring it to a simple IRET instruction.
\par 
\par Now we are ready to start the Forth comput
er.  Simply jumping to COLD will do it.  COLD is coded as a colon word, containing a list of words.  This word list does more initialization in high level, including initializing the user area, and setting up the terminal input buffer.  At the end, COLD e
xecutes QUIT, the text interpreter, which contains an infinite loop to receive commands from a user and executes them repeatedly.
\par 
\par The user area contains vital information for Forth to perform its functions.  It contains important pointers specifying memory areas for various activities, such as the data stack, the return stack, the terminal input buffer, where the code dictionary and
 the name dictionary end, and the execution addresses of many vectored words like KEY, EMIT, ECHO, EXPECT,  NUMBER, etc.
\par 
\par The user area must be located in the RAM memory, because the information contained in it are continuously updated when eForth is runnin
g.  The default values are stored in the code segment starting at UZERO and covering an area of 74 bytes.  This area is copied to the user area in RAM before starting the eForth computer.  The sequence of data in UZERO must match exactly the sequence of u
ser variables.
\par 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 ;; Main entry points and COLD start data

\par MAIN\tab SEGMENT
\par ASSUME  CS:MAIN,DS:MAIN,ES:MAIN,SS:MAIN
\par ORG\tab COLDD\tab \tab \tab ;beginning of cold boot
\par ORIG:\tab MOV\tab AX,CS
\par \tab MOV\tab DS,AX\tab \tab ;DS is same as CS
\par \tab CLI\tab \tab \tab ;disable interrupts, old 808x CPU bug
\par \tab MOV\tab SS,AX\tab \tab ;SS is same as CS
\par \tab MOV\tab SP,SPP\tab ;initialize SP
\par \tab STI\tab \tab \tab ;enable interrupts
\par \tab MOV\tab BP,RPP\tab ;initialize RP
\par \tab MOV\tab AL,023H\tab ;interrupt 23H
\par \tab MOV\tab DX,OFFSET CTRLC
\par \tab MOV\tab AH,025H\tab ;MS-DOS set interrupt vector
\par \tab INT\tab 021H
\par \tab CLD\tab \tab \tab ;direction flag, increment
\par \tab JMP\tab COLD\tab \tab ;to high level cold start
\par CTRLC:IRET\tab \tab \tab ;control C interrupt routine
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\tx720\tx1440\tx2160\tx4320\tx5040\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \f5\fs20\insrsid10628273\charrsid9062223 
; COLD start moves the following to USER variables.
\par ; MUST BE IN SAME ORDER AS USER VARIABLES.
\par $ALIGN\tab \tab \tab ;align to cell boundary
\par UZERO:\tab DW\tab 4 DUP (0)\tab ;reserved
\par \tab DW\tab SPP\tab \tab ;SP0
\par \tab DW\tab RPP\tab \tab ;RP0
\par \tab DW\tab QRX\tab \tab ;'?KEY
\par \tab DW\tab TXSTO\tab \tab ;'EMIT
\par \tab DW\tab ACCEP\tab \tab ;'EXPECT
\par \tab DW\tab KTAP\tab \tab ;'TAP
\par \tab DW\tab TXSTO\tab \tab ;'ECHO
\par \tab DW\tab DOTOK\tab \tab ;'PROMPT
\par \tab DW\tab BASEE\tab \tab ;BASE
\par \tab DW\tab 0\tab \tab ;tmp
\par \tab DW\tab 0\tab \tab ;SPAN
\par \tab DW\tab 0\tab \tab ;>IN
\par \tab DW\tab 0\tab \tab ;#TIB
\par \tab DW\tab TIBB\tab \tab ;TIB
\par \tab DW\tab 0\tab \tab ;CSP
\par \tab DW\tab INTER\tab \tab ;'EVAL
\par \tab DW\tab NUMBQ\tab \tab ;'NUMBER
\par \tab DW\tab 0\tab \tab ;HLD
\par \tab DW\tab 0\tab \tab ;HANDLER
\par \tab DW\tab 0\tab \tab ;CONTEXT pointer
\par \tab DW\tab VOCSS DUP (0)\tab ;vocabulary stack
\par \tab DW\tab 0\tab \tab ;CURRENT pointer
\par \tab DW\tab 0\tab \tab ;vocabulary link pointer
\par \tab DW\tab CTOP\tab \tab ;CP
\par \tab DW\tab NTOP\tab \tab ;NP
\par \tab DW\tab LASTN\tab \tab ;LAST
\par ULAST:
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par }\pard \ltrpar\qc \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \b\f39\fs20\insrsid10628273\charrsid9062223 Some Final Thoughts
\par }\pard \ltrpar\ql \li0\ri-720\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin-720\lin0\itap0 {\rtlch\fcs1 \af39 \ltrch\fcs0 \f39\fs20\insrsid10628273\charrsid9062223 
\par 
\par 
\par Congratulations if you reach this point the first time.  As you can see, we have traversed a complete Forth system from the beginning to the end, and it is not as difficult as you might have thought before you began.  But, think again what we have accompl
ished.  It is a complete operating system with an integrated interpreter and an integrated compiler all together.  If you look in the memory, the whole system is less than 7 Kbytes.  What else can you do with 7 Kbytes these days?
\par 
\par Forth is like Zen.  It is simple, it is accessible, and it can be understood in its entirety without devoting your whole life to it.
\par 
\par Is this the end?  Not really.  There are many topics important in Forth but we had chose to ignore in this simple model.  They include multitasking,
 virtual memory, interrupt control, programming style, source code management, and yes, metacompilation.  However, these topics can be considered advanced applications of Forth.  Once the fundamental principles in Forth are understood, these topics can be
 subject for further investigations at your leisure.
\par 
\par Forth is not an end to itself.  It is only a tool, as useful as the user intends it to be.  The most important thing is how the user can use it to solve his problems and build useful applications.  What 
eForth gives you is the understanding of this tool.  It is up to you to make use of it.
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \fs20\insrsid10628273\charrsid9062223 
\par 
\par }{\*\themedata 504b030414000600080000002100e9de0fbfff0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb4ec3301045f748fc83e52d4a
9cb2400825e982c78ec7a27cc0c8992416c9d8b2a755fbf74cd25442a820166c2cd933f79e3be372bd1f07b5c3989ca74aaff2422b24eb1b475da5df374fd9ad
5689811a183c61a50f98f4babebc2837878049899a52a57be670674cb23d8e90721f90a4d2fa3802cb35762680fd800ecd7551dc18eb899138e3c943d7e503b6
b01d583deee5f99824e290b4ba3f364eac4a430883b3c092d4eca8f946c916422ecab927f52ea42b89a1cd59c254f919b0e85e6535d135a8de20f20b8c12c3b0
0c895fcf6720192de6bf3b9e89ecdbd6596cbcdd8eb28e7c365ecc4ec1ff1460f53fe813d3cc7f5b7f020000ffff0300504b030414000600080000002100a5d6
a7e7c0000000360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4f
c7060abb0884a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b6309512
0f88d94fbc52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462
a1a82fe353bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f746865
6d652f7468656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b
4b0d592c9c070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b
4757e8d3f729e245eb2b260a0238fd010000ffff0300504b030414000600080000002100aa5225dfc60600008b1a0000160000007468656d652f7468656d652f
7468656d65312e786d6cec595d8bdb46147d2ff43f08bd3bfe92fcb1c41b6cd9ceb6d94d42eca4e4716c8fadc98e344633de8d0981923c160aa569e943037deb
43691b48a02fe9afd936a54d217fa17746b63c638fbb9b2585a5640d8b343af7ce997bafce1d4997afdc8fa87384134e58dc708b970aae83e3211b9178d2706f
f7bbb99aeb7081e211a22cc60d778eb97b65f7c30f2ea31d11e2083b601ff31dd4704321a63bf93c1fc230e297d814c7706dcc920809384d26f951828ec16f44
f3a542a1928f10895d274611b8bd311e932176fad2a5bbbb74dea1701a0b2e078634e949d7d8b050d8d1615122f89c0734718e106db830cf881df7f17de13a14
7101171a6e41fdb9f9ddcb79b4b330a2628bad66d7557f0bbb85c1e8b0a4e64c26836c52cff3bd4a33f3af00546ce23ad54ea553c9fc29001a0e61a52917dda7
dfaab7dafe02ab81d2438bef76b55d2e1a78cd7f798373d3973f03af40a97f6f03dfed06104503af4029dedfc07b5eb51478065e81527c65035f2d34db5ed5c0
2b5048497cb8812ef89572b05c6d061933ba6785d77daf5b2d2d9caf50500d5975c929c62c16db6a2d42f758d2058004522448ec88f9148fd110aa3840940c12
e2ec93490885374531e3305c2815ba8532fc973f4f1da988a01d8c346bc90b98f08d21c9c7e1c3844c45c3fd18bcba1ae4cdcb1fdfbc7cee9c3c7a71f2e89793
c78f4f1efd9c3a32acf6503cd1ad5e7fffc5df4f3f75fe7afeddeb275fd9f15cc7fffed367bffdfaa51d082b5d85e0d5d7cffe78f1ecd5379ffff9c3130bbc99
a0810eef930873e73a3e766eb10816a6426032c783e4ed2cfa2122ba45339e701423398bc57f478406fafa1c5164c1b5b019c13b09488c0d787576cf20dc0b93
9920168fd7c2c8001e30465b2cb146e19a9c4b0b737f164fec9327331d770ba123dbdc018a8dfc766653d05662731984d8a07993a258a0098eb170e4357688b1
6575770931e27a408609e36c2c9cbbc46921620d499f0c8c6a5a19ed9108f232b711847c1bb139b8e3b418b5adba8d8f4c24dc15885ac8f73135c27815cd048a
6c2efb28a27ac0f791086d247bf364a8e33a5c40a6279832a733c29cdb6c6e24b05e2de9d7405eec693fa0f3c84426821cda7cee23c674649b1d06218aa6366c
8fc4a18efd881f428922e7261336f80133ef10790e7940f1d674df21d848f7e96a701b9455a7b42a107965965872791533a37e7b733a4658490d08bfa1e71189
4f15f73559f7ff5b5907217df5ed53cbaa2eaaa0371362bda3f6d6647c1b6e5dbc03968cc8c5d7ee369ac53731dc2e9b0decbd74bf976ef77f2fdddbeee7772f
d82b8d06f9965bc574abae36eed1d67dfb9850da13738af7b9daba73e84ca32e0c4a3bf5cc8ab3e7b8690887f24e86090cdc2441cac64998f88488b017a229ec
ef8bae7432e10bd713ee4c19876dbf1ab6fa96783a8b0ed8287d5c2d16e5a3692a1e1c89d578c1cfc6e15143a4e84a75f50896b9576c27ea51794940dabe0d09
6d329344d942a2ba1c9441520fe610340b09b5b277c2a26e615193ee97a9da6001d4b2acc0d6c9810d57c3f53d30012378a242148f649ed2542fb3ab92f92e33
bd2d984605c03e625901ab4cd725d7adcb93ab4b4bed0c99364868e566925091513d8c87688417d52947cf42e36d735d5fa5d4a02743a1e683d25ad1a8d6fe8d
c579730d76ebda40635d2968ec1c37dc4ad9879219a269c31dc3633f1c4653a81d2eb7bc884ee0ddd95024e90d7f1e6599265cb4110fd3802bd149d520220227
0e2551c395cbcfd24063a5218a5bb104827061c9d541562e1a3948ba99643c1ee3a1d0d3ae8dc848a7a7a0f0a95658af2af3f383a5259b41ba7be1e8d819d059
720b4189f9d5a20ce0887078fb534ca33922f03a3313b255fdad35a685eceaef13550da5e3884e43b4e828ba98a77025e5191d7596c5403b5bac1902aa8564d1
080713d960f5a01add34eb1a2987ad5df7742319394d34573dd35015d935ed2a66ccb06c036bb13c5f93d7582d430c9aa677f854bad725b7bed4bab57d42d625
20e059fc2c5df70c0d41a3b69acca026196fcab0d4ecc5a8d93b960b3c85da599a84a6fa95a5dbb5b8653dc23a1d0c9eabf383dd7ad5c2d078b9af549156df3d
f44f136c700fc4a30d2f81675470954af8f09020d810f5d49e24950db845ee8bc5ad0147ce2c210df741c16f7a41c90f72859adfc97965af90abf9cd72aee9fb
e562c72f16daadd243682c228c8a7efacda50bafa2e87cf1e5458d6f7c7d89966fdb2e0d599467eaeb4a5e11575f5f8aa5ed5f5f1c02a2f3a052ead6cbf55625
572f37bb39afddaae5ea41a5956b57826abbdb0efc5abdfbd0758e14d86b9603afd2a9e52ac520c8799582a45fabe7aa5ea9d4f4aacd5ac76b3e5c6c6360e5a9
7c2c6201e155bc76ff010000ffff0300504b0304140006000800000021000dd1909fb60000001b010000270000007468656d652f7468656d652f5f72656c732f
7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f78277086f6fd3ba109126dd88d0add40384e4350d363f2451eced0dae2c082e8761be
9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89d93b64b060828e6f37ed1567914b284d262452282e3198720e274a939cd08a54f980
ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd5001996509affb3fd381a89672f1f165dfe514173d9850528a2c6cce0239baa4c04ca5b
babac4df000000ffff0300504b01022d0014000600080000002100e9de0fbfff0000001c0200001300000000000000000000000000000000005b436f6e74656e
745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6a7e7c0000000360100000b00000000000000000000000000300100005f72656c732f
2e72656c73504b01022d00140006000800000021006b799616830000008a0000001c00000000000000000000000000190200007468656d652f7468656d652f74
68656d654d616e616765722e786d6c504b01022d0014000600080000002100aa5225dfc60600008b1a00001600000000000000000000000000d6020000746865
6d652f7468656d652f7468656d65312e786d6c504b01022d00140006000800000021000dd1909fb60000001b0100002700000000000000000000000000d00900007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d010000cb0a00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax371\lsdlockeddef0\lsdsemihiddendef0\lsdunhideuseddef0\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 1;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 5;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 6;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 7;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 8;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index 9;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 1;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 2;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 3;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 4;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 5;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 6;
\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 7;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 8;\lsdsemihidden1 \lsdunhideused1 \lsdpriority39 \lsdlocked0 toc 9;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Normal Indent;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footnote text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 header;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footer;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 index heading;\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 table of figures;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 envelope address;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 envelope return;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 footnote reference;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation reference;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 line number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 page number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 endnote reference;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 endnote text;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 table of authorities;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 macro;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 toa heading;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Bullet 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 4;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Number 5;\lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Closing;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Signature;\lsdsemihidden1 \lsdunhideused1 \lsdpriority1 \lsdlocked0 Default Paragraph Font;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 4;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 List Continue 5;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Message Header;\lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Salutation;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Date;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text First Indent;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text First Indent 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Note Heading;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Body Text Indent 3;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Block Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Hyperlink;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 FollowedHyperlink;\lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;
\lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Document Map;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Plain Text;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 E-mail Signature;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Top of Form;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Bottom of Form;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Normal (Web);\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Acronym;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Address;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Cite;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Code;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Definition;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Keyboard;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Preformatted;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Sample;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Typewriter;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 HTML Variable;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 annotation subject;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 No List;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 1;
\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 2;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Outline List 3;\lsdsemihidden1 \lsdunhideused1 \lsdlocked0 Balloon Text;\lsdpriority39 \lsdlocked0 Table Grid;
\lsdsemihidden1 \lsdlocked0 Placeholder Text;\lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;\lsdpriority60 \lsdlocked0 Light Shading;\lsdpriority61 \lsdlocked0 Light List;\lsdpriority62 \lsdlocked0 Light Grid;
\lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdpriority64 \lsdlocked0 Medium Shading 2;\lsdpriority65 \lsdlocked0 Medium List 1;\lsdpriority66 \lsdlocked0 Medium List 2;\lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdpriority68 \lsdlocked0 Medium Grid 2;
\lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdpriority70 \lsdlocked0 Dark List;\lsdpriority71 \lsdlocked0 Colorful Shading;\lsdpriority72 \lsdlocked0 Colorful List;\lsdpriority73 \lsdlocked0 Colorful Grid;\lsdpriority60 \lsdlocked0 Light Shading Accent 1;
\lsdpriority61 \lsdlocked0 Light List Accent 1;\lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;
\lsdsemihidden1 \lsdlocked0 Revision;\lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;
\lsdpriority72 \lsdlocked0 Colorful List Accent 1;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdpriority60 \lsdlocked0 Light Shading Accent 2;\lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdpriority62 \lsdlocked0 Light Grid Accent 2;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;\lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;
\lsdpriority72 \lsdlocked0 Colorful List Accent 2;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;\lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdpriority61 \lsdlocked0 Light List Accent 3;\lsdpriority62 \lsdlocked0 Light Grid Accent 3;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;\lsdpriority70 \lsdlocked0 Dark List Accent 3;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;
\lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;\lsdpriority60 \lsdlocked0 Light Shading Accent 4;\lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdpriority62 \lsdlocked0 Light Grid Accent 4;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdpriority70 \lsdlocked0 Dark List Accent 4;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;
\lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdpriority60 \lsdlocked0 Light Shading Accent 5;\lsdpriority61 \lsdlocked0 Light List Accent 5;\lsdpriority62 \lsdlocked0 Light Grid Accent 5;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;\lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;
\lsdpriority72 \lsdlocked0 Colorful List Accent 5;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdpriority61 \lsdlocked0 Light List Accent 6;\lsdpriority62 \lsdlocked0 Light Grid Accent 6;
\lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;\lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;
\lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;\lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdpriority70 \lsdlocked0 Dark List Accent 6;\lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;
\lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;\lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;\lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdsemihidden1 \lsdunhideused1 \lsdpriority37 \lsdlocked0 Bibliography;
\lsdsemihidden1 \lsdunhideused1 \lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;\lsdpriority41 \lsdlocked0 Plain Table 1;\lsdpriority42 \lsdlocked0 Plain Table 2;\lsdpriority43 \lsdlocked0 Plain Table 3;\lsdpriority44 \lsdlocked0 Plain Table 4;
\lsdpriority45 \lsdlocked0 Plain Table 5;\lsdpriority40 \lsdlocked0 Grid Table Light;\lsdpriority46 \lsdlocked0 Grid Table 1 Light;\lsdpriority47 \lsdlocked0 Grid Table 2;\lsdpriority48 \lsdlocked0 Grid Table 3;\lsdpriority49 \lsdlocked0 Grid Table 4;
\lsdpriority50 \lsdlocked0 Grid Table 5 Dark;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 1;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 1;
\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 1;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 1;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 1;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 1;
\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 1;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 2;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 2;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 2;
\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 2;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 2;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 2;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 2;
\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 3;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 3;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 3;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 3;
\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 3;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 3;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 3;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 4;
\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 4;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 4;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 4;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 4;
\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 4;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 4;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 5;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 5;
\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 5;\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 5;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 5;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 5;
\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 5;\lsdpriority46 \lsdlocked0 Grid Table 1 Light Accent 6;\lsdpriority47 \lsdlocked0 Grid Table 2 Accent 6;\lsdpriority48 \lsdlocked0 Grid Table 3 Accent 6;
\lsdpriority49 \lsdlocked0 Grid Table 4 Accent 6;\lsdpriority50 \lsdlocked0 Grid Table 5 Dark Accent 6;\lsdpriority51 \lsdlocked0 Grid Table 6 Colorful Accent 6;\lsdpriority52 \lsdlocked0 Grid Table 7 Colorful Accent 6;
\lsdpriority46 \lsdlocked0 List Table 1 Light;\lsdpriority47 \lsdlocked0 List Table 2;\lsdpriority48 \lsdlocked0 List Table 3;\lsdpriority49 \lsdlocked0 List Table 4;\lsdpriority50 \lsdlocked0 List Table 5 Dark;
\lsdpriority51 \lsdlocked0 List Table 6 Colorful;\lsdpriority52 \lsdlocked0 List Table 7 Colorful;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 1;\lsdpriority47 \lsdlocked0 List Table 2 Accent 1;\lsdpriority48 \lsdlocked0 List Table 3 Accent 1;
\lsdpriority49 \lsdlocked0 List Table 4 Accent 1;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 1;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 1;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 1;
\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 2;\lsdpriority47 \lsdlocked0 List Table 2 Accent 2;\lsdpriority48 \lsdlocked0 List Table 3 Accent 2;\lsdpriority49 \lsdlocked0 List Table 4 Accent 2;
\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 2;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 2;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 2;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 3;
\lsdpriority47 \lsdlocked0 List Table 2 Accent 3;\lsdpriority48 \lsdlocked0 List Table 3 Accent 3;\lsdpriority49 \lsdlocked0 List Table 4 Accent 3;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 3;
\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 3;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 3;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 4;\lsdpriority47 \lsdlocked0 List Table 2 Accent 4;
\lsdpriority48 \lsdlocked0 List Table 3 Accent 4;\lsdpriority49 \lsdlocked0 List Table 4 Accent 4;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 4;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 4;
\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 4;\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 5;\lsdpriority47 \lsdlocked0 List Table 2 Accent 5;\lsdpriority48 \lsdlocked0 List Table 3 Accent 5;
\lsdpriority49 \lsdlocked0 List Table 4 Accent 5;\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 5;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 5;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 5;
\lsdpriority46 \lsdlocked0 List Table 1 Light Accent 6;\lsdpriority47 \lsdlocked0 List Table 2 Accent 6;\lsdpriority48 \lsdlocked0 List Table 3 Accent 6;\lsdpriority49 \lsdlocked0 List Table 4 Accent 6;
\lsdpriority50 \lsdlocked0 List Table 5 Dark Accent 6;\lsdpriority51 \lsdlocked0 List Table 6 Colorful Accent 6;\lsdpriority52 \lsdlocked0 List Table 7 Colorful Accent 6;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e362e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffff0c6ad98892f1d411a65f0040963251e500000000000000000000000080e6
8aa206b9d201feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}