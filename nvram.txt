\ ==== Boot Block ==============================================
-1 loaded !














; ==== Short Help ==============================================


A short list of commands

  help       display the tutorial and help
  words      list all Forth words (in current vocabulary)
  see        decompile the next word in the input stream
  0 30 index get titles for blocks 
  1 list     list block number '1', this block

This is a subroutine threaded Forth, the starting base is 16,
or hexadecimal. It is based on eForth.



; ==== Forth Error Messages: 1/4 ==============================
  -1 ABORT
  -2 ABORT"
  -3 stack overflow
  -4 stack underflow
  -5 return stack overflow
  -6 return stack underflow
  -7 do-loops nested too deeply during execution
  -8 dictionary overflow
  -9 invalid memory address
 -10 division by zero
 -11 result out of range
 -12 argument type mismatch
 -13 undefined word
 -14 interpreting a compile-only word
 -15 invalid FORGET
; ==== Forth Error Messages: 2/4 ==============================
 -16 attempt to use zero-length string as a name
 -17 pictured numeric output string overflow
 -18 parsed string overflow
 -19 definition name too long
 -20 write to a read-only location
 -21 unsupported operation
 -22 control structure mismatch
 -23 address alignment exception
 -24 invalid numeric argument
 -25 return stack imbalance
 -26 loop parameters unavailable
 -27 invalid recursion
 -28 user interrupt
 -29 compiler nesting
 -30 obsolescent feature
; ==== Forth Error Messages: 3/4 ==============================
 -31 >BODY used on non-CREATEd definition
 -32 invalid name argument (e.g., TO xxx)
 -33 block read exception
 -34 block write exception
 -35 invalid block number
 -36 invalid file position
 -37 file I/O exception
 -38 non-existent file
 -39 unexpected end of file
 -40 invalid BASE for floating point conversion
 -41 loss of precision
 -42 floating-point divide by zero
 -43 floating-point result out of range
 -44 floating-point stack overflow
 -45 floating-point stack underflow
; ==== Forth Error Messages: 4/4 ==============================
 -46 floating-point invalid argument
 -47 compilation word list deleted
 -48 invalid POSTPONE
 -49 search-order overflow
 -50 search-order underflow
 -51 compilation word list changed
 -52 control-flow stack overflow
 -53 exception stack overflow
 -54 floating-point underflow
 -55 floating-point unidentified fault
 -56 QUIT
 -57 exception in sending or receiving a character
 -58 [IF], [ELSE], or [THEN] exception


; ==== Description of this file ================================
The next screens contain extra code that can be loaded into the
interpreter if needed. Some of the standard Forth words are
placed here instead of in the image to save on space.

The blocks should be loaded in order unless otherwise stated.

This file is first converted by a utility into a fixed width
format, which can then be loaded onto the target board with
the same utility used to uploaded the bitfile to the FPGA.

Form feeds are used to mark the boundaries between blocks,
this does not have any special significance and is only there
to make editing easier. Line lengths are limited to 64
characters wide, each block contains 16 lines.

; ==== Empty Block =============================================















\ ==== Block Editor 1/2 ========================================
 ( Block Editor : block $8 )
variable editor-voc 0 editor-voc ! forth
: editor decimal editor-voc 1 set-order ;
get-order editor-voc swap 1+ set-order
$40 constant c/l $10 constant l/b
: (block) blk @ block ;
: (check) dup b/buf c/l / u>= if -24 throw then ;
: (line) (check) c/l * (block) + ;
: b block drop ;
: l blk @ list ;
: n  1 +block b l ;
: p -1 +block b l ;
: d (line) c/l blank ;
: x (block) b/buf blank ; 
: s update save-buffers ; 
\ ==== Block Editor 2/2/ =======================================
: q forth save-buffers ;
: e forth blk @ load editor ;
: ia c/l * + (block) + source drop >in @ +
  swap source nip >in @ - cmove [compile] \ ;
: i 0 swap ia ;
: u update ;
: w words ;
: yank pad c/l ;
: c (line) yank >r swap r> cmove ;
: y (line) yank cmove ;
: ct swap y c ;
: ea (line) c/l evaluate ;
: sw 2dup y (line) swap (line) swap c/l cmove c ;
forth

\ ==== Assembler word set ======================================
variable assembler-voc
bl parse rdrop pad pack$ find drop assembler-voc !
: assembler assembler-voc 1 set-order ;
: ;code assembler ; immediate
: code [compile] : assembler ;
get-order assembler-voc swap 1+ set-order
: end-code forth [compile] ; ; immediate
: words words ;
: forth forth ;
forth





\ ==== CORDIC 1/2 ==============================================
variable lookup -1 cells allot ( 16 values )
$3243 , $1DAC , $0FAD , $07F5 , $03FE , $01FF , $00FF , $007F ,
$003F , $001F , $000F , $0007 , $0003 , $0001 , $0000 , $0000 ,

: arshift ( n u -- n : arithmetic right shift )
  2dup rshift >r swap $8000 and 
  if $10 swap - -1 swap lshift else drop 0 then r> or ;

$26DD constant cordic_1K $6487 constant pi/2

variable tx 0 tx ! variable ty 0 ty ! variable tz 0 tz !
variable x  0  x ! variable y  0  y ! variable z  0  z !
variable d  0  d ! variable k  0  k !


\ ==== CORDIC 2/2 ==============================================
( CORDIC: valid in range -pi/2 to pi/2, arguments are in fixed )
( point format with 1 = 16384, angle is given in radians.  )
: cordic ( angle -- sine cosine )
  z ! cordic_1K x ! 0 y ! 0 k !
  $10 begin ?dup while
    z @ 0< d !
    x @ y @ k @ arshift d @ xor d @ - - tx !
    y @ x @ k @ arshift d @ xor d @ - + ty !
    z @ k @ cells lookup + @ d @ xor d @ - - tz !
    tx @ x ! ty @ y ! tz @ z !
    k 1+!
    1-
  repeat y @ x @ ;
: sin cordic drop ; 
: cos cordic nip ;
\ ==== Login Code 1/2 ==========================================
\ Login and user management system 
: generate count dup >r crc r> ccitt ; ( b -- u )
: .user     ." user>" space ; ( -- )
: .password ." password>" space ; ( -- )
variable user0 0 user0 !
: mk.user ( --; <string1>, <string2> )
  here user0 @ , user0 ! here 0 , bl word count 1+ allot align
  drop bl word generate swap ! ;
: ls.user ( -- : list all users in user database )
  cr user0 @ 
  begin dup while dup 2 cells + space count type cr @ repeat
  drop cr ;
: find.user ( a -- u | 0 : find user in database, return hash )
  >r user0 @ begin dup while dup 2 cells + count r@ count
  =string if rdrop exit then @ repeat rdrop drop 0 ;
\ ==== Login Code 2/2 ==========================================
: (password) ( u --, <string> )
  >r begin .password query bl word cr generate
  r@ = until rdrop ;
: fake .password query bl word drop cr ;
: (user) 
  begin .user query bl word cr find.user ?dup until ;
: retry ( xt -- : retry word until it succeeds )
  >r begin r@ catch 0= until rdrop ;
: user? [ ' (user) literal ] retry ;
: password? [ ' (password) literal ] retry ;
: hide-all 0 1 set-order ;
: login hide-all
  cr user? cell+ @ conceal password? interactive forth ;
mk.user guest guest     mk.user archer dangerzone
mk.user lana  sterling  mk.user cyril  figgis
\ ==== Extra Code 1/6 ==========================================
: 2+ 2 + ;                       ( n -- n )
: 2- 2 - ;                       ( n -- n )
: >= < invert ;                  ( n n -- f )
: simulation? cpu-id $cafe <> ; ( -- f : are we in the matrix? )
: 0<= 0> 0= ;                    ( n n -- f )
: 0>= 0< 0= ;                    ( n n -- f )
: not -1 xor ;                   ( n -- n )
: dabs dup 0< if dnegate then ;  ( d -- d )
: d+  >r swap >r um+ r> r> + + ; ( d d -- d )
: d=  >r swap r> = >r = r> and ; ( d d -- f )
: d<> d= 0= ;                    ( d d -- f )
: roll  dup 0> if swap >r 1- recurse r> swap else drop then ;
: ?exit if rdrop then ;          ( n --, R: n -- n | )
: 2rdrop r> rdrop rdrop >r ;     ( R n n -- )
: 2. swap . . ;                  ( n n -- )
\ ==== Extra Code 2/6 ==========================================
: m* 2dup xor 0< >r abs swap abs um* r> if dnegate then ;
: */mod  >r m* r> m/mod ;  ( n n n -- r q )
: */  */mod nip ;          ( n n n -- q )
: s>d dup 0< ;             ( n -- d : single to double )
: holds begin dup while 1- 2dup + c@ hold repeat 2drop ;
: binary  2 base ! ;                       ( -- )
: octal  8 base ! ;                        ( -- )
: .base base @ dup decimal base ! ; ( -- )
: only -1 set-order ;
: also get-order over swap 1+ set-order ;
: previous get-order swap drop 1- set-order ;
: buffer block ; ( k -- a )
: bye [ 0 , ] ;
: enum dup constant 1+ ; ( n --, <string> )
: logical 0= 0= ;     ( n -- f )
\ ==== Extra Code 3/6 ==========================================
: square dup * ;      ( n -- )
: limit rot min max ; ( n lo hi -- n )
: odd 1 and logical ; ( n -- )
: even odd invert ;   ( n -- )
: nor or invert ;     ( u u -- u )
: nand and invert ;   ( u u -- u )
: bell 7 emit ;       ( -- )
: under >r dup r> ;   ( n1 n2 -- n1 n1 n2 )
: 2nip >r >r 2drop r> r> ; ( n1 n2 n3 n4 -- n3 n4 )
( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
: 2over >r >r 2dup r> swap >r swap r> r> -rot ;
: 2swap >r -rot r> -rot ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
: 2tuck 2swap 2over ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 n3 n4 )
: 4drop 2drop 2drop ; ( n1 n2 n3 n4 -- )
: trip dup dup ; ( n -- n n n )
\ ==== Extra Code 4/6 ==========================================
: log  >r 0 swap ( u base -- u )
  begin swap 1+ swap r@ / dup 0= until
  drop 1- rdrop ;
: log2 0 swap ( u -- u )
  begin swap 1+ swap   2/ dup 0= until
  drop 1- ;
: average um+ 2 um/mod nip ; ( u u -- u )
: <=> 2dup > if 2drop -1 exit then < ;
: bounds over + swap ;
: 2, , , ; ( n n -- )
: tab 9 emit ; ( -- )
: drup drop dup ; ( n1 n2 -- n1 n1 )
: lsb $ff and ; ( u -- u )


\ ==== Extra Code 5/6 ==========================================
: signum ( n -- -1 | 0 | 1 : Signum function )
  dup 0> if drop  1 exit then
      0< if      -1 exit then
      0 ;
: >< dup 8 rshift swap 8 lshift or ; ( u -- u : swap bytes )
: #digits dup 0= if 1+ exit then base @ log 1+ ;
: ** ( n u -- n )
  ?dup if 
    over >r 
    begin 
      dup 1 > 
    while 
      swap r@ * swap 1- 
    repeat rdrop drop
  else logical 1 and then ; 
\ ==== Extra Code 6/6 ==========================================
: b. base @ swap 2 base ! u. base ! ; ( u -- )
: h. base @ swap hex u. base ! ;      ( u -- )
: o. base @ swap 8 base ! u. base ! ; ( u -- )
: d. base @ swap decimal . base ! ;   ( n -- )
: @bits swap @ and ;                  ( a u -- u )
: ?\ if [compile] \ then ; immediate
: ?( if [compile] ( then ; immediate ( )








; ==== eForth v6.66: Help and Tutorial =========================

This Forth is modeled after eForth, described in a book by
C.H. Ting called "eForth Overview", or "The Zen of eForth". It
implements most of the eForth model with some changes expected
from a more modern Forth system.

The processor targeted is called the H2, a rewrite of the
J1 processor (<http://www.excamera.com/sphinx/fpga-j1.html>).
It has been extended with a few more instructions and with
interrupts. The system resides on an FPGA Nexys 3 board from
Digilent, with words and peripherals designed for it.

For more see: <https://github.com/howerj/forth-cpu>


; ==== Help: Introduction ======================================

Forth is a simple, imperative, stack based language that mixes
elements of a high level language with a low level language. It
is possible to fit a small Forth system in a few kilobytes of
RAM complete with an interactive read-evaluate-print loop, an
editor, an assembler and a disassembler.

It is also a language that has fallen out of favor in recent
times (after the micro-computer era) as it is not a very safe
language, nor is it one that allows the programmer to easily
create reusable and maintainable software components.

However it is still suitable for a number of purposes; for
assemblers, to bring up hardware and test it, in memory
constrained systems, as a boot loader, and for fun.
; ==== Help: Philosophy of Forth ===============================
Forth itself has its own philosophy, one in which the programmer
should have a complete understanding of the system, from the
problem that needs to be solved, the algorithms needed to solve
it, the hardware and the software. As the latter two, the
hardware and software are usually very simple in Forth systems
it is possible to optimize the problem across multiple domains,
tailoring each to come up with a solution. Forth eschews
complexity, preferring one off, bespoke solutions. Another
reason it has not seen widespread use.

Advocates of the language are usually quite passionate about
it (as with Lisp, and other niche systems) so it is important
to be pragmatic about Forth. Forth is simply a tool and when
used correctly can be used productively.

; ==== Help: Basics 1/6 ========================================
A Forth system contains an interactive interpreter that parses
text and either compiles or executes functions, called 'words'
in Forth terminology. The system uses Reverse Polish Notation
(RPN) and provides the user with two stacks and a 'dictionary'
(a big block of memory containing 'words' and other data).

The interpreter reads from an input device, such as a keyboard
or a serial port, and writes output to the screen or back over
the serial port. Words and number input are space delimited and
are either compiled into the dictionary depending on the
interpreter mode and whether the word read in is 'immediate'
or not.

This tutorial will describe how to use Forth and how the
interpreter works internally.
; ==== Help: Basics 2/6 ========================================
To start with, simple expressions can be entered and the
results displayed. A line is evaluated after the carriage
return is entered, code will be indented, this can be typed in.

We will start off with a simple expression, adding two numbers
together and displaying the result:

  ( Comments appear within brackets )
  2 2 + .

This prints out '4' and 'ok'. 'ok' is printed out after every
line has been successfully compiled, unless we are in compile
mode. '+' obviously does the addition, and '.' pops a value
off the stack an prints it. Entering a number pushes it onto
the data stack.
; ==== Help: Basics 3/6 ========================================
The data, or variable, stack is a general purpose stack that
the programmer uses to pass data to functions, and to return
data from functions. The stacks are an important concept
within Forth and stack management will take up a lot of a Forth
programmers time.

Numbers are entered in Reverse Polish Notation, this allows
Forth interpreter to immediate process a word or a function as
it is encountered instead of building up a parse tree.

When '2' is encountered it is pushed onto the variable stack,
when the second '2' is input, it is also pushed onto the stack.
The Forth word '+' takes two arguments off the stack, adds them
together and pushes the result back onto the stack. The word
'.' pops a single number off the stack and prints it.
; ==== Help: Basics 4/6 ========================================
Manipulating the stack will be difficult at first, but gets
easier over time. There are standard words for stack
manipulation and a standard methodology for describing
stack effects called 'stack comments'.

A stack comment is a short comment describing the stack before
and after execution of the word, and the type of the arguments
it accepts and returns. For example the stack comment for '+'
is:

  + ( n n -- n : add two numbers together )

All text between '(' and the ')' is discarded by the Forth
system. This comment describes a word that accepts two
signed numbers "n n", and returns a signed number "n".
; ==== Help: Basics 5/6 ========================================
The "--" divides the comment into what the stack looks like
before execution of the word (to the left of "--") and what it
looks like after (to the right of "--"). A comment on the
behavior of the word comes after the semicolon.

Here is a list of some common Forth words and their stack
comments:

  dup  ( n -- n n : duplicate first item on the stack )
  swap ( n1 n2 -- n2 n1 : swap first two items on stack )
  drop ( n -- : drop a value from the stack )

Stack effects are sometimes numbered, which is used to
so the effects on specific arguments can be documented if
the order of arguments and return values matter.
; ==== Help: Basics 6/6 ========================================
Some more words with comments:

  @    ( a -- u : load value from memory address )
  !    ( u a -- : store 'u' at memory location 'a' )
  <    ( n1 n2 -- f : is n1 greater than n2, signed )
  u<   ( u1 u2 -- f : is u1 greater than n2, unsigned )

These words have stack comments, some with numbered arguments,
but they use different letters. The different letters are used
to describe the type of the arguments that the word accepts.

'@', also known as load, takes an address, and '!', takes
an address and a value. "<" takes two signed numbers, "u<"
takes two unsigned numbers and produces a flag. Type checking
is not performed by Forth and is up to the programmer.
; ==== Help: Stack Comments ====================================
Here is a list of stack type descriptions and what they mean:
| Comment  | Meaning                             |
|----------|-------------------------------------|
| a        | cell address                        |
| n        | signed number                       |
| u        | unsigned number                     |
| b        | string address                      |
| c        | single character                    |
| d        | double width number (2 Cells)       |
| f        | boolean flag (-1 = true, 0 = false) |
| k        | block number                        |
| cfa      | code field address of a word        |
| nfa      | name field address of a word        |
| pwd      | previous word address of a word     |
| <string> | a parsing word                      |
; ==== Help: Expressions =======================================
Let us continue on with some interactive examples before we
start to define new words. Before we saw a trivial example
of adding two numbers together, we will go over a few more
operators first.

  9 2 + . ( Displays 'B', the default base is hexadecimal )
  decimal ( Change the input and output base to decimal )
  9 2 + . ( Displays '11' )
  3 4 dup * swap dup * + . ( Displays 3^2 + 4^2 or 25 )

Negative numbers can be input by prefixing the number with
'-':

  -2 4 * . ( Display -8 )

; ==== Help: Numeric Output 1/2 ================================
The word '.' pops a value off the stack before displaying it,
if we want to examine the stack without popping the value we
can print out the entire contents of the stack with '.s':

  1 2 3 .s ( prints "1 2 3 <sp")
  .        ( prints "3" )
  .s       ( prints "1 2 <sp" )

"<sp" marks the element which is currently on the top of the
stack. Other useful words for debugging include '?' that
prints the contents at a memory address and 'dump', which
prints a memory dump of a region of memory.

  dump ( a u -- )
  ?    ( a -- )
; ==== Help: Numeric Output 2/2 ================================
Hexadecimal numbers can be entered if the base input and output
base is 16, or by prefixing the number with '$'.

  decimal  $aaa . ( Displays 2730 )
          -$aaa . ( Displays -2730 )

eForth starts up in base 16, valid bases range anywhere from
2 to 36. The base can be changed by either setting a variable
'base' to the desired base, or with the words 'hex' to change
the base back into hexadecimal, or 'decimal' to change the base
to '10'. Variables in Forth are words that leave an address on 
the stack when they are called. They can be read or set with 
'@' and '!'. For example, "$10 base !" and "hex" are 
equivalent, as are "$a base !" and "decimal".

; ==== Help: Word Definitions 1/2 ==============================
For the moment we have not covered how words are defined and
is a good time to do so, the word ":" is used to create a new
word definition and the word ";" is used to terminate one.
Words once defined are added to the 'dictionary', which is
consists of a linked list of words, hence the name 
'dictionary'. We can define new words interactively like we can
type expressions in, such as:

  : square dup * ; ( n -- n : square a number )

We can then use square like any other word:

  4 square .  ( prints 16 )
  -5 square . ( prints 25 )

; ==== Help: Word Definitions 2/2 ==============================
'hex' and 'decimal' are defined as:

  : hex $10 base ! ;
  : decimal $a base ! ;

And simple Forth words likewise defined:

  : 2- 2 - ;      ( u -- u : decrement a number by 2 )
  : 2+ 2 + ;      ( u -- u : increment a number by 2 )
  : 2* 1 lshift ; ( u -- u : multiply a number by 2 )
  : 1+ 1 + ;      ( u -- u : increment a number by 1 )
  : negate invert 1+ ; ( n -- n : negate, twos compliment )
  
It is best to keep all Forth words as short as possible and
reuse code as much as possible.
; ==== Help: Interpreter Loop 1/3 ==============================
All functions, control structures, defining words such as ":",
and simple functions like "square" or "hex" are simply Forth
words, which are either defined in terms of other Forth words
or in terms of primitive operations supported by the H2 CPU.

Currently this does not explain how compilation happens. When
the word ":" is encountered it does multiple things such as
compiling a word header into the dictionary, and it does one
more thing - it puts the Forth system into compile mode. The
system starts out in command mode, in this mode words are
executed, and numbers are pushed onto the stack. In compile
mode, a call to the word is compiled (or an assembly
instruction is inlined) and numbers of turned into literals
that push their value when run.

; ==== Help: Interpreter Loop 2/3 ==============================
There is a special class of words called "immediate" words, ";"
is an immediate word, when it is encountered instead of being
compiled into the dictionary it is executed, it compiles an
exit instruction to terminate the word definition and it puts
the Forth system back into command mode.

Not only are control structures sets of words, like "if",
"else", "then", "begin", "until", but so are words like "("
and "\" which are used to process comments. When executed
they read from the input stream until the they find a ")" or
end of line respectively.

Variables, strings, and defining words (defining words are
that create new words) are all simply Forth words that are
either compiling or immediate, their is no special syntax.
; ==== Help: Interpreter Loop 3/3 ==============================
The command loop goes like this:
Start) Fetch a space delimited word, find it in the dictionary
   Found) Is the system in compile mode?
          Yes) Is the word immediate?
               Yes) Execute It
               No)  Compile a call to it / In-line it
          No)  Execute the word
   Not Found) Is the word a number?
          Yes) Is the system in compile mode?
               Yes) Compile the number
               No)  Push the number onto the stack
          No)  Error!
This simple loop is invoked by the work 'quit' which uses
'query' to fetch and parse the input and 'interpreter' to
perform the state dependent action.
; ==== Help: Control Structures 1/10 ===========================
This will give you some idea what is going on when control
structures are covered in the following blocks. Control
structures can only be used within a word definition, that
is in compile mode, if used in command mode they simply throw
an error.

Some of the control structures available to Forth are:

  if ... then
  if ... else ... then
  for ... next
  for ... aft ... then ... next
  begin ... until
  begin ... again
  begin ... while ... repeat
; ==== Help: Control Structures 2/10 ===========================
Recursion is also available with the 'recurse' word. There
are more advance control flow methods available that will be
described later (such as 'catch', 'throw' and manipulating the
return stack).

"if...then" will be described first. First a simple example,
we will define a word called 'abs' that will return the
absolute value of a number, that is negative numbers will be
turned into positive numbers and positive numbers will stay
the same. This will require the word 'negate' which changes
the sign of a number and '0<' which tests if a number is
negative, their stack effect comments are:

  0<     ( n -- f )
  negate ( n -- n )
; ==== Help: Control Structures 3/10 ===========================
The word 'abs' is then defined as:

  : abs dup 0< if negate then ;

'if' takes an argument off the stack at run time and jumps to
after the 'then' if it is false (zero), if it is true (non-
zero) the negate is performed. From now if a word is shown in
a definition that has not been previously mentioned please
refer to the glossary. We can can use the definition of the
word 'abs' as soon as we terminate the definition with ";":

  -9 abs . ( displays 9 )
   4 abs . ( displays 4 )

This Forth uses two complements to represent negative numbers.
; ==== Help: Control Structures 4/10 ===========================
A number can be negated in twos compliment form by performing
a bitwise not on the number and adding one to it, this is what
the word 'negate' does.

"if...else...then" control structures can be created:

  : min 2dup < if drop else nip then ; ( n n -- n )
  : max 2dup > if drop else nip then ; ( n n -- n )

These words get the minimum (min) and the maximum (max) of
two numbers.

   4 3 min . ( prints 3 )
   4 3 max . ( prints 4 )

; ==== Help: Control Structures 5/10 ===========================
Whilst control structures can be nested very deeply it is
considered very bad practice to do, instead the definition
should be refactored so it consists of short (preferably one
line) word definitions.

There are two mains ways of looping, either by recursion or
with the several looping mechanisms. One of the simplest is
"begin...until". This continues looping until a variable popped
off the stack when the "until" word is reach is non-zero. Like
the "if" control structure this can only be used within a word
definition. An example is the definition of "key", which gets
a single character from the input device, it blocks until there
is input. It uses a word called "key?" which returns a variable
number of items on the stack depending on whether there is
new input from the user.
; ==== Help: Control Structures 6/10 ===========================
The stack comments for "key?" and "key" are:

  key? ( -- c -1 | 0 )
  key  ( -- c )

Key returns the new character and "-1" (in Forth -1 is true,
and 0 is false), or "0" if there is no new input. The pipe
system "|" is used to separate the possible return values in
the stack comment. We can use "begin...until" to define "key"
in terms of "key?" with:

  : key begin key? until ;

This simply loops until there is a new character of input.

; ==== Help: Control Structures 7/10 ===========================
Some contrived examples, using the standard metasyntactic
variable name "foo":

  : foo begin 1- dup . cr dup 0= until drop ; ( u -- )

  4 foo ( <-- type this ) 3 ( <-- prints '3' )
  2  ( <-- then '2' )
  1  ( ... )
  0  ( ... )
  ok ( then ok prompt )

If zero is given this will underflow and wrap around to $FFFF
and continue the loop 65536 times which is probably not
intended.

; ==== Help: Control Structures 8/10 ===========================
Indefinite loops can be made with "begin...again", the
following word "bar" simply repeatedly prints out "1":

  : bar begin 1 . cr again ;
  bar 1 1 1 1 1 1 ( ... ad infinitum ... )

A looping mechanism that is easier to use is the 
"begin...while...repeat" loop, this continues an operation
until a variable is not true:

  : foo begin ?dup while dup . cr 1- repeat ;
  3 foo 3 ( <-- prints 3 )
  2       ( <-- then 2 )
  1       ( <-- then 1 )

; ==== Help: Control Structures 9/10 ===========================
eForth provides another control structure, the "for...next" loop
which allows the Forth programmer to create counted loops. The
"for" loop takes a single variable, it stores this variable on
the return stack (which will be covered next) and decrements the
variable, until it is zero, at which point it exits (but still
executes for the final zeroth case). The word 'r@' is used to
push a copy of the top of the return stack, where the for loop
keeps the conditional value.

  : foobar for r@ . cr next ; 
  3 foobar 3 ( <-- prints 3 )
  2
  1
  0 ( <-- prints zero as well! )

; ==== Help: Control Structures 10/10 ==========================
The "for...next" construct can be modified with the "aft" and
"then" construct, which is not executed on the first run of the
loop.

  : quux for -9 . aft r@ . then -8 . cr then ;
  decimal 3 quux -9 -8 ( for...aft and then...next is run )
  2 -8 ( aft...then and then...next is run )
  1 -8 ( ... )
  0 -8 ( ... )

This concludes the control structure section, it should be
noted that the control structures are defined words themselves
again, it is possible to redefine and add your own control
structures. How this is done will be covered later.

; ==== Help: Return Stack ======================================
All Forth systems have at least two stacks along with main 
memory, they can be implemented in hardware like with this Forth
or in software. One stack is used to pass data to functions and
to return their results, the data or variable stack, which we
have already dealt with. The other stack is used for control
flow and as a place for temporarily storing variables.

Data can be moved to and from the return stacks, but this must
be done very carefully and only within word definitions, 
leaving values on the stack by accident can cause the 
interpreter to crash. 

Some looping constructs use the return stack as well to store
their loop index, and the 'throw/catch' mechanism manipulates
control flow a lot.
; ==== Help: Return Stack ======================================
Some words for manipulating the return stack are as follows,
notice the stack comments describe both stacks here:

  >r    ( u --, R: -- u : move variable to return stack )
  r>    ( -- u, R: u -- : move variable from return stack )
  rdrop ( R: u -- : remove topmost variable from return stack )
  r@    ( -- u, R: u -- u : copy topmost return stack item )








; ==== Help: Control Structures ================================















; ==== Help: TO DO =============================================

* Describe the system internals
* eForth primitives
* Make, Doer, Create, Does>
* Do word glossary, with one block per word
* Vocabularies
* Block Word set
* Peripheral access word set
* Throw/Catch
* How Forth is implemented





; ==== Block Editor Help 1/5 ===================================

The traditional way to store Forth source code and data is as
Forth blocks, a block is a contiguous array of 1024 characters,
which can be saved to non-volatile storage with the 'block'
word set. On more modern Forth systems, especially hosted ones,
the file access word set is used instead.

A Forth that does not have a file system, such as this one,
usually has a primitive block editor. An editor can be defined
in just a handful of (non-standard) words.

By default the editor words are not in the Forth search order,
the words in the editor vocabulary would conflict with Forth
words (and with hexadecimal numbers). To load the block editor
execute the 'editor' Forth word. Load initial block with '0 b'.
; ==== Block Editor Help 2/5 ===================================
The block editor is a prime example of Forth simplicity, it
both simplifies the problem of editing text and reuses the
Forth interpreter to define a new command language. Each command
in the block editor simply a Forth word which takes its
arguments off the stack, and a line is a fixed width 64
character array, a block can contain 16 lines of text. An empty
line consists entirely of spaces, which the interpreter will
ignore if it were to evaluate the block.

The 'editor' word replaces the current vocabulary with the
editor vocabulary and switches the number base for input and
output to decimal. The commands are terse words, only one or
two characters in length.


; ==== Block Editor Help 3/5 ===================================
The third element of the block editor is the elegant, if some-
what limited, block word set. It completely abstracts aways the
task of retrieving data from mass storage and saving modified
data back to it. The mass storage is divided into blocks which
can be loaded by their block number. Block numbers in this
system start at 0 and go to $FFFE, $FFFF is an invalid block
number.

The block word set is quite small, and the editor uses the
words; 'block', 'update', 'save-buffers', 'list', 'load',
and '+block'. The variable 'blk', which contains the last
block loaded (and listed) is also used. Most editor commands
are minor modifications on the behavior of these words.


; ==== Block Editor Help 4/5 ===================================
The workhorse of the word set is 'block', it takes a block
number and if that block number is not currently loaded into a
block buffer (this system only has one block buffer available)
it checks to see if the current block is marked as dirty (with
the 'update' word). If it has been it first flushes the dirty
block to mass storage, then loads the desired block from it. It
then returns a pointer to the beginning of the block buffer. It
also updates the 'blk' variable to contain the block number
just loaded.

The 'save-buffers' saves all buffers to disk and deallocates
any blocks (by storing $FFFF in 'blk'). 'list' displays the
contents of a block, 'load' evaluates a block and '+block'
moves to a block relative to the currently loaded one.

; ==== Block Editor Help 5/5 ===================================
A quick recap of the block words:

block        ( k -- u : load block into buffer )
blk          ( -- a : last loaded block )
+block       ( k -- : load block relative to 'blk' )
save-buffers ( -- : flush block to disk, put -1 in 'blk' )
list         ( k -- : display block )
load         ( k -- : evaluate a block )

These can be used to define simple editor commands, such as:

  : b block drop ;
  : n 1 +block b ;
  : u update ;

; ==== Block Editor Commands 1/2 ===============================

'#' indicates a numeric argument the command takes:
      n    move to next block
      p    move to previous block
    # d    delete line in current block
      x    erase current block (overwrite with spaces)
      e    evaluate current block
    # i    insert line
 # #2 ia   insert at line #2 at column #
      q    quit editor loop
    # b    load block number
      s    save block and write it out
      u    update block
      w    list editor commands
      q    back to Forth interpreter
; ==== Block Editor Commands 2/2 ===============================


      l    re-list current block
    # c    paste copy buffer to line #
    # y    yank line # into copy buffer
 # #2 ct   copy line # to line #2
    # ea   evaluate line #
 # #2 sw   swap lines # and #2

The editor is simple to use and understand, but for large
documents and programs can quite difficult to use. This block
editor was derived from the Retro Forth block editor, available
at: <http://retroforth.org/pages/?PortsOfRetroEditor>


; ==== TO DO ===================================================

* Describe the Nexys 3 system, the system on a chip, the
* List the instruction set, registers, words defined, eForth
* Make words for databases using blocks
* Add source code for everything to this block file
* Add a program listing, perhaps in the first block, it could
set variables relating to this document
* Turn this into a markdown document,
* The eForth primitives should be described.
* Add the symbols generated by the compiler (h2.sym) to block
* Extra words could be stored in these blocks, freeing up
space for the user
* Better tools for editing this file would help a lot.
* Move the block editor to this file
* Full glossary: 1 block per word definition
; ==== Empty Block =============================================















; ==== Glossary ================================================















; ==== <  ( n1 n2 -- f : signed less than ) ====================
Signed less than.














; ==== <>  ( u1 u2 -- f : not equal ) ==========================
Not equal to.














; ==== <#  ( -- : prepare numeric output ) =====================
This is part of the mechanism for pictured numeric output, 
which should be used from within a word definition only.













; ==== =  ( u1 u2 -- f : equality of two numbers ) =============
This is an assembly instruction for testing whether two numbers
are equal. 













; ==== >  ( n1 n2 -- f : signed greater than ) =================















; ==== -  ( n1 n2 -- n : twos compliment subtraction ) =========
This is a word performs subtraction on two numbers in twos
compliment format. 













; ==== ,  ( u -- : compile value into dictionary ) =============















; ==== ;  ( -- : terminate a word definition ) =================
This word terminates a word definition, linking the newly formed
word into the dictionary. It is an immediate word and performs
some basic checking to make sure control structures match up. It
writes an 'exit' into the word and switches the state back into
command mode. It has another minor usage, if called within
command it throws -56, for QUIT. This can be used within a block
to stop execution of it, if 'thru' is used to load block, this
error is ignored.

Example:

   : 2+ 2 + ; 
   : count dup 1+ swap c@ ;
   :noname 9 . ; execute ( <-- prints 9 )

; ==== :  ( -- ; <string> : start a word definition ) ==========
Start a word definition. 














; ==== !  ( u a -- : store 'u' at address 'a' ) ================
Store a value in at an address, this is also used to write to
the memory mapped peripheral registers.













; ==== ?  ( a -- : print value at address ) ====================
Print a value out from an address, this is effected by the
output radix stored in 'base'. This word uses the area between
PAD area and the end of the dictionary.












; ==== /  ( n1 n2 -- q: divide n1 by n2 ) ======================
Signed and floored division of the second value on the stack by
the first. This will throw and error if the divisor is zero.
This is a particularly slow operation, as the H2 CPU does not
a built in division operation.











; ==== .  ( n -- : print number out in current base ) ==========
Print a space, then a signed number (if the output radix is ten
then a '-' is printed before the number if it is less than zero,
if the output radix is not ten, then it is just printed out as
an unsigned number). This word uses the area after the
dictionary and before the start of the pad area, it is not a
reentrant function.









; ==== ."  ( -- ; <string> : compile string into word ) ========
This word is an immediate word that compiles a string into a
word definition (it should only be used from within a word
definition). When the word is run it will print out the string.

The string is terminated by a double quote.










; ==== .(  ( -- ; <string> : print out line until ')' ) ========
This word prints out a string until the matching ')' is 
encountered. It is not an immediate word.













; ==== '  ( -- xt ; <string> : return a word execution token ) =
This word parses the next word in the input stream and returns
its execution token if the word is found. It is an immediate
word. If the word is not found it throws an exception.












; ==== (  ( -- ; <string> : comment until ')' ) ================
This is an immediate word used for comments, it discards all
input until the matching ')' is encountered. It can be used
within blocks.












; ==== )  ( -- : do nothing ) ==================================
This is a word that does nothing. It is an immediate word. It
has no function.













; ==== [  ( -- : change compile state to command mode ) ========
An immediate word for changing the state of the interpreter loop
into the command state. It can be used within a word definition.













; ==== ]  ( -- : change compile state to compile mode ) ========
A normal, compiling word, which turns the interpreter state into
compile mode. Words and numbers after (apart from immediate
words) are compiled into the dictionary.












; ==== @  ( a -- u : load value from address ) =================
Retrieve a value from memory location 'a'. It can be used to
read from the memory mapped registers as well.













; ==== $"  ( -- ; <string> : compile string into word ) ========
This is an immediate word that can only be used in a word
definition, it compiles a string into the dictionary, when it
runs it pushes the address of the counted string compiled into
the word.











; ==== *  ( u1 u2 -- u3 : multiple two numbers ) ===============
Multiply two numbers and push the result onto the stack. This is
a slow operation, as there is not a built in multiply operation.













; ==== \  ( -- ; <string> : comment until end of line ) ========
Comment until end of input line, this word works within blocks
as well, where it is a comment until the end of the block line.
It is an immediate word.












; ==== #  ( u -- u : extract numeric character from u ) ========















; ==== #>  ( u -- b u : return converted number string ) =======















; ==== +  ( u1 u2 -- u3 : add two numbers together ) ===========















; ==== +!  ( u a -- : add 'u' to value 'a' ) ===================















; ==== 0<  ( n -- f : 'n' less than zero? ) ====================















; ==== 0<>  ( n -- f : 'n' not equal to zero? ) ================















; ==== 0=  ( n -- f : 'n' equal to zero? ) =====================















; ==== 0>  ( n -- f : 'n' greater than zero? ) =================















; ==== 1-  ( u -- u : decrement u ) ============================















; ==== 1+  ( u -- u : increment u ) ============================















; ==== 1+!  ( a -- : increment value at 'a' by one ) ===========















; ==== 2!  ( u1 u2 a -- : store u1 and u2 at two cells ) =======















; ==== 2/  ( u -- u : divide 'u' by two ) ======================















; ==== 2@  ( a -- u1 u2 : retrieve two cells ) =================















; ==== 2*  ( u -- u : multiply 'u' by two ) ====================















; ==== 2drop  ( u u -- : drop two values from the stack ) ======















; ==== 2dup  ( u1 u2 -- u1 u2 u1 u2 : duplicate two values ) ===















; ==== abort  ( ? --, R: ? -- ? : throw abort exception ) ======















; ==== abort" ( ? --, R: ? -- ?, <string>: abort with string ) =















; ==== abs  ( n -- u : absolute value of a number ) ============















; ==== accept  ( b u -- b u : accept a line ) ==================















; ==== aft  ( -- : part of for...aft...then...next ) ===========















; ==== again  ( -- : part of begin...again loop ) ==============















; ==== align  ( -- : align dictionary pointer ) ================















; ==== aligned  ( b -- a : align up an address ) ===============















; ==== allot  ( n -- : allocate 'n' bytes ) ====================















; ==== and  ( u1 u2 -- u3 : bitwise and of two numbers ) =======















; ==== at-xy  ( x y -- : place cursor at column 'x', row 'y' ) =















; ==== background  ( color -- color : change to background ) ===















; ==== base  ( -- a : address of base radix ) ==================















; ==== b/buf  ( -- u : number of bytes in a block ) ============















; ==== begin  ( -- : start begin...until/again loop ) ==========















; ==== bl  ( -- u : value for space character ) ================















; ==== black  ( -- u : color for black ) =======================















; ==== blank  ( b u -- : fill array with blanks ) ==============















; ==== blk  ( -- a : address of last loaded block ) ============















; ==== block  ( u -- a : perform block operation ) =============















; ==== +block ( n -- u : return block number relative to blk ) =















; ==== blue  ( -- u : return color for blue ) ==================















; ==== >body  ( xt -- a : move to body of created word ) =======















; ==== border  ( -- a : variable for list display control ) ====















; ==== c,  ( c -- : compile character into dictionary ) ========















; ==== c!  ( c b -- : store 'c' at 'b' ) =======================















; ==== c@  ( b -- c : retrieve 'c' from 'b' ) ==================















; ==== catch  ( xt -- n | 0 : catch possible exception ) =======















; ==== ccitt  ( crc c -- crc : compute CRC step ) ==============















; ==== cell-  ( a -- a : decrement address by single cell ) ====















; ==== cell+  ( a -- a : increment address by single cell ) ====















; ==== cells  ( n -- n : convert byte to cell number ) =========















; ==== char  ( -- c ; <string> : parse character ) =============















; ==== [char]  ( -- ; <string> : compile character literal ) ===















; ==== cmove  ( b b u -- : move block memory ) =================















; ==== color  ( u -- : change display color ) ==================















; ==== compile ( -- : compile next word into dictionary ) ======















; ==== [compile]  ( -- xt : compile next immediate word ) ======















; ==== compile,  ( xt -- : compile execution token ) ===========















; ==== conceal  ( -- : emit stars instead of characters ) ======















; ==== console  ( -- : UART only mode ) ========================















; ==== constant  ( n -- ; <string> : create constant ) =========















; ==== count  ( a -- b c : retrieve next character in string ) =















; ==== cpu-id  ( -- u : return CPU-ID ) ========================















; ==== cr  ( -- : emit new line ) ==============================















; ==== crc  ( b u -- u : perform CRC over array ) ==============















; ==== create  ( -- ; <string> : make 'created' word ) =========















; ==== decimal  ( -- : switch radix to decimal ) ===============















; ==== dm+  ( a u -- u : print out section of memory ) =========















; ==== dnegate  ( d -- d : negate a double value ) =============















; ==== doer  ( -- ; <string> : create a 'doer' word ) ==========















; ==== does>  ( -- : start 'does' section of word ) ============















; ==== drop  ( u -- : drop a value ) ===========================















; ==== dump  ( a u -- : dump a section of memory ) =============















; ==== dup  ( n -- n n : duplicate a value ) ===================















; ==== ?dup  ( n -- n n | 0 : duplicate value if not zero ) ====















; ==== else  ( -- : if...else...then ) =========================















; ==== emit  ( c -- : emit a character ) =======================















; ==== empty-buffers  ( -- : deallocate block buffer ) =========















; ==== evaluate  ( a u -- : evaluate block of memory ) =========















; ==== execute  ( xt -- : execute an execution token ) =========















; ==== @execute  ( a -- : execute token at 'a' if non-zero ) ===















; ==== exit  ( -- : exit from word ) ===========================















; ==== expect  ( b u -- : accept, but store 'u' in span ) ======















; ==== file  ( -- : file transfer mode ) =======================















; ==== fill  ( b u c -- : fill area of memory with 'c' ) =======















; ==== find  ( a -- pwd 1 | pwd -1 | a 0 : find word ) =========















; ==== flash  ( -- : add flash words to search order ) =========















; ==== flush  ( -- : write dirty blocks, empty-buffers also ) ==















; ==== for  ( -- : part of for...next loop ) ===================















; ==== forth  ( -- : set minimal search order ) ================















; ==== forth-wordlist  ( -- voc : return Forth vocabulary ) ====















; ==== get-order  ( -- vn...v0 u : get search order ) ==========















; ==== green  ( -- u : green color value ) =====================















; ==== here  ( -- a : return dictionary address ) ==============















; ==== hex  ( -- : set numeric radix to hexadecimal ) ==========















; ==== hi  ( -- : initialize and login to system ) =============















; ==== hld  ( -- : hold variable for pictured numeric output ) =















; ==== hold  ( c -- : put byte into numeric output string ) ====















; ==== ien  ( f -- f : set interrupt flag ) ====================















; ==== ien?  ( -- f : are interrupts enabled? ) ================















; ==== if  ( -- : part of if...then/if...else...then) ==========















; ==== immediate  ( -- : make last defined word immediate ) ====















; ==== >in  ( -- a : index into parse input at address ) =======















; ==== index  ( k1 k2 -- : print first line of block range ) ===















; ==== interactive  ( -- : interactive I/O mode ) ==============















; ==== interpret  ( ??? a -- ??? : interpret word/number ) =====















; ==== invert  ( u -- u : bitwise invert ) =====================















; ==== io!  ( -- : initialize IO channels ) ====================















; ==== key  ( -- c : block until character read in ) ===========















; ==== key?  ( -- c -1 | 0 : non-blocking character read ) =====















; ==== last  ( -- pwd : last defined word ) ====================















; ==== led!  ( u -- : write value to LEDs ) ====================















; ==== list  ( k -- : list block ) =============================
The word list loads block 'k' from disk and display the contents
of this block on the screen. It displays the block as 16 lines
with a column width of 64. The display format is controlled by
the 'border' variable, if true it 'list' displays the line
number and a border around the block, if false, then it just
display the block line by line without formatting. It is true
by default.








; ==== literal  ( n -- : compile literal into dictionary ) =====
This is an immediate word that compiles a number into the
dictionary. A number takes up between one and two cells in the
dictionary (negative numbers take up two space, positive only
one). It is a compile only word.











; ==== load  ( k -- : load and execute block ) =================















; ==== loaded  ( -- a : variable, true if boot block loaded ) ==















; ==== lshift  ( u1 u2 -- u3: logical left shift u1 by u2 ) ====
This performs a logical left shift on 'u1' by 'u2'.














; ==== make  ( -- : make part of make/doer words ) =============















; ==== max  ( n1 n2 -- n3: maximum of two numbers ) ============
This returns the maximum of two numbers.














; ==== message  ( u -- : type line from block ) ================















; ==== min  ( n1 n2 -- n3: minimum of two numbers ) ============
This returns the minimum of two signed numbers.














; ==== m/mod  ( d n -- r q : signed divide / modulo ) ==========















; ==== mod  ( n1 n2 -- r : remainder of n1 divided by n2 ) =====















; ==== /mod  ( n1 n2 -- r q : remainder/divisor ) ==============















; ==== ms  ( u -- : wait for 'u' milliseconds ) ================
'ms' waits for 'u' milliseconds with a busy loop. It is
predicated on the system running at 100MHz and will need to be
modified if the system frequency changes.












; ==== negate  ( n -- n : negate a number ) ====================















; ==== next  ( -- : part of for...next loop ) ==================















; ==== nip  ( n1 n2 -- n1 : remove second value on stack ) =====















; ==== :noname  ( -- xt : start anonymous function ) ===========
The ':noname' word is an immediate word that allows the
creation of words that do not have names, or an anonymous
function. The word can be executed with the 'execute' function.












; ==== nop  ( -- : no-operation - do nothing ) =================
This is an assembly instruction that is inlined into a word
when it is compiled into it, it does nothing, it can be used
for timing purposes or to work around the optimizer.












; ==== nuf?  ( -- f : true if 'cr' character pressed ) =========















; ==== number?  ( b u -- n f : is string a number ) ============















; ==== .ok  ( -- : print okay prompt ) =========================
'.ok' prints out 'ok' after the successful execution of an
input line when the Forth interpreter is in the command mode,
the prompt is suppressed when in compile mode.












; ==== or  ( u1 u2 -- u3: bitwise or of two numbers ) ==========















; ==== over  ( n1 n2 -- n1 n2 n1 : duplicate over ) ============















; ==== pack$  ( b u a -- a : pack string into address ) ========















; ==== pad  ( -- a : return address into pad area ) ============















; ==== page  ( -- : clear page ) ===============================















; ==== parse  ( b u c -- b u delta : parse string out ) ========















; ==== pick  ( un...u0 u -- un...u0 u u : pick value ) =========















; ==== query  ( -- : get line of input ) =======================















; ==== quit  ( -- : interpreter loop ) =========================















; ==== >r  ( u --, R: -- u : move value to return stack ) ======















; ==== r>  ( -- u, R: u --: move value from return stack ) =====















; ==== r@  ( -- u : R: u -- u: copy top of return stack ) ======















; ==== random  ( -- u : random number ) ========================















; ==== rdrop  ( --, R: u -- : drop a value from return stack ) =















; ==== recurse  ( -- : recursively call current word ) =========















; ==== red  ( -- u : red color ) ===============================















; ==== repeat  ( -- : part of begin...while...repeat ) =========















; ==== rot  ( n1 n2 n3 -- n2 n3 n1 : rotate three items ) ======















; ==== -rot  ( n1 n2 n3 -- n3 n1 n2 : rotate three items ) =====















; ==== rp@  ( -- u : return stack depth ) ======================















; ==== rpick  ( n -- u, R: un...u0 : pick return stack value ) =















; ==== rshift  ( u1 u2 -- u3 : logical right shift u1 by u2 ) ==















; ==== .s  ( -- : print out variable stack ) ===================
This word is used for debugging, it prints out the entire
variable stack up to the current variable stack depth. It uses
the area between the end of the dictionary and the start of the
PAD area. It is not a reentrant function.











; ==== #s  ( u -- 0 : repeat '#' until 0 ) =====================















; ==== save-buffers  ( -- : save dirty blocks ) ================















; ==== screens  ( k1 k2 -- : list screens k1 to k2 ) ===========















; ==== screen-saver  ( -- : start screen-saver ) ===============















; ==== see  ( -- ; <string> : decompile word ) =================















; ==== segments!  ( u -- : display 'u' on LED displays ) =======
Segments writes a single 16-bit value to the four seven segment
displays on the board. This can be used to display a single
cell as a hexadecimal value.












; ==== set-order  ( vn...v0 u -- : set search order ) ==========
This word sets the sort order.














; ==== sgr  ( u -- : set ANSI terminal SGR attribute ) =========















; ==== sign  ( n -- : hold '-' if n negative ) =================















; ==== source  ( -- a u : get source string ) ==================















; ==== source-id  ( -- 0 | -1 : identify input source ) ========















; ==== sp@  ( -- u : variable stack depth ) ====================















; ==== space  ( -- : emit space character ) ====================
'space' emits a single space.














; ==== spaces  ( n -- : emit 'n' spaces ) ======================
'spaces' emits 'n' number of spaces.














; ==== span  ( -- a : character count from expect, variable ) ==















; ==== state  ( -- a : state variable ) ========================















; ==== store  ( u a -- u : store 'u' at 'a' ) ==================















; ==== =string  ( a1 u2 a1 u2 -- f : string equality ) =========















; ==== /string  ( b u1 u2 -- b u : advance string by u2 ) ======















; ==== swap  ( u1 u2 -- u2 u1 : swap two variables ) ===========















; ==== switches  ( -- u : get state of switches ) ==============















; ==== then  ( -- : part of if...then or if...else...then ) ====















; ==== throw  ( ? n -- ?, R: ? -- ? : throw exception ) ========















; ==== thru  ( k1 k2 -- : load from k1 to k2 ) =================















; ==== timer  ( -- u : get value of timer ) ====================















; ==== timer!  ( -- : set timer ) ==============================















; ==== tuck  ( n1 n2 -- n2 n1 n2 : tuck value ) ================















; ==== type  ( b u -- : print out a string ) ===================
'type' prints out a string.














; ==== u<  ( u1 u2 -- f: unsigned less than ) ==================
Unsigned less than of two numbers, this is an assembly operation
that is inlined into a word definition. 













; ==== u>  ( u1 u2 -- f: unsigned greater than ) ===============
Unsigned greater than, this is not an assembly instruction.














; ==== u>=  ( u1 u2 -- f: unsigned greater or equal to ) =======















; ==== u.  ( u -- : print out number in current base ) =========















; ==== um*  ( u u -- ud : unsigned multiply ) ==================
Unsigned multiple, it takes two single cell numbers and returns
an unsigned double.













; ==== um+  ( u u -- u carry : unsigned add with carry ) =======
Unsigned addition with carry, this word is used to implement
the majority of the arithmetic operations, although it is not
very useful directly.












; ==== um/mod  ( ud u -- ur uq : unsigned modulo divide ) ======
Unsigned division of an unsigned double cell number by a single
cell number and leaves the remainder, 'ur' and the quotient,
'uq'. This is a slow operation as it is not implemented as an
instruction within the H2 CPU. It will throw and exception if
the divisor is zero. The word is used to implement the other
division and modulus operations.









; ==== until  ( -- : begin...until loop ) ======================















; ==== update  ( -- : mark last loaded block as dirty ) ========
Marks the last loaded block as being dirty (the last loaded
block block number is stored in the variable 'blk'). A dirty
block will be written to disk on when 'flush', 'save-buffers',
or another block is loaded from disk. 











; ==== u.r  ( u +n -- : print u right justified by +n ) ========















; ==== variable  ( -- ; <string> : create a new variable ) =====
'variable' parses the next space delimited string from the
input string and makes a new named variable. The variable will
be initialized with zero, although this is not guaranteed to be
the case with all Forths. Variables are just normal words that
push a location onto the dictionary of where the variable is
stored, it can be accessed with the '!' and '@' words, only
one cell of storage space is reserved. The created word is
not an immediate word.







; ==== ver  ( -- u : push version information ) ================
Pushes the version number of the eForth implementation. The
format of the version is the major version is stored in the
upper byte and the minor version information is stored in the
lower byte. 

The minor version number changes on minor updates, the major
version changes when there are major updates in how the
interpreter works that could potentially break code.







; ==== while  ( -- : begin...while...repeat loop ) =============















; ==== white  ( -- u : push code for white color ) =============















; ==== within  ( u lo hi -- f : is u within a range? ) =========















; ==== word  ( c -- a; <string> : parse a word ) ===============















; ==== words  ( -- : list all words in dictionary ) ============















; ==== xor  ( u1 u2 -- u : bit wise exclusive or ) =============
Bitwise exclusive or of two numbers, this is an assembly word
that is inlined into a word definition when compiled into it.













