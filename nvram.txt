\ ==== Boot Block ==============================================
-1 loaded !














; ==== Short Help ==============================================
This is a subroutine threaded Forth, based on eForth. The
starting base in in hexadecimal. A tutorial, word glossary and
extra code is stored in block storage. A short list of commands
follows ('#' are numbers):
 
  words       list all Forth words 
  see         decompile the next word in the input stream
  # #2 index  get descriptive titles for blocks from '#' to '#2'
  # list      list block number '#'
  # load      execute code in block '#'
  # #2 thru   execute code in blocks '#' to '#2'




; ==== Forth Error Messages: 1/4 ===============================
  -1 ABORT
  -2 ABORT"
  -3 stack overflow
  -4 stack underflow
  -5 return stack overflow
  -6 return stack underflow
  -7 do-loops nested too deeply during execution
  -8 dictionary overflow
  -9 invalid memory address
 -10 division by zero
 -11 result out of range
 -12 argument type mismatch
 -13 undefined word
 -14 interpreting a compile-only word
 -15 invalid FORGET
; ==== Forth Error Messages: 2/4 ===============================
 -16 attempt to use zero-length string as a name
 -17 pictured numeric output string overflow
 -18 parsed string overflow
 -19 definition name too long
 -20 write to a read-only location
 -21 unsupported operation
 -22 control structure mismatch
 -23 address alignment exception
 -24 invalid numeric argument
 -25 return stack imbalance
 -26 loop parameters unavailable
 -27 invalid recursion
 -28 user interrupt
 -29 compiler nesting
 -30 obsolescent feature
; ==== Forth Error Messages: 3/4 ===============================
 -31 >BODY used on non-CREATEd definition
 -32 invalid name argument (e.g., TO xxx)
 -33 block read exception
 -34 block write exception
 -35 invalid block number
 -36 invalid file position
 -37 file I/O exception
 -38 non-existent file
 -39 unexpected end of file
 -40 invalid BASE for floating point conversion
 -41 loss of precision
 -42 floating-point divide by zero
 -43 floating-point result out of range
 -44 floating-point stack overflow
 -45 floating-point stack underflow
; ==== Forth Error Messages: 4/4 ===============================
 -46 floating-point invalid argument
 -47 compilation word list deleted
 -48 invalid POSTPONE
 -49 search-order overflow
 -50 search-order underflow
 -51 compilation word list changed
 -52 control-flow stack overflow
 -53 exception stack overflow
 -54 floating-point underflow
 -55 floating-point unidentified fault
 -56 QUIT
 -57 exception in sending or receiving a character
 -58 [IF], [ELSE], or [THEN] exception


; ==== Description of this file ================================
The next screens contain extra code that can be loaded into the
interpreter if needed. Some of the standard Forth words are
placed here instead of in the image to save on space.

The blocks should be loaded in order unless otherwise stated.

This file is first converted by a utility into a fixed width
format, which can then be loaded onto the target board with
the same utility used to uploaded the bitfile to the FPGA.

Form feeds are used to mark the boundaries between blocks,
this does not have any special significance and is only there
to make editing easier. Line lengths are limited to 64
characters wide, each block contains 16 lines.

; ==== Scratch Block ===========================================















\ ==== Block Editor 1/2 ========================================
( Block Editor: There is a help section later on )
variable editor-voc 0 editor-voc ! forth
: editor decimal editor-voc 1 set-order ;
get-order editor-voc swap 1+ set-order
$40 constant c/l $10 constant l/b
: (block) blk @ block ;
: (check) dup b/buf c/l / u>= if -24 throw then ;
: (line) (check) c/l * (block) + ;
: b block drop ;
: l blk @ list ;
: n  1 +block b l ;
: p -1 +block b l ;
: d (line) c/l blank ;
: x (block) b/buf blank ; 
: s update save-buffers ; 
\ ==== Block Editor 2/2 ========================================
: q forth save-buffers ;
: e forth blk @ load editor ;
: ia c/l * + (block) + source drop >in @ +
  swap source nip >in @ - cmove [compile] \ ;
: i 0 swap ia ;
: u update ;
: w words ;
: yank pad c/l ;
: c (line) yank >r swap r> cmove ;
: y (line) yank cmove ;
: ct swap y c ;
: ea (line) c/l evaluate ;
: sw 2dup y (line) swap (line) swap c/l cmove c ;
forth

\ ==== Assembler word set ======================================
variable assembler-voc
bl parse rdrop pad pack$ find drop assembler-voc !
: assembler assembler-voc 1 set-order ;
: ;code assembler ; immediate
: code [compile] : assembler ;
get-order assembler-voc swap 1+ set-order
: end-code forth [compile] ; ; immediate
: words words ;
: forth forth ;
forth





\ ==== CORDIC 1/2 ==============================================
variable lookup -1 cells allot ( 16 values )
$3243 , $1DAC , $0FAD , $07F5 , $03FE , $01FF , $00FF , $007F ,
$003F , $001F , $000F , $0007 , $0003 , $0001 , $0000 , $0000 ,

: arshift ( n u -- n : arithmetic right shift )
  2dup rshift >r swap $8000 and 
  if $10 swap - -1 swap lshift else drop 0 then r> or ;

$26DD constant cordic_1K $6487 constant pi/2

variable tx 0 tx ! variable ty 0 ty ! variable tz 0 tz !
variable x  0  x ! variable y  0  y ! variable z  0  z !
variable d  0  d ! variable k  0  k !


\ ==== CORDIC 2/2 ==============================================
( CORDIC: valid in range -pi/2 to pi/2, arguments are in fixed )
( point format with 1 = 16384, angle is given in radians.  )
: cordic ( angle -- sine cosine )
  z ! cordic_1K x ! 0 y ! 0 k !
  $10 begin ?dup while
    z @ 0< d !
    x @ y @ k @ arshift d @ xor d @ - - tx !
    y @ x @ k @ arshift d @ xor d @ - + ty !
    z @ k @ cells lookup + @ d @ xor d @ - - tz !
    tx @ x ! ty @ y ! tz @ z !
    k 1+!
    1-
  repeat y @ x @ ;
: sin cordic drop ; 
: cos cordic nip ;
\ ==== Login Code 1/2 ==========================================
\ Login and user management system 
: generate count dup >r crc r> ccitt ; ( b -- u )
: .user     ." user>" space ; ( -- )
: .password ." password>" space ; ( -- )
variable user0 0 user0 !
: mk.user ( --; <string1>, <string2> )
  here user0 @ , user0 ! here 0 , bl word count 1+ allot align
  drop bl word generate swap ! ;
: ls.user ( -- : list all users in user database )
  cr user0 @ 
  begin dup while dup 2 cells + space count type cr @ repeat
  drop cr ;
: find.user ( a -- u | 0 : find user in database, return hash )
  >r user0 @ begin dup while dup 2 cells + count r@ count
  =string if rdrop exit then @ repeat rdrop drop 0 ;
\ ==== Login Code 2/2 ==========================================
: (password) ( u --, <string> )
  >r begin .password query bl word cr generate
  r@ = until rdrop ;
: fake .password query bl word drop cr ;
: (user) 
  begin .user query bl word cr find.user ?dup until ;
: retry ( xt -- : retry word until it succeeds )
  >r begin r@ catch 0= until rdrop ;
: user?     ' (user)     retry ;
: password? ' (password) retry ;
: hide-all 0 1 set-order ;
: login hide-all
  cr user? cell+ @ conceal password? interactive forth ;
mk.user guest guest     mk.user archer dangerzone
mk.user lana  sterling  mk.user cyril  figgis
\ ==== Extra Code 1/7 ==========================================
: 2+ 2 + ;                       ( n -- n )
: 2- 2 - ;                       ( n -- n )
: >= < invert ;                  ( n n -- f )
: simulation? cpu-id $cafe <> ; ( -- f : are we in the matrix? )
: 0<= 0> 0= ;                    ( n n -- f )
: 0>= 0< 0= ;                    ( n n -- f )
: not -1 xor ;                   ( n -- n )
: dabs dup 0< if dnegate then ;  ( d -- d )
: d+  >r swap >r um+ r> r> + + ; ( d d -- d )
: d=  >r swap r> = >r = r> and ; ( d d -- f )
: d<> d= 0= ;                    ( d d -- f )
: roll  dup 0> if swap >r 1- recurse r> swap else drop then ;
: ?exit if rdrop then ;          ( n --, R: n -- n | )
: 2rdrop r> rdrop rdrop >r ;     ( R n n -- )
: 2. swap . . ;                  ( n n -- )
\ ==== Extra Code 2/7 ==========================================
: m* 2dup xor 0< >r abs swap abs um* r> if dnegate then ;
: */mod  >r m* r> m/mod ;  ( n n n -- r q )
: */  */mod nip ;          ( n n n -- q )
: s>d dup 0< ;             ( n -- d : single to double )
: holds begin dup while 1- 2dup + c@ hold repeat 2drop ;
: binary  2 base ! ;                       ( -- )
: octal  8 base ! ;                        ( -- )
: .base base @ dup decimal base ! ; ( -- )
: only -1 set-order ;
: also get-order over swap 1+ set-order ;
: previous get-order swap drop 1- set-order ;
: buffer block ; ( k -- a )
: bye [ 0 , ] ;
: enum dup constant 1+ ; ( n --, <string> )
: logical 0= 0= ;     ( n -- f )
\ ==== Extra Code 3/7 ==========================================
: square dup * ;      ( n -- )
: limit rot min max ; ( n lo hi -- n )
: odd 1 and logical ; ( n -- )
: even odd invert ;   ( n -- )
: nor or invert ;     ( u u -- u )
: nand and invert ;   ( u u -- u )
: bell 7 emit ;       ( -- )
: under >r dup r> ;   ( n1 n2 -- n1 n1 n2 )
: 2nip >r >r 2drop r> r> ; ( n1 n2 n3 n4 -- n3 n4 )
( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
: 2over >r >r 2dup r> swap >r swap r> r> -rot ;
: 2swap >r -rot r> -rot ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
: 2tuck 2swap 2over ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 n3 n4 )
: 4drop 2drop 2drop ; ( n1 n2 n3 n4 -- )
: trip dup dup ; ( n -- n n n )
\ ==== Extra Code 4/7 ==========================================
: log  >r 0 swap ( u base -- u )
  begin swap 1+ swap r@ / dup 0= until
  drop 1- rdrop ;
: log2 0 swap ( u -- u )
  begin swap 1+ swap   2/ dup 0= until
  drop 1- ;
: average um+ 2 um/mod nip ; ( u u -- u )
: <=> 2dup > if 2drop -1 exit then < ;
: bounds over + swap ;
: 2, , , ; ( n n -- )
: tab 9 emit ; ( -- )
: drup drop dup ; ( n1 n2 -- n1 n1 )
: lsb $ff and ; ( u -- u )
: --> 1 +block load ;
: scr blk ;
\ ==== Extra Code 5/7 ==========================================
: signum ( n -- -1 | 0 | 1 : Signum function )
  dup 0> if drop  1 exit then
      0< if      -1 exit then
      0 ;
: >< dup 8 rshift swap 8 lshift or ; ( u -- u : swap bytes )
: #digits dup 0= if 1+ exit then base @ log 1+ ;
: ** ( n u -- n )
  ?dup if 
    over >r 
    begin 
      dup 1 > 
    while 
      swap r@ * swap 1- 
    repeat rdrop drop
  else logical 1 and then ; 
\ ==== Extra Code 6/7 ==========================================
: b. base @ swap 2 base ! u. base ! ; ( u -- )
: h. base @ swap hex u. base ! ;      ( u -- )
: o. base @ swap 8 base ! u. base ! ; ( u -- )
: d. base @ swap decimal . base ! ;   ( n -- )
: @bits swap @ and ;                  ( a u -- u )
: ?\ if [compile] \ then ; immediate
: ?( if [compile] ( then ; immediate ( )
: defined? ( -- pwd -1 | 0, <string> : is word defined? )
  bl word find if -1 else drop 0 then ; 
: ?if compile dup [compile] if ; immediate
: ?dup-if compile ?dup [compile] if ; immediate
: >body ( dup @ $4000 or <> if 31 -throw then ) cell+ ;



\ ==== Extra Code 7/7 ==========================================
: screens ( k1 k2 -- : list blocks k1 to k2 )
	over -
	for
		dup . dup list 1+ nuf? if rdrop drop exit then
	next drop ;










\ ==== Roulette ================================================
\ Russian Roulette: It would be interesting to do something
\ killed the computer when the player dies 

: click ."  *click*" cr ;
: bang  ."  BANG!" cr ;
: roulette random 6 mod if click else bang then ; ( -- )









\ ==== Extended ANSI Escape Codes ==============================
0 constant black 1 constant red 2 constant green 4 constant blue
red green        + constant yellow
    green blue   + constant cyan
red       blue   + constant magenta
red green blue + + constant white
: background $a + ;
: color $1e + sgr ;
\ : hide-cursor CSI [char] ? emit $19 10u. [char] l emit ;
\ : show-cursor CSI [char] ? emit $19 10u. [char] h emit ;
: up    [char] A ansi ; ( n -- )
: down  [char] B ansi ; ( n -- )
: left  [char] C ansi ; ( n -- )
: right [char] D ansi ; ( n -- )


\ ==== Screen Saver ============================================
\ An incredibly simple screen saver using ANSI Escape codes
\ for placement and coloring of random characters

: screen-saver ( -- )
  page
  begin
    random 80 mod
    random 40 mod at-xy
    random >char emit
    random 8  mod
    ( random 1 and if background then )
    color
  again ;


; ==== Game: YOU ARE DEAD (HELP) ===============================
This is a clone of the one dimensional rogue like game
available at <https://github.com/rupa/YOU_ARE_DEAD>. The
object is to get to the other side of the screen.

Keys:
w  Turn into '.'
a  Turn into '~'
s  Turn into '>'
d  Move right
q  Quit

Block number 7 is used to store the game state.



\ ==== Game: YOU ARE DEAD 1/6 ==================================
forth variable yad-voc get-order yad-voc swap 1+ set-order
$40 constant c/l $10 constant l/b
: memory 7 block ;
: variables memory c/l + ;
: score    variables 0 cells + ;
: position variables 1 cells + ;
: level    variables 2 cells + ;
: form     variables 3 cells + ;
: continue variables 4 cells + ;
: end c/l 1- ;
: player form @ ;
: .player position @ 1+ 3 at-xy player emit ;
: .goal c/l 3 at-xy [char] # emit ;
: .score ." SCORE: " score @ 5 u.r ;
: .level ." LEVEL: " level @ 5 u.r ;
\ ==== Game: YOU ARE DEAD 2/6 ==================================
: show 
  page cr cr space memory c/l type 
  .player .goal
  cr .score space .level cr ;

: select ( n -- c )
  dup 0=  if drop $3c ( < ) exit then
  dup 1 = if drop [char] ~  exit then
  dup 2 = if drop [char] .  exit then 
  drop bl ;

: die ." YOU ARE DEAD" cr 0 continue ! -56 throw ;
: survived ." YOU SURVIVED" cr .score cr ;
: forms form c@ position @ memory + c@ ; ( -- c c )

\ ==== Game: YOU ARE DEAD 3/6 ==================================
: generate ( -- generate a level )
  c/l 1- for
    random 5 mod ( 3 = most difficult )
    select memory r@ + c!
  next 
  bl memory c! bl memory end + c! ;
: normal [char] x ;
: setup ( -- )
  -1 continue !
  memory b/buf 0 fill
  normal form c!
  generate ;
  
: +score random 4 mod 1 min score +! ; ( -- )
: ?next <> if die else +score then ; ( c c -- )
\ ==== Game: YOU ARE DEAD 4/6 ==================================
: +level
  0 position ! level 1+!
  random 23 mod 5 min score +!
  generate ;

: monster swap >r forms r> = if ?next else 2drop then ; 

: command ( -- f )
  dup [char] w = if drop [char] . form c! 0 exit then
  dup [char] a = if drop [char] ~ form c! 0 exit then 
  dup [char] d = if drop -1 exit then 
  dup [char] s = if drop [char] < form c! 0 exit then 
  dup [char] q = if drop -56 throw then
  drop 0 ;

\ ==== Game: YOU ARE DEAD 5/6 ==================================
: rules
  position @ end = if +level exit then
  forms = if exit then
  [char] ~ [char] < monster
  [char] . [char] ~ monster
  [char] < [char] . monster
  normal form c!
  bl position @ memory + c!
  score 1+!
  position 1+! ;





\ ==== Game: YOU ARE DEAD 6/6 ==================================
: game
  begin
  show
  key command if rules then
  level @ 9 >
  until survived ;


: play setup ' game catch drop ;
get-order -rot swap rot set-order
: you-are-dead base @ decimal play base ! ;
forth
\ : resume memory drop ' game catch drop ;


; ==== eForth v6.66: Help and Tutorial =========================

This Forth is modeled after eForth, described in a book by
C.H. Ting called "eForth Overview", or "The Zen of eForth". It
implements most of the eForth model with some changes expected
from a more modern Forth system.

The processor targeted is called the H2, a rewrite of the
J1 processor (<http://www.excamera.com/sphinx/fpga-j1.html>).
It has been extended with a few more instructions and with
interrupts. The system resides on an FPGA Nexys 3 board from
Digilent, with words and peripherals designed for it.

For more see: <https://github.com/howerj/forth-cpu>


; ==== Help: Introduction ======================================

Forth is a simple, imperative, stack based language that mixes
elements of a high level language with a low level language. It
is possible to fit a small Forth system in a few kilobytes of
RAM complete with an interactive read-evaluate-print loop, an
editor, an assembler and a disassembler.

It is also a language that has fallen out of favor in recent
times (after the micro-computer era) as it is not a very safe
language, nor is it one that allows the programmer to easily
create reusable and maintainable software components.

However it is still suitable for a number of purposes; for
assemblers, to bring up hardware and test it, in memory
constrained systems, as a boot loader, and for fun.
; ==== Help: Philosophy of Forth ===============================
Forth itself has its own philosophy, one in which the programmer
should have a complete understanding of the system, from the
problem that needs to be solved, the algorithms needed to solve
it, the hardware and the software. As the latter two, the
hardware and software are usually very simple in Forth systems
it is possible to optimize the problem across multiple domains,
tailoring each to come up with a solution. Forth eschews
complexity, preferring one off, bespoke solutions. Another
reason it has not seen widespread use.

Advocates of the language are usually quite passionate about
it (as with Lisp, and other niche systems) so it is important
to be pragmatic about Forth. Forth is simply a tool and when
used correctly can be used productively.

; ==== Help: Basics 1/6 ========================================
A Forth system contains an interactive interpreter that parses
text and either compiles or executes functions, called 'words'
in Forth terminology. The system uses Reverse Polish Notation
(RPN) and provides the user with two stacks and a 'dictionary'
(a big block of memory containing 'words' and other data).

The interpreter reads from an input device, such as a keyboard
or a serial port, and writes output to the screen or back over
the serial port. Words and number input are space delimited and
are either compiled into the dictionary depending on the
interpreter mode and whether the word read in is 'immediate'
or not.

This tutorial will describe how to use Forth and how the
interpreter works internally.
; ==== Help: Basics 2/6 ========================================
To start with, simple expressions can be entered and the
results displayed. A line is evaluated after the carriage
return is entered, code will be indented, this can be typed in.

We will start off with a simple expression, adding two numbers
together and displaying the result:

  ( Comments appear within brackets )
  2 2 + .

This prints out '4' and 'ok'. 'ok' is printed out after every
line has been successfully compiled, unless we are in compile
mode. '+' obviously does the addition, and '.' pops a value
off the stack an prints it. Entering a number pushes it onto
the data stack.
; ==== Help: Basics 3/6 ========================================
The data, or variable, stack is a general purpose stack that
the programmer uses to pass data to functions, and to return
data from functions. The stacks are an important concept
within Forth and stack management will take up a lot of a Forth
programmers time.

Numbers are entered in Reverse Polish Notation, this allows
Forth interpreter to immediate process a word or a function as
it is encountered instead of building up a parse tree.

When '2' is encountered it is pushed onto the variable stack,
when the second '2' is input, it is also pushed onto the stack.
The Forth word '+' takes two arguments off the stack, adds them
together and pushes the result back onto the stack. The word
'.' pops a single number off the stack and prints it.
; ==== Help: Basics 4/6 ========================================
Manipulating the stack will be difficult at first, but gets
easier over time. There are standard words for stack
manipulation and a standard methodology for describing
stack effects called 'stack comments'.

A stack comment is a short comment describing the stack before
and after execution of the word, and the type of the arguments
it accepts and returns. For example the stack comment for '+'
is:

  + ( n n -- n : add two numbers together )

All text between '(' and the ')' is discarded by the Forth
system. This comment describes a word that accepts two
signed numbers "n n", and returns a signed number "n".
; ==== Help: Basics 5/6 ========================================
The "--" divides the comment into what the stack looks like
before execution of the word (to the left of "--") and what it
looks like after (to the right of "--"). A comment on the
behavior of the word comes after the semicolon.

Here is a list of some common Forth words and their stack
comments:

  dup  ( n -- n n : duplicate first item on the stack )
  swap ( n1 n2 -- n2 n1 : swap first two items on stack )
  drop ( n -- : drop a value from the stack )

Stack effects are sometimes numbered, which is used to
so the effects on specific arguments can be documented if
the order of arguments and return values matter.
; ==== Help: Basics 6/6 ========================================
Some more words with comments:

  @    ( a -- u : load value from memory address )
  !    ( u a -- : store 'u' at memory location 'a' )
  <    ( n1 n2 -- f : is n1 greater than n2, signed )
  u<   ( u1 u2 -- f : is u1 greater than n2, unsigned )

These words have stack comments, some with numbered arguments,
but they use different letters. The different letters are used
to describe the type of the arguments that the word accepts.

'@', also known as load, takes an address, and '!', takes
an address and a value. "<" takes two signed numbers, "u<"
takes two unsigned numbers and produces a flag. Type checking
is not performed by Forth and is up to the programmer.
; ==== Help: Stack Comments ====================================
Here is a list of stack type descriptions and what they mean:
| Comment  | Meaning                             |
|----------|-------------------------------------|
| a        | cell address                        |
| n        | signed number                       |
| u        | unsigned number                     |
| b        | string address                      |
| c        | single character                    |
| d        | double width number (2 Cells)       |
| f        | boolean flag (-1 = true, 0 = false) |
| k        | block number                        |
| cfa      | code field address of a word        |
| nfa      | name field address of a word        |
| pwd      | previous word address of a word     |
| <string> | a parsing word                      |
; ==== Help: Expressions =======================================
Let us continue on with some interactive examples before we
start to define new words. Before we saw a trivial example
of adding two numbers together, we will go over a few more
operators first.

  9 2 + . ( Displays 'B', the default base is hexadecimal )
  decimal ( Change the input and output base to decimal )
  9 2 + . ( Displays '11' )
  3 4 dup * swap dup * + . ( Displays 3^2 + 4^2 or 25 )

Negative numbers can be input by prefixing the number with
'-':

  -2 4 * . ( Display -8 )

; ==== Help: Numeric Output 1/2 ================================
The word '.' pops a value off the stack before displaying it,
if we want to examine the stack without popping the value we
can print out the entire contents of the stack with '.s':

  1 2 3 .s ( prints "1 2 3 <sp")
  .        ( prints "3" )
  .s       ( prints "1 2 <sp" )

"<sp" marks the element which is currently on the top of the
stack. Other useful words for debugging include '?' that
prints the contents at a memory address and 'dump', which
prints a memory dump of a region of memory.

  dump ( a u -- )
  ?    ( a -- )
; ==== Help: Numeric Output 2/2 ================================
Hexadecimal numbers can be entered if the base input and output
base is 16, or by prefixing the number with '$'.

  decimal  $aaa . ( Displays 2730 )
          -$aaa . ( Displays -2730 )

eForth starts up in base 16, valid bases range anywhere from
2 to 36. The base can be changed by either setting a variable
'base' to the desired base, or with the words 'hex' to change
the base back into hexadecimal, or 'decimal' to change the base
to '10'. Variables in Forth are words that leave an address on 
the stack when they are called. They can be read or set with 
'@' and '!'. For example, "$10 base !" and "hex" are 
equivalent, as are "$a base !" and "decimal".

; ==== Help: Word Definitions 1/2 ==============================
For the moment we have not covered how words are defined and
is a good time to do so, the word ":" is used to create a new
word definition and the word ";" is used to terminate one.
Words once defined are added to the 'dictionary', which is
consists of a linked list of words, hence the name 
'dictionary'. We can define new words interactively like we can
type expressions in, such as:

  : square dup * ; ( n -- n : square a number )

We can then use square like any other word:

  4 square .  ( prints 16 )
  -5 square . ( prints 25 )

; ==== Help: Word Definitions 2/2 ==============================
'hex' and 'decimal' are defined as:

  : hex $10 base ! ;
  : decimal $a base ! ;

And simple Forth words likewise defined:

  : 2- 2 - ;      ( u -- u : decrement a number by 2 )
  : 2+ 2 + ;      ( u -- u : increment a number by 2 )
  : 2* 1 lshift ; ( u -- u : multiply a number by 2 )
  : 1+ 1 + ;      ( u -- u : increment a number by 1 )
  : negate invert 1+ ; ( n -- n : negate, twos compliment )
  
It is best to keep all Forth words as short as possible and
reuse code as much as possible.
; ==== Help: Interpreter Loop 1/3 ==============================
All functions, control structures, defining words such as ":",
and simple functions like "square" or "hex" are simply Forth
words, which are either defined in terms of other Forth words
or in terms of primitive operations supported by the H2 CPU.

Currently this does not explain how compilation happens. When
the word ":" is encountered it does multiple things such as
compiling a word header into the dictionary, and it does one
more thing - it puts the Forth system into compile mode. The
system starts out in command mode, in this mode words are
executed, and numbers are pushed onto the stack. In compile
mode, a call to the word is compiled (or an assembly
instruction is inlined) and numbers of turned into literals
that push their value when run.

; ==== Help: Interpreter Loop 2/3 ==============================
There is a special class of words called "immediate" words, ";"
is an immediate word, when it is encountered instead of being
compiled into the dictionary it is executed, it compiles an
exit instruction to terminate the word definition and it puts
the Forth system back into command mode.

Not only are control structures sets of words, like "if",
"else", "then", "begin", "until", but so are words like "("
and "\" which are used to process comments. When executed
they read from the input stream until the they find a ")" or
end of line respectively.

Variables, strings, and defining words (defining words are
that create new words) are all simply Forth words that are
either compiling or immediate, their is no special syntax.
; ==== Help: Interpreter Loop 3/3 ==============================
The command loop goes like this:
Start) Fetch a space delimited word, find it in the dictionary
   Found) Is the system in compile mode?
          Yes) Is the word immediate?
               Yes) Execute It
               No)  Compile a call to it / In-line it
          No)  Execute the word
   Not Found) Is the word a number?
          Yes) Is the system in compile mode?
               Yes) Compile the number
               No)  Push the number onto the stack
          No)  Error!
This simple loop is invoked by the work 'quit' which uses
'query' to fetch and parse the input and 'interpreter' to
perform the state dependent action.
; ==== Help: Control Structures 1/10 ===========================
This will give you some idea what is going on when control
structures are covered in the following blocks. Control
structures can only be used within a word definition, that
is in compile mode, if used in command mode they simply throw
an error.

Some of the control structures available to Forth are:

  if ... then
  if ... else ... then
  for ... next
  for ... aft ... then ... next
  begin ... until
  begin ... again
  begin ... while ... repeat
; ==== Help: Control Structures 2/10 ===========================
Recursion is also available with the 'recurse' word. There
are more advance control flow methods available that will be
described later (such as 'catch', 'throw' and manipulating the
return stack).

"if...then" will be described first. First a simple example,
we will define a word called 'abs' that will return the
absolute value of a number, that is negative numbers will be
turned into positive numbers and positive numbers will stay
the same. This will require the word 'negate' which changes
the sign of a number and '0<' which tests if a number is
negative, their stack effect comments are:

  0<     ( n -- f )
  negate ( n -- n )
; ==== Help: Control Structures 3/10 ===========================
The word 'abs' is then defined as:

  : abs dup 0< if negate then ;

'if' takes an argument off the stack at run time and jumps to
after the 'then' if it is false (zero), if it is true (non-
zero) the negate is performed. From now if a word is shown in
a definition that has not been previously mentioned please
refer to the glossary. We can can use the definition of the
word 'abs' as soon as we terminate the definition with ";":

  -9 abs . ( displays 9 )
   4 abs . ( displays 4 )

This Forth uses two complements to represent negative numbers.
; ==== Help: Control Structures 4/10 ===========================
A number can be negated in twos compliment form by performing
a bitwise not on the number and adding one to it, this is what
the word 'negate' does.

"if...else...then" control structures can be created:

  : min 2dup < if drop else nip then ; ( n n -- n )
  : max 2dup > if drop else nip then ; ( n n -- n )

These words get the minimum (min) and the maximum (max) of
two numbers.

   4 3 min . ( prints 3 )
   4 3 max . ( prints 4 )

; ==== Help: Control Structures 5/10 ===========================
Whilst control structures can be nested very deeply it is
considered very bad practice to do, instead the definition
should be refactored so it consists of short (preferably one
line) word definitions.

There are two mains ways of looping, either by recursion or
with the several looping mechanisms. One of the simplest is
"begin...until". This continues looping until a variable popped
off the stack when the "until" word is reach is non-zero. Like
the "if" control structure this can only be used within a word
definition. An example is the definition of "key", which gets
a single character from the input device, it blocks until there
is input. It uses a word called "key?" which returns a variable
number of items on the stack depending on whether there is
new input from the user.
; ==== Help: Control Structures 6/10 ===========================
The stack comments for "key?" and "key" are:

  key? ( -- c -1 | 0 )
  key  ( -- c )

Key returns the new character and "-1" (in Forth -1 is true,
and 0 is false), or "0" if there is no new input. The pipe
system "|" is used to separate the possible return values in
the stack comment. We can use "begin...until" to define "key"
in terms of "key?" with:

  : key begin key? until ;

This simply loops until there is a new character of input.

; ==== Help: Control Structures 7/10 ===========================
Some contrived examples, using the standard metasyntactic
variable name "foo":

  : foo begin 1- dup . cr dup 0= until drop ; ( u -- )

  4 foo ( <-- type this ) 3 ( <-- prints '3' )
  2  ( <-- then '2' )
  1  ( ... )
  0  ( ... )
  ok ( then ok prompt )

If zero is given this will underflow and wrap around to $FFFF
and continue the loop 65536 times which is probably not
intended.

; ==== Help: Control Structures 8/10 ===========================
Indefinite loops can be made with "begin...again", the
following word "bar" simply repeatedly prints out "1":

  : bar begin 1 . cr again ;
  bar 1 1 1 1 1 1 ( ... ad infinitum ... )

A looping mechanism that is easier to use is the 
"begin...while...repeat" loop, this continues an operation
until a variable is not true:

  : foo begin ?dup while dup . cr 1- repeat ;
  3 foo 3 ( <-- prints 3 )
  2       ( <-- then 2 )
  1       ( <-- then 1 )

; ==== Help: Control Structures 9/10 ===========================
eForth provides another control structure, the "for...next" loop
which allows the Forth programmer to create counted loops. The
"for" loop takes a single variable, it stores this variable on
the return stack (which will be covered next) and decrements the
variable, until it is zero, at which point it exits (but still
executes for the final zeroth case). The word 'r@' is used to
push a copy of the top of the return stack, where the for loop
keeps the conditional value.

  : foobar for r@ . cr next ; 
  3 foobar 3 ( <-- prints 3 )
  2
  1
  0 ( <-- prints zero as well! )

; ==== Help: Control Structures 10/10 ==========================
The "for...next" construct can be modified with the "aft" and
"then" construct, which is not executed on the first run of the
loop.

  : quux for -9 . aft r@ . then -8 . cr then ;
  decimal 3 quux -9 -8 ( for...aft and then...next is run )
  2 -8 ( aft...then and then...next is run )
  1 -8 ( ... )
  0 -8 ( ... )

This concludes the control structure section, it should be
noted that the control structures are defined words themselves
again, it is possible to redefine and add your own control
structures. How this is done will be covered later.

; ==== Help: Return Stack ======================================
All Forth systems have at least two stacks along with main 
memory, they can be implemented in hardware like with this Forth
or in software. One stack is used to pass data to functions and
to return their results, the data or variable stack, which we
have already dealt with. The other stack is used for control
flow and as a place for temporarily storing variables.

Data can be moved to and from the return stacks, but this must
be done very carefully and only within word definitions, 
leaving values on the stack by accident can cause the 
interpreter to crash. 

Some looping constructs use the return stack as well to store
their loop index, and the 'throw/catch' mechanism manipulates
control flow a lot.
; ==== Help: Return Stack ======================================
Some words for manipulating the return stack are as follows,
notice the stack comments describe both stacks here:

  >r    ( u --, R: -- u : move variable to return stack )
  r>    ( -- u, R: u -- : move variable from return stack )
  rdrop ( R: u -- : remove topmost variable from return stack )
  r@    ( -- u, R: u -- u : copy topmost return stack item )








; ==== Help: Control Structures ================================















; ==== Help: TO DO =============================================

* Describe the system internals
* eForth primitives
* Make, Doer, Create, Does>
* Do word glossary, with one block per word
* Vocabularies
* Block Word set
* Peripheral access word set
* Throw/Catch
* How Forth is implemented





; ==== Block Editor Help 1/5 ===================================

The traditional way to store Forth source code and data is as
Forth blocks, a block is a contiguous array of 1024 characters,
which can be saved to non-volatile storage with the 'block'
word set. On more modern Forth systems, especially hosted ones,
the file access word set is used instead.

A Forth that does not have a file system, such as this one,
usually has a primitive block editor. An editor can be defined
in just a handful of (non-standard) words.

By default the editor words are not in the Forth search order,
the words in the editor vocabulary would conflict with Forth
words (and with hexadecimal numbers). To load the block editor
execute the 'editor' Forth word. Load initial block with '0 b'.
; ==== Block Editor Help 2/5 ===================================
The block editor is a prime example of Forth simplicity, it
both simplifies the problem of editing text and reuses the
Forth interpreter to define a new command language. Each command
in the block editor simply a Forth word which takes its
arguments off the stack, and a line is a fixed width 64
character array, a block can contain 16 lines of text. An empty
line consists entirely of spaces, which the interpreter will
ignore if it were to evaluate the block.

The 'editor' word replaces the current vocabulary with the
editor vocabulary and switches the number base for input and
output to decimal. The commands are terse words, only one or
two characters in length.


; ==== Block Editor Help 3/5 ===================================
The third element of the block editor is the elegant, if some-
what limited, block word set. It completely abstracts aways the
task of retrieving data from mass storage and saving modified
data back to it. The mass storage is divided into blocks which
can be loaded by their block number. Block numbers in this
system start at 0 and go to $FFFE, $FFFF is an invalid block
number.

The block word set is quite small, and the editor uses the
words; 'block', 'update', 'save-buffers', 'list', 'load',
and '+block'. The variable 'blk', which contains the last
block loaded (and listed) is also used. Most editor commands
are minor modifications on the behavior of these words.


; ==== Block Editor Help 4/5 ===================================
The workhorse of the word set is 'block', it takes a block
number and if that block number is not currently loaded into a
block buffer (this system only has one block buffer available)
it checks to see if the current block is marked as dirty (with
the 'update' word). If it has been it first flushes the dirty
block to mass storage, then loads the desired block from it. It
then returns a pointer to the beginning of the block buffer. It
also updates the 'blk' variable to contain the block number
just loaded.

The 'save-buffers' saves all buffers to disk and deallocates
any blocks (by storing $FFFF in 'blk'). 'list' displays the
contents of a block, 'load' evaluates a block and '+block'
moves to a block relative to the currently loaded one.

; ==== Block Editor Help 5/5 ===================================
A quick recap of the block words:

block        ( k -- u : load block into buffer )
blk          ( -- a : last loaded block )
+block       ( k -- : load block relative to 'blk' )
save-buffers ( -- : flush block to disk, put -1 in 'blk' )
list         ( k -- : display block )
load         ( k -- : evaluate a block )

These can be used to define simple editor commands, such as:

  : b block drop ;
  : n 1 +block b ;
  : u update ;

; ==== Block Editor Commands 1/2 ===============================

'#' indicates a numeric argument the command takes:
      n    move to next block
      p    move to previous block
    # d    delete line in current block
      x    erase current block (overwrite with spaces)
      e    evaluate current block
    # i    insert line
 # #2 ia   insert at line #2 at column #
      q    quit editor loop
    # b    load block number
      s    save block and write it out
      u    update block
      w    list editor commands
      q    back to Forth interpreter
; ==== Block Editor Commands 2/2 ===============================


      l    re-list current block
    # c    paste copy buffer to line #
    # y    yank line # into copy buffer
 # #2 ct   copy line # to line #2
    # ea   evaluate line #
 # #2 sw   swap lines # and #2

The editor is simple to use and understand, but for large
documents and programs can quite difficult to use. This block
editor was derived from the Retro Forth block editor, available
at: <http://retroforth.org/pages/?PortsOfRetroEditor>


; ==== TO DO ===================================================

* Describe the Nexys 3 system, the system on a chip, the
* List the instruction set, registers, words defined, eForth
* Make words for databases using blocks
* Add source code for everything to this block file
* Add a program listing, perhaps in the first block, it could
set variables relating to this document
* Turn this into a markdown document,
* The eForth primitives should be described.
* Add the symbols generated by the compiler (h2.sym) to block
* Extra words could be stored in these blocks, freeing up
space for the user
* Better tools for editing this file would help a lot.
* Move the block editor to this file
* Full glossary: 1 block per word definition
; ==== Empty Block =============================================















; ==== Glossary ================================================















; ==== <  ( n1 n2 -- f : signed less than ) ====================
Signed less than, this is an assembly word primitive that is
inlined when it is compiled into a word.













; ==== <>  ( u1 u2 -- f : not equal ) ==========================
Not equal to.














; ==== <#  ( -- : prepare numeric output ) =====================
This is part of the mechanism for pictured numeric output, 
which should be used from within a word definition only.













; ==== =  ( u1 u2 -- f : equality of two numbers ) =============
This is an assembly instruction for testing whether two numbers
are equal. 













; ==== >  ( n1 n2 -- f : signed greater than ) =================
signed greater than














; ==== -  ( n1 n2 -- n : twos compliment subtraction ) =========
This is a word performs subtraction on two numbers in twos
compliment format. 













; ==== ,  ( u -- : compile value into dictionary ) =============
The word ',' compiles a value at the next available location
in the dictionary, updating the dictionary pointer by the size
of a cell.












; ==== ;  ( -- : terminate a word definition ) =================
This word terminates a word definition, linking the newly formed
word into the dictionary. It is an immediate word and performs
some basic checking to make sure control structures match up. It
writes an 'exit' into the word and switches the state back into
command mode. It has another minor usage, if called within
command it throws -56, for QUIT. This can be used within a block
to stop execution of it, if 'thru' is used to load block, this
error is ignored.

Example:

   : 2+ 2 + ; 
   : count dup 1+ swap c@ ;
   :noname 9 . ; execute ( <-- prints 9 )

; ==== :  ( -- ; <string> : start a word definition ) ==========
Start a word definition. 














; ==== !  ( u a -- : store 'u' at address 'a' ) ================
Store a value in at an address, this is also used to write to
the memory mapped peripheral registers.













; ==== ?  ( a -- : print value at address ) ====================
Print a value out from an address, this is effected by the
output radix stored in 'base'. This word uses the area between
PAD area and the end of the dictionary.












; ==== /  ( n1 n2 -- q: divide n1 by n2 ) ======================
Signed and floored division of the second value on the stack by
the first. This will throw and error if the divisor is zero.
This is a particularly slow operation, as the H2 CPU does not
a built in division operation.











; ==== .  ( n -- : print number out in current base ) ==========
Print a space, then a signed number (if the output radix is ten
then a '-' is printed before the number if it is less than zero,
if the output radix is not ten, then it is just printed out as
an unsigned number). This word uses the area after the
dictionary and before the start of the pad area, it is not a
reentrant function.









; ==== ."  ( -- ; <string> : compile string into word ) ========
This word is an immediate word that compiles a string into a
word definition (it should only be used from within a word
definition). When the word is run it will print out the string.

The string is terminated by a double quote.










; ==== .(  ( -- ; <string> : print out line until ')' ) ========
This word prints out a string until the matching ')' is 
encountered. It is not an immediate word.













; ==== '  ( -- xt ; <string> : return a word execution token ) =
This word parses the next word in the input stream and returns
its execution token if the word is found. It is an immediate
word. If the word is not found it throws an exception.












; ==== (  ( -- ; <string> : comment until ')' ) ================
This is an immediate word used for comments, it discards all
input until the matching ')' is encountered. It can be used
within blocks.












; ==== )  ( -- : do nothing ) ==================================
This is a word that does nothing. It is an immediate word. It
has no function.













; ==== [  ( -- : change compile state to command mode ) ========
An immediate word for changing the state of the interpreter loop
into the command state. It can be used within a word definition.













; ==== ]  ( -- : change compile state to compile mode ) ========
A normal, compiling word, which turns the interpreter state into
compile mode. Words and numbers after (apart from immediate
words) are compiled into the dictionary.












; ==== @  ( a -- u : load value from address ) =================
Retrieve a value from memory location 'a'. It can be used to
read from the memory mapped registers as well.













; ==== $"  ( -- ; <string> : compile string into word ) ========
This is an immediate word that can only be used in a word
definition, it compiles a string into the dictionary, when it
runs it pushes the address of the counted string compiled into
the word.











; ==== *  ( u1 u2 -- u3 : multiple two numbers ) ===============
Multiply two numbers and push the result onto the stack. This is
a slow operation, as there is not a built in multiply operation.













; ==== \  ( -- ; <string> : comment until end of line ) ========
Comment until end of input line, this word works within blocks
as well, where it is a comment until the end of the block line.
It is an immediate word.












; ==== #  ( u -- u : extract numeric character from u ) ========















; ==== #>  ( u -- b u : return converted number string ) =======















; ==== +  ( u1 u2 -- u3 : add two numbers together ) ===========















; ==== +!  ( u a -- : add 'u' to value 'a' ) ===================















; ==== 0<  ( n -- f : 'n' less than zero? ) ====================















; ==== 0<>  ( n -- f : 'n' not equal to zero? ) ================















; ==== 0=  ( n -- f : 'n' equal to zero? ) =====================















; ==== 0>  ( n -- f : 'n' greater than zero? ) =================















; ==== 1-  ( u -- u : decrement u ) ============================
This is an assembly word that is inlined when compiled into a
word definition, it decrements a value.













; ==== 1+  ( u -- u : increment u ) ============================
This is a regular function that increments a value by one.














; ==== 1+!  ( a -- : increment value at 'a' by one ) ===========















; ==== 2!  ( u1 u2 a -- : store u1 and u2 at two cells ) =======















; ==== 2/  ( u -- u : divide 'u' by two ) ======================















; ==== 2@  ( a -- u1 u2 : retrieve two cells ) =================















; ==== 2*  ( u -- u : multiply 'u' by two ) ====================















; ==== 2drop  ( u u -- : drop two values from the stack ) ======















; ==== 2dup  ( u1 u2 -- u1 u2 u1 u2 : duplicate two values ) ===















; ==== abs  ( n -- u : absolute value of a number ) ============
Returns the absolute value of a signed number, positive values
stay the same, negative values become positive. Signed numbers
are stored in twos compliment format, the function fails for
the number $8000, which is unaffected by abs.











; ==== accept  ( b u -- b u : accept a line ) ==================















; ==== aft  ( -- : part of for...aft...then...next ) ===========















; ==== again  ( -- : part of begin...again loop ) ==============















; ==== align  ( -- : align dictionary pointer ) ================















; ==== aligned  ( b -- a : align up an address ) ===============















; ==== allot  ( n -- : allocate 'n' bytes ) ====================
Allocate 'n' bytes of space in the dictionary, 'n' can be
either positive, or negative, negative deallocates space.













; ==== and  ( u1 u2 -- u3 : bitwise and of two numbers ) =======
This performs a bitwise and on two numbers, this is an
assembly primitive that is inlined when it is compiled into a
word.












; ==== ansi ( n c -- : emit an ANSI escape command ) ===========















; ==== at-xy  ( x y -- : place cursor at column 'x', row 'y' ) =















; ==== base  ( -- a : address of base radix ) ==================
Pushes the address of the base variable onto the variable stack,
this can be used to change the input and output radix of numbers
to a base between 2 and 36 inclusive. Characters '0' to '9' are
used for numbers 0 through 9, and letters 'A' to 'Z' are used
for numbers 10 to 35, upper case and lower case letter can be
used, only upper case characters are output.

Setting the base to an invalid value can cause exceptions to
be thrown in other words.

Example usage:
   $2 base !
   base @
   $8 base !

; ==== b/buf  ( -- u : number of bytes in a block ) ============
This pushes the number of bytes in a block onto the stack, which
is 1024 in most Forth implementations, including this one.













; ==== begin  ( -- : start begin...until/again loop ) ==========















; ==== bl  ( -- u : value for space character ) ================
This pushes the space character to the stack.














; ==== blank  ( b u -- : fill array with blanks ) ==============
This word writes the space character to a byte array, one use
is to erase a block before it is displayed with 'list'.













; ==== blk  ( -- a : address of last loaded block ) ============















; ==== block  ( u -- a : perform block operation ) =============















; ==== +block ( n -- u : return block number relative to blk ) =















; ==== border  ( -- a : variable for list display control ) ====















; ==== c,  ( c -- : compile character into dictionary ) ========
This words takes a character and writes the character in the
next available location in the dictionary, and updates the
dictionary pointer. This word can cause the dictionary number to
be misaligned, 'align' can be used to remedy this.











; ==== c!  ( c b -- : store 'c' at 'b' ) =======================















; ==== c@  ( b -- c : retrieve 'c' from 'b' ) ==================















; ==== catch  ( xt -- n | 0 : catch possible exception ) =======















; ==== ccitt  ( crc c -- crc : compute CRC step ) ==============















; ==== cell-  ( a -- a : decrement address by single cell ) ====















; ==== cell+  ( a -- a : increment address by single cell ) ====















; ==== cells  ( n -- n : convert byte to cell number ) =========















; ==== >char ( c -- c : convert unprintable string ) ===========















; ==== char  ( -- c ; <string> : parse character ) =============
This word reads in a space delimited from the input stream and
and pushes the first character of that word onto the stack.













; ==== [char]  ( -- ; <string> : compile character literal ) ===
This is an immediate word that compiles a character into the
dictionary as a literal value that will be pushed onto the
stack when the word is run. It parses a space delimited word
and compiles the first character of that word. It is a compile
only word.










; ==== cmove  ( b b u -- : move block memory ) =================
'cmove' moves a block of characters from one location to 
another.













; ==== compile ( -- : compile next word into dictionary ) ======















; ==== [compile]  ( -- xt : compile next immediate word ) ======















; ==== compile,  ( xt -- : compile execution token ) ===========
'compile,' compiles an execution token into the next available
location in the dictionary, taking up a cell of space. This
word must be used when compiling in an execution into a word,
the word ',' will compile an unconditional branch.











; ==== conceal  ( -- : emit stars instead of characters ) ======















; ==== console  ( -- : UART only mode ) ========================















; ==== constant  ( n -- ; <string> : create constant ) =========















; ==== count  ( a -- b c : retrieve next character in string ) =















; ==== cpu-id  ( -- u : return CPU-ID ) ========================
This is an assembly instruction that pushes the CPU-ID of the
CPU onto the stack. It can be used to determine whether the
system is running in a simulation or on the hardware.












; ==== cr  ( -- : emit new line ) ==============================















; ==== crc  ( b u -- u : perform CRC over array ) ==============















; ==== create  ( -- ; <string> : make 'created' word ) =========















; ==== decimal  ( -- : switch radix to decimal ) ===============















; ==== dm+  ( a u -- u : print out section of memory ) =========















; ==== dnegate  ( d -- d : negate a double value ) =============















; ==== doer  ( -- ; <string> : create a 'doer' word ) ==========















; ==== does>  ( -- : start 'does' section of word ) ============















; ==== drop  ( u -- : drop a value ) ===========================















; ==== dump  ( a u -- : dump a section of memory ) =============















; ==== dup  ( n -- n n : duplicate a value ) ===================















; ==== ?dup  ( n -- n n | 0 : duplicate value if not zero ) ====
This word duplicates a number if that number is non zero, it
returns just a single zero if the input number was zero. It
finds a lot of use in 'begin...while...repeat' loop constructs.












; ==== else  ( -- : if...else...then ) =========================















; ==== emit  ( c -- : emit a character ) =======================
'emit' emits a single character to the output device, this
device is by default both the UART and the VT100 terminal
emulator can be displayed on a VGA capable display. The board
used has VGA output. The output of this word can be redirected
by words like 'io!', 'stars', 'conceal', 'file', 'console' and
'interactive'.









; ==== empty-buffers  ( -- : deallocate block buffer ) =========
'empty-buffers' deallocates any currently loaded block buffers,
and stores and invalid block number in 'blk'. It can be used
to discard any changes made to any currently loaded blocks.












; ==== evaluate  ( a u -- : evaluate block of memory ) =========















; ==== execute  ( xt -- : execute an execution token ) =========
'execute' takes an execution token, which represents a callable 
function, and it executes that function. Execution tokens are
returned by words like "'" (quote), or by ":noname".












; ==== @execute  ( a -- : execute token at 'a' if non-zero ) ===
'@execute' expects an address of a value containing an
execution token to execute, it retrieves this token from the
address and executes it if the token is a non-zero value. This
is primarily uses for vectored word execution.











; ==== exit  ( -- : exit from word ) ===========================
This word is an assembly instruction that will be inlined into
a word when it is executed, it will run but have no effect when
executed in command mode, when compiled into a word it will
exit that word definition when it is run by returning from that
word. It is compiled into the end of a word definition by
the ';' word, which terminates a word.




Example:
   : foo if $f00f . exit then $1337 . ;
   0 foo $F00F ( <-- prints only '$F00F', $1337 not printed )
   1 foo $1337 ( <-- prints $1337 only )

; ==== expect  ( b u -- : accept, but store 'u' in span ) ======















; ==== file  ( -- : file transfer mode ) =======================















; ==== fill  ( b u c -- : fill area of memory with 'c' ) =======















; ==== find  ( a -- pwd 1 | pwd -1 | a 0 : find word ) =========















; ==== flash  ( -- : add flash words to search order ) =========















; ==== flush  ( -- : write dirty blocks, empty-buffers also ) ==















; ==== for  ( -- : part of for...next loop ) ===================















; ==== forth  ( -- : set minimal search order ) ================















; ==== forth-wordlist  ( -- voc : return Forth vocabulary ) ====















; ==== get-order  ( -- vn...v0 u : get search order ) ==========















; ==== here  ( -- a : return dictionary address ) ==============
'here' returns the current address of where the dictionary
pointer is, new words will be compiled at this address. The
dictionary pointer is updated by compiling words and numbers
into the dictionary, words like ',' and 'compile,'.











; ==== hex  ( -- : set numeric radix to hexadecimal ) ==========
This sets the current output radix to hexadecimal.














; ==== hi  ( -- : initialize and login to system ) =============















; ==== hld  ( -- : hold variable for pictured numeric output ) =















; ==== hold  ( c -- : put byte into numeric output string ) ====















; ==== ien  ( f -- f : set interrupt flag ) ====================















; ==== ien?  ( -- f : are interrupts enabled? ) ================















; ==== if  ( -- : part of if...then/if...else...then) ==========















; ==== immediate  ( -- : make last defined word immediate ) ====















; ==== >in  ( -- a : index into parse input at address ) =======















; ==== index  ( k1 k2 -- : print first line of block range ) ===
'index' displays the first line in a range of blocks, if the
blocks are formatted correctly with the first line containing a
description of the block contents then this works to display an
index of the blocks.











; ==== interactive  ( -- : interactive I/O mode ) ==============















; ==== interpret  ( ??? a -- ??? : interpret word/number ) =====















; ==== invert  ( u -- u : bitwise invert ) =====================
Performs a bitwise invert on a number. This is implemented as an
assembly instruction that is inlined when compiled into a word.













; ==== io!  ( -- : initialize IO channels ) ====================
'io!' initializes the I/O devices and sets the input and output
devices to their default values (read from UART and PS/2 
keyboard, write to the VT100 display, and to UART - both at
the same time). It also disables the interrupts, and sets the
timer to a count but not generate interrupts.





Example usage:

   io! ( ...that's not a very good demonstration... )


; ==== key  ( -- c : block until character read in ) ===========
This word blocks until a character has been read in from the
current input device (or devices). The input devices can be 
either be the UART or the PS/2 Keyboard. The input devices can
be changed with the 'io!', 'console', 'conceal', 'interactive'
and 'file' words.










; ==== key?  ( -- c -1 | 0 : non-blocking character read ) =====
This is a non-blocking version of 'key', it returns a
character and true (-1) if a new character has come through
from input devices, and only 0 if there is no new character.
The input devices can be either a UART or a PS/2 keyboard, and
this can be changed with the 'io!', 'console', 'conceal', 'file'
and 'interactive' words.









; ==== last  ( -- pwd : last defined word ) ====================















; ==== led!  ( u -- : write value to LEDs ) ====================
'led!' sets the LEDs on the board next to the switches. There
are eight switches, and the lowest eight bits of the input value
are used to set the switches, 1 is on, 0 is off.












; ==== list  ( k -- : list block ) =============================
The word list loads block 'k' from disk and display the contents
of this block on the screen. It displays the block as 16 lines
with a column width of 64. The display format is controlled by
the 'border' variable, if true it 'list' displays the line
number and a border around the block, if false, then it just
display the block line by line without formatting. It is true
by default. 'list' will also call 'page' before it displays
the block if 'border' contains a non-zero value.







; ==== literal  ( n -- : compile literal into dictionary ) =====
This is an immediate word that compiles a number into the
dictionary. A number takes up between one and two cells in the
dictionary (negative numbers take up two space, positive only
one). It is a compile only word.











; ==== load  ( k -- : load and execute block ) =================















; ==== loaded  ( -- a : variable, true if boot block loaded ) ==
This is a variable which can be set by the user if the loading
of the boot block was successful, and if the error messages
exists on disk. The error handling words in QUIT inspect this
variable to work out if it can lookup error messages and print
them, or if it should just print out the error number.










; ==== lshift  ( u1 u2 -- u3: logical left shift u1 by u2 ) ====
This performs a logical left shift on 'u1' by 'u2'.














; ==== make  ( -- : make part of make/doer words ) =============















; ==== max  ( n1 n2 -- n3: maximum of two numbers ) ============
This returns the maximum of two numbers.














; ==== message  ( u -- : type line from block ) ================















; ==== min  ( n1 n2 -- n3: minimum of two numbers ) ============
This returns the minimum of two signed numbers.














; ==== m/mod  ( d n -- r q : signed divide / modulo ) ==========















; ==== mod  ( n1 n2 -- r : remainder of n1 divided by n2 ) =====















; ==== /mod  ( n1 n2 -- r q : remainder/divisor ) ==============















; ==== ms  ( u -- : wait for 'u' milliseconds ) ================
'ms' waits for 'u' milliseconds with a busy loop. It is
predicated on the system running at 100MHz and will need to be
modified if the system frequency changes.












; ==== negate  ( n -- n : negate a number ) ====================















; ==== next  ( -- : part of for...next loop ) ==================















; ==== nip  ( n1 n2 -- n1 : remove second value on stack ) =====















; ==== :noname  ( -- xt : start anonymous function ) ===========
The ':noname' word is an immediate word that allows the
creation of words that do not have names, or an anonymous
function. The word can be executed with the 'execute' function.












; ==== nuf?  ( -- f : true if 'cr' character pressed ) =========
'nuf?' is a non blocking input word that returns true if a
carriage return was input. It can be used to determine if a
word should continue execution or not.












; ==== number?  ( b u -- n f : is string a number ) ============















; ==== .ok  ( -- : print okay prompt ) =========================
'.ok' prints out 'ok' after the successful execution of an
input line when the Forth interpreter is in the command mode,
the prompt is suppressed when in compile mode.












; ==== or  ( u1 u2 -- u3: bitwise or of two numbers ) ==========















; ==== over  ( n1 n2 -- n1 n2 n1 : duplicate over ) ============















; ==== pack$  ( b u a -- a : pack string into address ) ========















; ==== pad  ( -- a : return address into pad area ) ============















; ==== page  ( -- : clear page ) ===============================















; ==== parse  ( b u c -- b u delta : parse string out ) ========















; ==== pick  ( un...u0 u -- un...u0 u u : pick value ) =========















; ==== query  ( -- : get line of input ) =======================















; ==== quit  ( -- : interpreter loop ) =========================















; ==== >r  ( u --, R: -- u : move value to return stack ) ======















; ==== r>  ( -- u, R: u --: move value from return stack ) =====















; ==== r@  ( -- u : R: u -- u: copy top of return stack ) ======















; ==== random  ( -- u : random number ) ========================















; ==== rdrop  ( --, R: u -- : drop a value from return stack ) =
'rdrop' is the return stack equivalent of 'drop', it discards
a single value from the return stack. It is implemented as an
assembly routine that will be inlined when compiled into a
word. Care should be taken when manipulating the return stack
as it can trash it rendering the system inoperable until it
is restarted.









; ==== recurse  ( -- : recursively call current word ) =========
'recurse' is a word that when used within a word definition it
will recursively call the current word. 













; ==== repeat  ( -- : part of begin...while...repeat ) =========















; ==== rot  ( n1 n2 n3 -- n2 n3 n1 : rotate three items ) ======
Rotate the first three elements on the variable stack.














; ==== -rot  ( n1 n2 n3 -- n3 n1 n2 : rotate three items ) =====
Rotate the first three elements on the variable stack in the
opposite direction as 'rot'. If you find yourself using this
word too much it might be best to refactor your code.












; ==== rp@  ( -- u : return stack depth ) ======================
'rp@' push the return stack depth onto the variable stack, it
is an assembly instruction.













; ==== rpick  ( u -- u, R: un...u0 : pick return stack value ) =
'rpick' picks a value at an arbitrary depth on the return stack
based on the argument given.













; ==== rshift  ( u1 u2 -- u3 : logical right shift u1 by u2 ) ==















; ==== .s  ( -- : print out variable stack ) ===================
This word is used for debugging, it prints out the entire
variable stack up to the current variable stack depth. It uses
the area between the end of the dictionary and the start of the
PAD area. It is not a reentrant function.











; ==== #s  ( u -- 0 : repeat '#' until 0 ) =====================
This word repeatedly calls '#' on a number until it is zero, it
should only be used within a pictured numeric output construct
and uses the area between the end of the dictionary and the
beginning of the pad area. Characters are held starting from
the pad area working downwards towards the end of the dictionary
space.





Example:
  : print-number <# #s #> type ;
  1234 print-number ( <-- prints '1234' )

; ==== save-buffers  ( -- : save dirty blocks ) ================















; ==== see  ( -- ; <string> : decompile word ) =================
'see' is a complex word that can decompile a Forth word, it is
liable to be buggy. 'see' parses the next space delimited word
in the dictionary, and if found attempts to disassemble the
word into instructions and function calls. If not found 'see'
will throw an exception.










; ==== segments!  ( u -- : display 'u' on LED displays ) =======
Segments writes a single 16-bit value to the four seven segment
displays on the board. This can be used to display a single
cell as a hexadecimal value.












; ==== set-order  ( vn...v0 u -- : set search order ) ==========
This word sets the sort order.














; ==== sgr  ( u -- : set ANSI terminal SGR attribute ) =========
'sgr' takes a number and emits it as a 'Select Graphic
Rendition' command, which is a standard ANSI Escape sequence
used for terminal control. SGR commands relate to colors and
how the text is presents, for example numbers $1E to $25 are
used to set the foreground color, $28 to $2F the background
color. $0 is used to reset all of the attributes, $8 is used
to conceal character output, $7 for reverse video. Not all
SGR commands are processed by the VT100 hardware, and if
talking to the device over the UART it depends on the terminal
emulator you are using.

Examples:
   0 sgr    ( reset terminal SGR attributes )
   $1f sgr  ( set foreground color to red )
   $2a sgr  ( set background color to green )
; ==== sign  ( n -- : hold '-' if n negative ) =================
'sign' is a word used in conjunction with the pictured numeric
output routines ('<#', '#s' and '#>'), it holds a '-' is the
signed number it is given is negative.












; ==== source  ( -- a u : get source string ) ==================















; ==== source-id  ( -- 0 | -1 : identify input source ) ========















; ==== sp@  ( -- u : variable stack depth ) ====================
'sp@' is an assembly instruction which returns the current
depth of the variable stack. It is inlined when compiled into
a word.












; ==== space  ( -- : emit space character ) ====================
'space' emits a single space character to the current output
device.













; ==== spaces  ( n -- : emit 'n' spaces ) ======================
'spaces' emits 'n' number of spaces.














; ==== span  ( -- a : character count from expect, variable ) ==















; ==== state  ( -- a : state variable ) ========================
'state' is a variable that contains the global state of the
Forth interpreter loop, which can be in either compile or
command mode. 'state' contains -1 for command mode, 0 for
compile mode. It can be set directly to change the interpreter
state, or read to make words change their behavior based on
the state (which is generally not the best thing to do). The
words '[' and ']' can be used to switch the state as well.








; ==== =string  ( a1 u2 a1 u2 -- f : string equality ) =========















; ==== /string  ( b u1 u2 -- b u : advance string by u2 ) ======
'/string' advances a string 'b u1' by 'u2' characters, if there
are enough characters left to advance the string by.













; ==== swap  ( u1 u2 -- u2 u1 : swap two variables ) ===========
This is an assembly instruction which will be inlined if 
compiled into a word. It swaps two variables on the stack.













; ==== switches  ( -- u : get state of switches ) ==============
'switches' retrieves the state of the two state switches on
the board, the values are already debounced. There are eight
switches which each have a single LED next to them (which can
be controlled with 'led!'). The lowest eight bits are used
for the switch states, 1 for on, 0 for off.

Example usage:
   : select 1 swap lshift switches swap and 0= 0= ;
   : sw0 0 select ; : sw1 1 select ; : sw2 2 select ;
   : sw3 3 select ; : sw4 4 select ; : sw5 5 select ;
   : sw6 6 select ; : sw7 7 select ;
   : switches->leds switches led! ;



; ==== then  ( -- : part of if...then or if...else...then ) ====















; ==== throw  ( ? n -- ?, R: ? -- ? : throw exception ) ========
'throw' along with 'catch' are the Forth exception handling
routines, 'throw' throws an exception if the number provided to
it is non-zero. An exception unwinds the return stack until
a 'catch' is encountered, the word 'quit' contains the exception
handler of last resort. Numbers from -255 to 0 are reserved for
standard Forth errors.









; ==== thru  ( k1 k2 -- : load from k1 to k2 ) =================
'thru' calls 'load' on a range of blocks from 'k1' to 'k2'
inclusively. It is used to evaluate a range of blocks and as
a convent way to load software off of the mass storage device.
Code and data is stored in Forth blocks, 'thru' is used to load
that data.










; ==== timer  ( -- u : get value of timer ) ====================
'timer' retrieves the current value of the hardware time in the
FPGA, this peripheral can be controlled with the 'timer!' word,
which is used to control the timer.












; ==== timer!  ( -- : set timer ) ==============================
'timer!' sets the hardware timer control register, allowing the
timer to be enabled/stopped/reset and setting up the value at
which the timer wraps around at (or triggers an interrupt). The
layout of the timer control register is as follows:

  BIT  - MEANING
  15   - Enable Timer (1 = enabled)
  14   - Reset Timer
  13   - Enable Interrupts
  12-0 - Timer Compare Value

The word 'timer' can be used to read in the current value of
the timer.


; ==== tuck  ( n1 n2 -- n2 n1 n2 : tuck value ) ================
'tuck' is a simple word that manipulates the stack, its stack
comment describes what it does. It tucks a variable behind
the second most item on the stack.












; ==== type  ( b u -- : print out a string ) ===================
'type' prints out a string.














; ==== u<  ( u1 u2 -- f: unsigned less than ) ==================
Unsigned less than of two numbers, this is an assembly operation
that is inlined into a word definition. 













; ==== u>  ( u1 u2 -- f: unsigned greater than ) ===============
Unsigned greater than, this is not an assembly instruction.














; ==== u>=  ( u1 u2 -- f: unsigned greater or equal to ) =======
Is 'u1' greater than or equal to 'u2', this is an unsigned
operation.













; ==== u.  ( u -- : print out number in current base ) =========
'u.' prints out an unsigned number in the current output base,
this number uses the area at the end of the dictionary and
the beginning of the PAD area as temporary storage.












; ==== um*  ( u u -- ud : unsigned multiply ) ==================
Unsigned multiple, it takes two single cell numbers and returns
an unsigned double.













; ==== um+  ( u u -- u carry : unsigned add with carry ) =======
Unsigned addition with carry, this word is used to implement
the majority of the arithmetic operations, although it is not
very useful directly.












; ==== um/mod  ( ud u -- ur uq : unsigned modulo divide ) ======
Unsigned division of an unsigned double cell number by a single
cell number and leaves the remainder, 'ur' and the quotient,
'uq'. This is a slow operation as it is not implemented as an
instruction within the H2 CPU. It will throw and exception if
the divisor is zero. The word is used to implement the other
division and modulus operations.









; ==== until  ( -- : begin...until loop ) ======================















; ==== update  ( -- : mark last loaded block as dirty ) ========
Marks the last loaded block as being dirty (the last loaded
block block number is stored in the variable 'blk'). A dirty
block will be written to disk on when 'flush', 'save-buffers',
or another block is loaded from disk. 











; ==== u.r  ( u +n -- : print u right justified by +n ) ========
'u.r' is a general purpose numeric formatting word, it prints
out the number 'u' as an unsigned number in the current output
radix, preceded by '+n' spaces, minus the number of spaces 
needed to display 'u' in the current output radix, or right
aligned. This function uses the area between the end of the
dictionary and the beginning of the PAD area as temporary
storage.








; ==== variable  ( -- ; <string> : create a new variable ) =====
'variable' parses the next space delimited string from the
input string and makes a new named variable. The variable will
be initialized with zero, although this is not guaranteed to be
the case with all Forths. Variables are just normal words that
push a location onto the dictionary of where the variable is
stored, it can be accessed with the '!' and '@' words, only
one cell of storage space is reserved. The created word is
not an immediate word.







; ==== ver  ( -- u : push version information ) ================
Pushes the version number of the eForth implementation. The
format of the version is the major version is stored in the
upper byte and the minor version information is stored in the
lower byte. 

The minor version number changes on minor updates, the major
version changes when there are major updates in how the
interpreter works that could potentially break code.







; ==== while  ( -- : begin...while...repeat loop ) =============















; ==== within  ( u hi lo -- f : is u within a range? ) =========















; ==== word  ( c -- a; <string> : parse a word ) ===============















; ==== words  ( -- : list all words in dictionary ) ============
This lists all of the words in the dictionary that are on the
current search order. Each vocabulary is listed with the address
of that vocabulary as a prefix.












; ==== xor  ( u1 u2 -- u : bit wise exclusive or ) =============
Bitwise exclusive or of two numbers, this is an assembly word
that is inlined into a word definition when compiled into it.













; ==============================================================















