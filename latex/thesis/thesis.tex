% Richard James Howe
% LaTeX Final Year Project, final report.
% Fri Apr 19 23:17:27 BST 2013
\documentclass	[a4paper, 10pt]	{article}
\usepackage	    [T1]		        {fontenc}
\usepackage	    [utf8]		      {inputenc}
\usepackage			                {lmodern}
\usepackage			                {url}
\usepackage                     {color}
\usepackage                     {hyperref}

% page layout settings
% \evensidemargin	= 0pt		%default 54pt
% \textwidth	= 444pt		%default 380pt
% \hoffset	= -54pt		%default 0pt
% \topmargin	= -54pt		%default 18pt


\newcommand{\findcite}[1]{
  \par
  \begin{center}
  \framebox[\textwidth]{
    \textcolor{red}{\emph{Find Citation on:} \textsc{#1}}
  }
  \end{center}
  \par
}

\title		{Final Year Project: A Computing System in VHDL.}
\author		{Richard James Howe}
%date		{}

\begin		{document}

	\maketitle
	\hrulefill

	\begin{abstract}
    The goal of this project is to create a computing system in VHDL from the
    ground up in order to make a product that is useful for both teaching and
    eventually much more. This project includes the firmware and the toolchain
    that is to target the device.
	\end{abstract}

	\tableofcontents
  \listoffigures

  \section{Introduction}

  The idea of this project is to create an educational system for electrical
  engineers who are studying VHDL that can be eventually developed into something 
  more useful, and still have those engineers in mind. 

  This is meant to be an entire system, which is why the project spans multiple
  languages and includes different sub-projects, which can be put into roughly
  three different fields: The C/FORTH assembler program (which also finds other
  uses), the Assembler that is to run on the device and finally the VHDL that implements
  the device itself.

  I have used other peoples modules in this project and that will be clearly labelled,
  the intention was to use them and then swap them out, but some have increased
  functionality above the original goals and there were time constraints as well.

  The project is available on Github here: \url{https://github.com/howerj/fyp.git} .

  I intend to continue working on the project after university improving functionality,
  rewriting sections and porting to different devices.

  \section{Project Goals}
  % Ease of use, modularity, code portability.

  \section{Tools used}
  
  As this project is entirely software based you will need a list of all the tools
  I have chosen, that will be included in this section as well as why I have used
  these tools.

    \subsection{Tools list}

    As of the $27^{th}$ of April, 2013, I have used the following to run and develop
    my project:

    \begin{itemize}
      \item Debian 6.0 (This includes a lot of the software used, eg. Gcc)
      \item Xilinx Webpack ISE 14.2 (Free for students).
      \item Git, A distributed version control system.
      \item GHDL, Digital simulation for VHDL.
      \item GTKWave, Waveform viewer.
      \item Make, For the VHDL build process.
      \item Gcc, The GNU C compiler.
      \item Bash, command interpreter.
      \item Digilent's programmer for the Nexys 3 device.
    \end{itemize}


  \section{The Hardware}
  % Nexys 3 Development board.

  \subsection{Basic system overview}
  % Stack based machines.
  % I/O System.

  \section{VHDL}

  The main thrust of this project lies in the VHDL, all of this project revolves around
  the architecture defined here. Although most of the assembler was created separately
  as a fully blown language, the definitions for the instructions are dependant on what 
  is going on in the CPU core naturally.

    \subsection{J1}
  
    The project is built around a translation and improvement of the J1 core \findcite{J1},
    a small stack processor built in Verilog and optimized to efficiently execute FORTH
    instructions, most of which can be executed in one clock cycle. It was perfectly suited
    for my project although it was not written in my language of choice.

    \subsection{H2}

    The original core was written in Verilog, a language that lends itself to more
    compact code and where things are not as explicit, for example the exact size of
    variables.

    Getting the translation to work was fairly challenging and I also experimented with
    the core more, I moved some instructions around to allow for more ALU operations
    and added a few more instructions.

    I renamed this core the \textbf{"H2"} and it will be referred to by either this name
    or as \textbf{"CPU"} unless I say it refers to another one.

    \subsubsection{Why a stack machine?}
    \findcite{stack machines, the new wave}

    Stack machines have several advantages when it comes to embedded development compared
    to the more mainstream register machines, naturally they have disadvantages also which
    will be addressed, but they do not really apply here.

    % Why stack machines?
      % Small.
      % Dense code.
      % Minimal internal state -> Fast interrupts.
      % Simpler interpreters/compilers.

    % Simple optimization Flip flops to distributed RAM.
      %% Slowed things down.
    % Multiplier.
    % Core description

    \subsubsection{The H2 Core}

    % Jump indirection.

    \subsection{VGA}
    \subsection{UART}

      The UART is the primary method of talking to the device, it is customizable at
      compile time.

    \subsection{RAM and other inferred modules}

      Instead of using Xilinx specific components you can use VHDL to create code that
      fits a certain template, this template is picked up by the synthesizer and you  
      can then verify if this is what you intended. Using this instead of instantiating
      proprietary blocks and loading the RAM with proprietary tools is a much better
      way of doing things that allows me more flexibility in how I go about things.

      The VGA unit and the CPU both have their own RAM blocks, two for the former and
      one for the latter. They are initialized from an ASCII encoded binary format,
      which while not efficient is certainly easy to process with the given tools.

      For a given file describing the RAM, for example \textbf{"h2\_mem.vhd"}, 
      the initial contents will be described in a file called \textbf{"h2\_mem.binary"}.

      All the RAM used is dual port this greatly simplifies the design, if I had to single
      port RAM I would have to worry about moving data in and out of the devices and the
      timing of it in much greater detail, it would also slow a lot of things down. For example
      the CPU would either have to adopt a Harvard architecture instead of a Von Neumann 
      or suffer a slow down.

      % Read from a file.
    \subsection{Top level}
    \subsection{Test benches and waveforms}
      % Given X show Y. Show the assembly program and the wave form that results from it.
    \subsection{Optimizations}
  \section{Build system}
    \subsection{Test benches}
    \subsection{FORTH}
    \subsection{Miscellaneous}
      % Git, make, shell.

  \section{Problems}
    \subsection{Build time}
    \subsection{Debugging}

  \section{Documentation}

  In this section I will provide a terse (terse in the sense that this should
  be its own paper) about the system.

    \subsection{FORTH interpreter}

    Instead of being a stand alone program with only one use I decided to create
    a full blown and reusable programming language in C, the reason for the extra
    complexity is because of its utility, I have used this program not only as an
    assembler but as part of the build process in ways that are not shown in the
    code (for example for converting between file formats).

    The interpreter can trace its lineage back to an entry to the IOCCC \footnote{
    The IOCCC is the International Obfuscated C Coding Competition, the entry can
    be found here: \url{http://www.ioccc.org/all/all.tar.bz2} in the folder '1992'
    for 'buzzard.2'.}. The interpreter is drastically different from the original,
    being a complete rewrite although there are still similarities. 

    The program interprets threaded code \findcite{Threaded code} for a stack machine,
    the C program does the initial heavy lifting allowing users to interpret commands
    but it is severely lacking in capabilities initially. The trick is to write most
    of the language \emph{in itself}. This maybe odd to people coming from a background
    in a 'normal' compiled language such as C/C++ or Java. You do not modify or extend
    the language itself but instead provide new functionality via libraries you have
    written.

    Initially the language does not even have basic elements such as the "if ... else ... then"
    statements or even loops, they are written in the language itself. FORTH, and my
    dialect of it, has the ability that its syntax can be changed arbitrarily. Lets say
    you want to make an interpreter for a different language, lets say lisp, you could
    do that and start executing lisp, while at the same time it would be a valid FORTH
    program as well.

      \subsubsection{The C Program}

      The C program itself is design to be portable being written entirely in ANSI C \findcite{
      ANSI C}, I have had this program running on my phone, and plan with some minor adjustments
      to have this running on a few embedded systems.

      \subsubsection{Basic commands and ideas}
      % References to other tutorials.
      % READ, CREATE, making IF...ELSE...THEN, recursion.
    \subsection{H2 CPU}
      \subsubsection{Assembly}

   \section{Future plans}
    % More generic CPU core

    I intend to keep working on this project after I have finished university, it offers the
    potential to provide a nearly complete work bench for home use and by this you will see
    what I mean.

    There are some general improvements that could be made; making the code more uniform
    through out, adding variable stack sizes and word sizes, improving the instruction set,
    much more thorough testing (and proofs there of).

    The potential improvements here are outside the scope of the project, they were never
    intended to be included in it as I would not have had time to do so, however when I
    started the project I did have these as an eventual end goal. The platform has a lot of
    potential.

    \subsection{Hardware}

      The hardware section is the one that offers the most potential when it comes to
      what can be improved with the device, although it is the section that will move
      most slowly as HDLs can be difficult to debug, more so than normal programs.

      \subsubsection{Different platforms}
        % Papilo one
      One of the goals of this project was portable of code and not just to different
      Xilinx devices either. I would like to port this system to cheaper hardware
      such as the "Papilio One". \findcite{http://papilio.cc/} This system while less
      functional costs a fraction of the Nexys 3. While the project would be more
      constrained, it should still be able to fit on the device with ease.

      I would like to get my code running on as many platforms as possible, while it
      \emph{should} be portable you can never truly find out until you have tested
      it on the real thing.

      \subsubsection{More generic code}
        % Give examples
      \subsubsection{PS/2 or USB keyboard}
      \subsubsection{Signal Generator}

      A signal generator should be fairly easy to design, at least internally, the
      main problem would be designing the external analogue components to work from
      ~1Hz to 100MHz (or a fraction thereof).

      The VHDL would consist of a block RAM holding the data, for example a sine wave
      or another arbitrary signal, a counter, a pointer into the memory and a few
      registers to control the device. As the RAM being used is dual port, it is
      possible to run two signals from the same RAM at a sacrifice or precision.

      This would be output in parallel over some of the boards standard I/O pins
      to a digital to analogue converter.

      \subsubsection{Data logger}
      \subsubsection{Logic Analyser}

      With very minimal additions a logic analyser running at the speed of the device
      ($\frac{1 Sample}{Clock Cycle}$) should be attainable, the unit does not have
      to be directly controlled by the CPU core, perhaps only by setting a few registers
      to tell it how fast to sample and how much, when to begin and end and where to
      send the data.

      I can see the main problems being in where to store the data and how to get it
      off the board, I would need a faster method of communications than the UART
      unless I only intend to capture roughly 16 Kilobytes of data at a time.

      The external hardware would be quite simple, just a way to buffer and electrically
      isolate the signal from the input pins of the device.

      Instead of displaying the data on the device, it should be done instead on a
      normal desktop, at least initially.

      \subsubsection{Multiple cores}

      Due to the tiny amount of resources that are taken up by the CPU it should be
      possible to have more than on CPU core running on the platform at the same
      time, perhaps a dedicated CPU for each peripheral with one master? It would
      be a relatively easy way of increasing the power of the system.

      This is however not a priority, first increasing functionality of the base
      system by adding the aforementioned peripherals would be of greater initial
      utility, then adding more cores would be considered.

      \subsubsection{Miscellaneous}
      % Timers, PWM, I2C, interrupts, multiplier! 

    \subsection{Firmware}
    \subsection{Build system}
        % More FORTH! As a show case for my language.

  \section{Contact details and licenses}
  \section{Conclusion}
    \subsection{What I would have done differently}
    \subsection{Project achievements}
  \section{References}
  \section{Appendix}
\end 	{document}
